// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import {
  type XdrCodec,
  int32,
  uint32,
  int64,
  uint64,
  float32,
  float64,
  bool,
  xdrVoid,
  fixedOpaque,
  varOpaque,
  xdrString,
  fixedArray,
  varArray,
  option,
  lazy,
  xdrStruct,
  xdrEnum,
  taggedUnion,
} from 'ts-stellar-xdr';

export type Uint32 = number;
export const Uint32: XdrCodec<Uint32> = uint32;

export interface ConfigSettingContractExecutionLanesV0 {
  readonly ledgerMaxTxCount: Uint32;
}
export const ConfigSettingContractExecutionLanesV0: XdrCodec<ConfigSettingContractExecutionLanesV0> = xdrStruct<ConfigSettingContractExecutionLanesV0>([
  ['ledgerMaxTxCount', Uint32],
]);

export type Int64 = bigint;
export const Int64: XdrCodec<Int64> = int64;

export interface ConfigSettingContractComputeV0 {
  readonly ledgerMaxInstructions: Int64;
  readonly txMaxInstructions: Int64;
  readonly feeRatePerInstructionsIncrement: Int64;
  readonly txMemoryLimit: Uint32;
}
export const ConfigSettingContractComputeV0: XdrCodec<ConfigSettingContractComputeV0> = xdrStruct<ConfigSettingContractComputeV0>([
  ['ledgerMaxInstructions', Int64],
  ['txMaxInstructions', Int64],
  ['feeRatePerInstructionsIncrement', Int64],
  ['txMemoryLimit', Uint32],
]);

export interface ConfigSettingContractParallelComputeV0 {
  readonly ledgerMaxDependentTxClusters: Uint32;
}
export const ConfigSettingContractParallelComputeV0: XdrCodec<ConfigSettingContractParallelComputeV0> = xdrStruct<ConfigSettingContractParallelComputeV0>([
  ['ledgerMaxDependentTxClusters', Uint32],
]);

export interface ConfigSettingContractLedgerCostV0 {
  readonly ledgerMaxDiskReadEntries: Uint32;
  readonly ledgerMaxDiskReadBytes: Uint32;
  readonly ledgerMaxWriteLedgerEntries: Uint32;
  readonly ledgerMaxWriteBytes: Uint32;
  readonly txMaxDiskReadEntries: Uint32;
  readonly txMaxDiskReadBytes: Uint32;
  readonly txMaxWriteLedgerEntries: Uint32;
  readonly txMaxWriteBytes: Uint32;
  readonly feeDiskReadLedgerEntry: Int64;
  readonly feeWriteLedgerEntry: Int64;
  readonly feeDiskRead1KB: Int64;
  readonly sorobanStateTargetSizeBytes: Int64;
  readonly rentFee1KBSorobanStateSizeLow: Int64;
  readonly rentFee1KBSorobanStateSizeHigh: Int64;
  readonly sorobanStateRentFeeGrowthFactor: Uint32;
}
export const ConfigSettingContractLedgerCostV0: XdrCodec<ConfigSettingContractLedgerCostV0> = xdrStruct<ConfigSettingContractLedgerCostV0>([
  ['ledgerMaxDiskReadEntries', Uint32],
  ['ledgerMaxDiskReadBytes', Uint32],
  ['ledgerMaxWriteLedgerEntries', Uint32],
  ['ledgerMaxWriteBytes', Uint32],
  ['txMaxDiskReadEntries', Uint32],
  ['txMaxDiskReadBytes', Uint32],
  ['txMaxWriteLedgerEntries', Uint32],
  ['txMaxWriteBytes', Uint32],
  ['feeDiskReadLedgerEntry', Int64],
  ['feeWriteLedgerEntry', Int64],
  ['feeDiskRead1KB', Int64],
  ['sorobanStateTargetSizeBytes', Int64],
  ['rentFee1KBSorobanStateSizeLow', Int64],
  ['rentFee1KBSorobanStateSizeHigh', Int64],
  ['sorobanStateRentFeeGrowthFactor', Uint32],
]);

export interface ConfigSettingContractLedgerCostExtV0 {
  readonly txMaxFootprintEntries: Uint32;
  readonly feeWrite1KB: Int64;
}
export const ConfigSettingContractLedgerCostExtV0: XdrCodec<ConfigSettingContractLedgerCostExtV0> = xdrStruct<ConfigSettingContractLedgerCostExtV0>([
  ['txMaxFootprintEntries', Uint32],
  ['feeWrite1KB', Int64],
]);

export interface ConfigSettingContractHistoricalDataV0 {
  readonly feeHistorical1KB: Int64;
}
export const ConfigSettingContractHistoricalDataV0: XdrCodec<ConfigSettingContractHistoricalDataV0> = xdrStruct<ConfigSettingContractHistoricalDataV0>([
  ['feeHistorical1KB', Int64],
]);

export interface ConfigSettingContractEventsV0 {
  readonly txMaxContractEventsSizeBytes: Uint32;
  readonly feeContractEvents1KB: Int64;
}
export const ConfigSettingContractEventsV0: XdrCodec<ConfigSettingContractEventsV0> = xdrStruct<ConfigSettingContractEventsV0>([
  ['txMaxContractEventsSizeBytes', Uint32],
  ['feeContractEvents1KB', Int64],
]);

export interface ConfigSettingContractBandwidthV0 {
  readonly ledgerMaxTxsSizeBytes: Uint32;
  readonly txMaxSizeBytes: Uint32;
  readonly feeTxSize1KB: Int64;
}
export const ConfigSettingContractBandwidthV0: XdrCodec<ConfigSettingContractBandwidthV0> = xdrStruct<ConfigSettingContractBandwidthV0>([
  ['ledgerMaxTxsSizeBytes', Uint32],
  ['txMaxSizeBytes', Uint32],
  ['feeTxSize1KB', Int64],
]);

export type ContractCostType = 'WasmInsnExec' | 'MemAlloc' | 'MemCpy' | 'MemCmp' | 'DispatchHostFunction' | 'VisitObject' | 'ValSer' | 'ValDeser' | 'ComputeSha256Hash' | 'ComputeEd25519PubKey' | 'VerifyEd25519Sig' | 'VmInstantiation' | 'VmCachedInstantiation' | 'InvokeVmFunction' | 'ComputeKeccak256Hash' | 'DecodeEcdsaCurve256Sig' | 'RecoverEcdsaSecp256k1Key' | 'Int256AddSub' | 'Int256Mul' | 'Int256Div' | 'Int256Pow' | 'Int256Shift' | 'ChaCha20DrawBytes' | 'ParseWasmInstructions' | 'ParseWasmFunctions' | 'ParseWasmGlobals' | 'ParseWasmTableEntries' | 'ParseWasmTypes' | 'ParseWasmDataSegments' | 'ParseWasmElemSegments' | 'ParseWasmImports' | 'ParseWasmExports' | 'ParseWasmDataSegmentBytes' | 'InstantiateWasmInstructions' | 'InstantiateWasmFunctions' | 'InstantiateWasmGlobals' | 'InstantiateWasmTableEntries' | 'InstantiateWasmTypes' | 'InstantiateWasmDataSegments' | 'InstantiateWasmElemSegments' | 'InstantiateWasmImports' | 'InstantiateWasmExports' | 'InstantiateWasmDataSegmentBytes' | 'Sec1DecodePointUncompressed' | 'VerifyEcdsaSecp256r1Sig' | 'Bls12381EncodeFp' | 'Bls12381DecodeFp' | 'Bls12381G1CheckPointOnCurve' | 'Bls12381G1CheckPointInSubgroup' | 'Bls12381G2CheckPointOnCurve' | 'Bls12381G2CheckPointInSubgroup' | 'Bls12381G1ProjectiveToAffine' | 'Bls12381G2ProjectiveToAffine' | 'Bls12381G1Add' | 'Bls12381G1Mul' | 'Bls12381G1Msm' | 'Bls12381MapFpToG1' | 'Bls12381HashToG1' | 'Bls12381G2Add' | 'Bls12381G2Mul' | 'Bls12381G2Msm' | 'Bls12381MapFp2ToG2' | 'Bls12381HashToG2' | 'Bls12381Pairing' | 'Bls12381FrFromU256' | 'Bls12381FrToU256' | 'Bls12381FrAddSub' | 'Bls12381FrMul' | 'Bls12381FrPow' | 'Bls12381FrInv' | 'Bn254EncodeFp' | 'Bn254DecodeFp' | 'Bn254G1CheckPointOnCurve' | 'Bn254G2CheckPointOnCurve' | 'Bn254G2CheckPointInSubgroup' | 'Bn254G1ProjectiveToAffine' | 'Bn254G1Add' | 'Bn254G1Mul' | 'Bn254Pairing' | 'Bn254FrFromU256' | 'Bn254FrToU256' | 'Bn254FrAddSub' | 'Bn254FrMul' | 'Bn254FrPow' | 'Bn254FrInv';
export const ContractCostType = xdrEnum({
  WasmInsnExec: 0,
  MemAlloc: 1,
  MemCpy: 2,
  MemCmp: 3,
  DispatchHostFunction: 4,
  VisitObject: 5,
  ValSer: 6,
  ValDeser: 7,
  ComputeSha256Hash: 8,
  ComputeEd25519PubKey: 9,
  VerifyEd25519Sig: 10,
  VmInstantiation: 11,
  VmCachedInstantiation: 12,
  InvokeVmFunction: 13,
  ComputeKeccak256Hash: 14,
  DecodeEcdsaCurve256Sig: 15,
  RecoverEcdsaSecp256k1Key: 16,
  Int256AddSub: 17,
  Int256Mul: 18,
  Int256Div: 19,
  Int256Pow: 20,
  Int256Shift: 21,
  ChaCha20DrawBytes: 22,
  ParseWasmInstructions: 23,
  ParseWasmFunctions: 24,
  ParseWasmGlobals: 25,
  ParseWasmTableEntries: 26,
  ParseWasmTypes: 27,
  ParseWasmDataSegments: 28,
  ParseWasmElemSegments: 29,
  ParseWasmImports: 30,
  ParseWasmExports: 31,
  ParseWasmDataSegmentBytes: 32,
  InstantiateWasmInstructions: 33,
  InstantiateWasmFunctions: 34,
  InstantiateWasmGlobals: 35,
  InstantiateWasmTableEntries: 36,
  InstantiateWasmTypes: 37,
  InstantiateWasmDataSegments: 38,
  InstantiateWasmElemSegments: 39,
  InstantiateWasmImports: 40,
  InstantiateWasmExports: 41,
  InstantiateWasmDataSegmentBytes: 42,
  Sec1DecodePointUncompressed: 43,
  VerifyEcdsaSecp256r1Sig: 44,
  Bls12381EncodeFp: 45,
  Bls12381DecodeFp: 46,
  Bls12381G1CheckPointOnCurve: 47,
  Bls12381G1CheckPointInSubgroup: 48,
  Bls12381G2CheckPointOnCurve: 49,
  Bls12381G2CheckPointInSubgroup: 50,
  Bls12381G1ProjectiveToAffine: 51,
  Bls12381G2ProjectiveToAffine: 52,
  Bls12381G1Add: 53,
  Bls12381G1Mul: 54,
  Bls12381G1Msm: 55,
  Bls12381MapFpToG1: 56,
  Bls12381HashToG1: 57,
  Bls12381G2Add: 58,
  Bls12381G2Mul: 59,
  Bls12381G2Msm: 60,
  Bls12381MapFp2ToG2: 61,
  Bls12381HashToG2: 62,
  Bls12381Pairing: 63,
  Bls12381FrFromU256: 64,
  Bls12381FrToU256: 65,
  Bls12381FrAddSub: 66,
  Bls12381FrMul: 67,
  Bls12381FrPow: 68,
  Bls12381FrInv: 69,
  Bn254EncodeFp: 70,
  Bn254DecodeFp: 71,
  Bn254G1CheckPointOnCurve: 72,
  Bn254G2CheckPointOnCurve: 73,
  Bn254G2CheckPointInSubgroup: 74,
  Bn254G1ProjectiveToAffine: 75,
  Bn254G1Add: 76,
  Bn254G1Mul: 77,
  Bn254Pairing: 78,
  Bn254FrFromU256: 79,
  Bn254FrToU256: 80,
  Bn254FrAddSub: 81,
  Bn254FrMul: 82,
  Bn254FrPow: 83,
  Bn254FrInv: 84,
});

export type ExtensionPoint =
  | { readonly tag: 0 }
;

export const ExtensionPoint: XdrCodec<ExtensionPoint> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<ExtensionPoint>;

export interface ContractCostParamEntry {
  readonly ext: ExtensionPoint;
  readonly constTerm: Int64;
  readonly linearTerm: Int64;
}
export const ContractCostParamEntry: XdrCodec<ContractCostParamEntry> = xdrStruct<ContractCostParamEntry>([
  ['ext', ExtensionPoint],
  ['constTerm', Int64],
  ['linearTerm', Int64],
]);

export interface StateArchivalSettings {
  readonly maxEntryTTL: Uint32;
  readonly minTemporaryTTL: Uint32;
  readonly minPersistentTTL: Uint32;
  readonly persistentRentRateDenominator: Int64;
  readonly tempRentRateDenominator: Int64;
  readonly maxEntriesToArchive: Uint32;
  readonly liveSorobanStateSizeWindowSampleSize: Uint32;
  readonly liveSorobanStateSizeWindowSamplePeriod: Uint32;
  readonly evictionScanSize: Uint32;
  readonly startingEvictionScanLevel: Uint32;
}
export const StateArchivalSettings: XdrCodec<StateArchivalSettings> = xdrStruct<StateArchivalSettings>([
  ['maxEntryTTL', Uint32],
  ['minTemporaryTTL', Uint32],
  ['minPersistentTTL', Uint32],
  ['persistentRentRateDenominator', Int64],
  ['tempRentRateDenominator', Int64],
  ['maxEntriesToArchive', Uint32],
  ['liveSorobanStateSizeWindowSampleSize', Uint32],
  ['liveSorobanStateSizeWindowSamplePeriod', Uint32],
  ['evictionScanSize', Uint32],
  ['startingEvictionScanLevel', Uint32],
]);

export type Uint64 = bigint;
export const Uint64: XdrCodec<Uint64> = uint64;

export interface EvictionIterator {
  readonly bucketListLevel: Uint32;
  readonly isCurrBucket: boolean;
  readonly bucketFileOffset: Uint64;
}
export const EvictionIterator: XdrCodec<EvictionIterator> = xdrStruct<EvictionIterator>([
  ['bucketListLevel', Uint32],
  ['isCurrBucket', bool],
  ['bucketFileOffset', Uint64],
]);

export interface ConfigSettingSCPTiming {
  readonly ledgerTargetCloseTimeMilliseconds: Uint32;
  readonly nominationTimeoutInitialMilliseconds: Uint32;
  readonly nominationTimeoutIncrementMilliseconds: Uint32;
  readonly ballotTimeoutInitialMilliseconds: Uint32;
  readonly ballotTimeoutIncrementMilliseconds: Uint32;
}
export const ConfigSettingSCPTiming: XdrCodec<ConfigSettingSCPTiming> = xdrStruct<ConfigSettingSCPTiming>([
  ['ledgerTargetCloseTimeMilliseconds', Uint32],
  ['nominationTimeoutInitialMilliseconds', Uint32],
  ['nominationTimeoutIncrementMilliseconds', Uint32],
  ['ballotTimeoutInitialMilliseconds', Uint32],
  ['ballotTimeoutIncrementMilliseconds', Uint32],
]);

export const CONTRACT_COST_COUNT_LIMIT = 1024;

export type ContractCostParams = readonly ContractCostParamEntry[];
export const ContractCostParams: XdrCodec<ContractCostParams> = varArray(CONTRACT_COST_COUNT_LIMIT, ContractCostParamEntry);

export type ConfigSettingID = 'ContractMaxSizeBytes' | 'ContractComputeV0' | 'ContractLedgerCostV0' | 'ContractHistoricalDataV0' | 'ContractEventsV0' | 'ContractBandwidthV0' | 'ContractCostParamsCpuInstructions' | 'ContractCostParamsMemoryBytes' | 'ContractDataKeySizeBytes' | 'ContractDataEntrySizeBytes' | 'StateArchival' | 'ContractExecutionLanes' | 'LiveSorobanStateSizeWindow' | 'EvictionIterator' | 'ContractParallelComputeV0' | 'ContractLedgerCostExtV0' | 'ScpTiming';
export const ConfigSettingID = xdrEnum({
  ContractMaxSizeBytes: 0,
  ContractComputeV0: 1,
  ContractLedgerCostV0: 2,
  ContractHistoricalDataV0: 3,
  ContractEventsV0: 4,
  ContractBandwidthV0: 5,
  ContractCostParamsCpuInstructions: 6,
  ContractCostParamsMemoryBytes: 7,
  ContractDataKeySizeBytes: 8,
  ContractDataEntrySizeBytes: 9,
  StateArchival: 10,
  ContractExecutionLanes: 11,
  LiveSorobanStateSizeWindow: 12,
  EvictionIterator: 13,
  ContractParallelComputeV0: 14,
  ContractLedgerCostExtV0: 15,
  ScpTiming: 16,
});

export type ConfigSettingEntry =
  | { readonly tag: 'ContractMaxSizeBytes'; readonly value: Uint32 }
  | { readonly tag: 'ContractComputeV0'; readonly value: ConfigSettingContractComputeV0 }
  | { readonly tag: 'ContractLedgerCostV0'; readonly value: ConfigSettingContractLedgerCostV0 }
  | { readonly tag: 'ContractHistoricalDataV0'; readonly value: ConfigSettingContractHistoricalDataV0 }
  | { readonly tag: 'ContractEventsV0'; readonly value: ConfigSettingContractEventsV0 }
  | { readonly tag: 'ContractBandwidthV0'; readonly value: ConfigSettingContractBandwidthV0 }
  | { readonly tag: 'ContractCostParamsCpuInstructions'; readonly value: ContractCostParams }
  | { readonly tag: 'ContractCostParamsMemoryBytes'; readonly value: ContractCostParams }
  | { readonly tag: 'ContractDataKeySizeBytes'; readonly value: Uint32 }
  | { readonly tag: 'ContractDataEntrySizeBytes'; readonly value: Uint32 }
  | { readonly tag: 'StateArchival'; readonly value: StateArchivalSettings }
  | { readonly tag: 'ContractExecutionLanes'; readonly value: ConfigSettingContractExecutionLanesV0 }
  | { readonly tag: 'LiveSorobanStateSizeWindow'; readonly value: readonly Uint64[] }
  | { readonly tag: 'EvictionIterator'; readonly value: EvictionIterator }
  | { readonly tag: 'ContractParallelComputeV0'; readonly value: ConfigSettingContractParallelComputeV0 }
  | { readonly tag: 'ContractLedgerCostExtV0'; readonly value: ConfigSettingContractLedgerCostExtV0 }
  | { readonly tag: 'ScpTiming'; readonly value: ConfigSettingSCPTiming }
;

export const ConfigSettingEntry: XdrCodec<ConfigSettingEntry> = taggedUnion({
  switchOn: ConfigSettingID,
  arms: [
    { tags: ['ContractMaxSizeBytes'], codec: Uint32 },
    { tags: ['ContractComputeV0'], codec: ConfigSettingContractComputeV0 },
    { tags: ['ContractLedgerCostV0'], codec: ConfigSettingContractLedgerCostV0 },
    { tags: ['ContractHistoricalDataV0'], codec: ConfigSettingContractHistoricalDataV0 },
    { tags: ['ContractEventsV0'], codec: ConfigSettingContractEventsV0 },
    { tags: ['ContractBandwidthV0'], codec: ConfigSettingContractBandwidthV0 },
    { tags: ['ContractCostParamsCpuInstructions'], codec: ContractCostParams },
    { tags: ['ContractCostParamsMemoryBytes'], codec: ContractCostParams },
    { tags: ['ContractDataKeySizeBytes'], codec: Uint32 },
    { tags: ['ContractDataEntrySizeBytes'], codec: Uint32 },
    { tags: ['StateArchival'], codec: StateArchivalSettings },
    { tags: ['ContractExecutionLanes'], codec: ConfigSettingContractExecutionLanesV0 },
    { tags: ['LiveSorobanStateSizeWindow'], codec: varArray(2147483647, Uint64) },
    { tags: ['EvictionIterator'], codec: EvictionIterator },
    { tags: ['ContractParallelComputeV0'], codec: ConfigSettingContractParallelComputeV0 },
    { tags: ['ContractLedgerCostExtV0'], codec: ConfigSettingContractLedgerCostExtV0 },
    { tags: ['ScpTiming'], codec: ConfigSettingSCPTiming },
  ],
}) as XdrCodec<ConfigSettingEntry>;

export type SCEnvMetaKind = 'ScEnvMetaKindInterfaceVersion';
export const SCEnvMetaKind = xdrEnum({
  ScEnvMetaKindInterfaceVersion: 0,
});

export interface SCEnvMetaEntryInterfaceVersion {
  readonly protocol: Uint32;
  readonly preRelease: Uint32;
}
export const SCEnvMetaEntryInterfaceVersion: XdrCodec<SCEnvMetaEntryInterfaceVersion> = xdrStruct<SCEnvMetaEntryInterfaceVersion>([
  ['protocol', Uint32],
  ['preRelease', Uint32],
]);

export type SCEnvMetaEntry =
  | { readonly tag: 'ScEnvMetaKindInterfaceVersion'; readonly value: SCEnvMetaEntryInterfaceVersion }
;

export const SCEnvMetaEntry: XdrCodec<SCEnvMetaEntry> = taggedUnion({
  switchOn: SCEnvMetaKind,
  arms: [
    { tags: ['ScEnvMetaKindInterfaceVersion'], codec: SCEnvMetaEntryInterfaceVersion },
  ],
}) as XdrCodec<SCEnvMetaEntry>;

export interface SCMetaV0 {
  readonly key: string;
  readonly val: string;
}
export const SCMetaV0: XdrCodec<SCMetaV0> = xdrStruct<SCMetaV0>([
  ['key', xdrString(2147483647)],
  ['val', xdrString(2147483647)],
]);

export type SCMetaKind = 'ScMetaV0';
export const SCMetaKind = xdrEnum({
  ScMetaV0: 0,
});

export type SCMetaEntry =
  | { readonly tag: 'ScMetaV0'; readonly value: SCMetaV0 }
;

export const SCMetaEntry: XdrCodec<SCMetaEntry> = taggedUnion({
  switchOn: SCMetaKind,
  arms: [
    { tags: ['ScMetaV0'], codec: SCMetaV0 },
  ],
}) as XdrCodec<SCMetaEntry>;

export const SC_SPEC_DOC_LIMIT = 1024;

export type SCSpecType = 'Val' | 'Bool' | 'Void' | 'Error' | 'U32' | 'I32' | 'U64' | 'I64' | 'Timepoint' | 'Duration' | 'U128' | 'I128' | 'U256' | 'I256' | 'Bytes' | 'String' | 'Symbol' | 'Address' | 'MuxedAddress' | 'Option' | 'Result' | 'Vec' | 'Map' | 'Tuple' | 'BytesN' | 'Udt';
export const SCSpecType = xdrEnum({
  Val: 0,
  Bool: 1,
  Void: 2,
  Error: 3,
  U32: 4,
  I32: 5,
  U64: 6,
  I64: 7,
  Timepoint: 8,
  Duration: 9,
  U128: 10,
  I128: 11,
  U256: 12,
  I256: 13,
  Bytes: 14,
  String: 16,
  Symbol: 17,
  Address: 19,
  MuxedAddress: 20,
  Option: 1000,
  Result: 1001,
  Vec: 1002,
  Map: 1004,
  Tuple: 1005,
  BytesN: 1006,
  Udt: 2000,
});

export interface SCSpecTypeResult {
  readonly okType: SCSpecTypeDef;
  readonly errorType: SCSpecTypeDef;
}
export const SCSpecTypeResult: XdrCodec<SCSpecTypeResult> = xdrStruct<SCSpecTypeResult>([
  ['okType', lazy(() => SCSpecTypeDef)],
  ['errorType', lazy(() => SCSpecTypeDef)],
]);

export interface SCSpecTypeVec {
  readonly elementType: SCSpecTypeDef;
}
export const SCSpecTypeVec: XdrCodec<SCSpecTypeVec> = xdrStruct<SCSpecTypeVec>([
  ['elementType', lazy(() => SCSpecTypeDef)],
]);

export interface SCSpecTypeMap {
  readonly keyType: SCSpecTypeDef;
  readonly valueType: SCSpecTypeDef;
}
export const SCSpecTypeMap: XdrCodec<SCSpecTypeMap> = xdrStruct<SCSpecTypeMap>([
  ['keyType', lazy(() => SCSpecTypeDef)],
  ['valueType', lazy(() => SCSpecTypeDef)],
]);

export interface SCSpecTypeTuple {
  readonly valueTypes: readonly SCSpecTypeDef[];
}
export const SCSpecTypeTuple: XdrCodec<SCSpecTypeTuple> = xdrStruct<SCSpecTypeTuple>([
  ['valueTypes', varArray(12, lazy(() => SCSpecTypeDef))],
]);

export interface SCSpecTypeBytesN {
  readonly n: Uint32;
}
export const SCSpecTypeBytesN: XdrCodec<SCSpecTypeBytesN> = xdrStruct<SCSpecTypeBytesN>([
  ['n', Uint32],
]);

export interface SCSpecTypeUDT {
  readonly name: string;
}
export const SCSpecTypeUDT: XdrCodec<SCSpecTypeUDT> = xdrStruct<SCSpecTypeUDT>([
  ['name', xdrString(60)],
]);

export type SCSpecTypeDef =
  | { readonly tag: 'Val' }
  | { readonly tag: 'Bool' }
  | { readonly tag: 'Void' }
  | { readonly tag: 'Error' }
  | { readonly tag: 'U32' }
  | { readonly tag: 'I32' }
  | { readonly tag: 'U64' }
  | { readonly tag: 'I64' }
  | { readonly tag: 'Timepoint' }
  | { readonly tag: 'Duration' }
  | { readonly tag: 'U128' }
  | { readonly tag: 'I128' }
  | { readonly tag: 'U256' }
  | { readonly tag: 'I256' }
  | { readonly tag: 'Bytes' }
  | { readonly tag: 'String' }
  | { readonly tag: 'Symbol' }
  | { readonly tag: 'Address' }
  | { readonly tag: 'MuxedAddress' }
  | { readonly tag: 'Option'; readonly value: SCSpecTypeOption }
  | { readonly tag: 'Result'; readonly value: SCSpecTypeResult }
  | { readonly tag: 'Vec'; readonly value: SCSpecTypeVec }
  | { readonly tag: 'Map'; readonly value: SCSpecTypeMap }
  | { readonly tag: 'Tuple'; readonly value: SCSpecTypeTuple }
  | { readonly tag: 'BytesN'; readonly value: SCSpecTypeBytesN }
  | { readonly tag: 'Udt'; readonly value: SCSpecTypeUDT }
;

export const SCSpecTypeDef: XdrCodec<SCSpecTypeDef> = taggedUnion({
  switchOn: SCSpecType,
  arms: [
    { tags: ['Val', 'Bool', 'Void', 'Error', 'U32', 'I32', 'U64', 'I64', 'Timepoint', 'Duration', 'U128', 'I128', 'U256', 'I256', 'Bytes', 'String', 'Symbol', 'Address', 'MuxedAddress'] },
    { tags: ['Option'], codec: lazy(() => SCSpecTypeOption) },
    { tags: ['Result'], codec: SCSpecTypeResult },
    { tags: ['Vec'], codec: SCSpecTypeVec },
    { tags: ['Map'], codec: SCSpecTypeMap },
    { tags: ['Tuple'], codec: SCSpecTypeTuple },
    { tags: ['BytesN'], codec: SCSpecTypeBytesN },
    { tags: ['Udt'], codec: SCSpecTypeUDT },
  ],
}) as XdrCodec<SCSpecTypeDef>;

export interface SCSpecTypeOption {
  readonly valueType: SCSpecTypeDef;
}
export const SCSpecTypeOption: XdrCodec<SCSpecTypeOption> = xdrStruct<SCSpecTypeOption>([
  ['valueType', lazy(() => SCSpecTypeDef)],
]);

export interface SCSpecUDTStructFieldV0 {
  readonly doc: string;
  readonly name: string;
  readonly type: SCSpecTypeDef;
}
export const SCSpecUDTStructFieldV0: XdrCodec<SCSpecUDTStructFieldV0> = xdrStruct<SCSpecUDTStructFieldV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['name', xdrString(30)],
  ['type', lazy(() => SCSpecTypeDef)],
]);

export interface SCSpecUDTStructV0 {
  readonly doc: string;
  readonly lib: string;
  readonly name: string;
  readonly fields: readonly SCSpecUDTStructFieldV0[];
}
export const SCSpecUDTStructV0: XdrCodec<SCSpecUDTStructV0> = xdrStruct<SCSpecUDTStructV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['lib', xdrString(80)],
  ['name', xdrString(60)],
  ['fields', varArray(2147483647, SCSpecUDTStructFieldV0)],
]);

export interface SCSpecUDTUnionCaseVoidV0 {
  readonly doc: string;
  readonly name: string;
}
export const SCSpecUDTUnionCaseVoidV0: XdrCodec<SCSpecUDTUnionCaseVoidV0> = xdrStruct<SCSpecUDTUnionCaseVoidV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['name', xdrString(60)],
]);

export interface SCSpecUDTUnionCaseTupleV0 {
  readonly doc: string;
  readonly name: string;
  readonly type: readonly SCSpecTypeDef[];
}
export const SCSpecUDTUnionCaseTupleV0: XdrCodec<SCSpecUDTUnionCaseTupleV0> = xdrStruct<SCSpecUDTUnionCaseTupleV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['name', xdrString(60)],
  ['type', varArray(2147483647, lazy(() => SCSpecTypeDef))],
]);

export type SCSpecUDTUnionCaseV0Kind = 'VoidV0' | 'TupleV0';
export const SCSpecUDTUnionCaseV0Kind = xdrEnum({
  VoidV0: 0,
  TupleV0: 1,
});

export type SCSpecUDTUnionCaseV0 =
  | { readonly tag: 'VoidV0'; readonly value: SCSpecUDTUnionCaseVoidV0 }
  | { readonly tag: 'TupleV0'; readonly value: SCSpecUDTUnionCaseTupleV0 }
;

export const SCSpecUDTUnionCaseV0: XdrCodec<SCSpecUDTUnionCaseV0> = taggedUnion({
  switchOn: SCSpecUDTUnionCaseV0Kind,
  arms: [
    { tags: ['VoidV0'], codec: SCSpecUDTUnionCaseVoidV0 },
    { tags: ['TupleV0'], codec: SCSpecUDTUnionCaseTupleV0 },
  ],
}) as XdrCodec<SCSpecUDTUnionCaseV0>;

export interface SCSpecUDTUnionV0 {
  readonly doc: string;
  readonly lib: string;
  readonly name: string;
  readonly cases: readonly SCSpecUDTUnionCaseV0[];
}
export const SCSpecUDTUnionV0: XdrCodec<SCSpecUDTUnionV0> = xdrStruct<SCSpecUDTUnionV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['lib', xdrString(80)],
  ['name', xdrString(60)],
  ['cases', varArray(2147483647, SCSpecUDTUnionCaseV0)],
]);

export interface SCSpecUDTEnumCaseV0 {
  readonly doc: string;
  readonly name: string;
  readonly value: Uint32;
}
export const SCSpecUDTEnumCaseV0: XdrCodec<SCSpecUDTEnumCaseV0> = xdrStruct<SCSpecUDTEnumCaseV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['name', xdrString(60)],
  ['value', Uint32],
]);

export interface SCSpecUDTEnumV0 {
  readonly doc: string;
  readonly lib: string;
  readonly name: string;
  readonly cases: readonly SCSpecUDTEnumCaseV0[];
}
export const SCSpecUDTEnumV0: XdrCodec<SCSpecUDTEnumV0> = xdrStruct<SCSpecUDTEnumV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['lib', xdrString(80)],
  ['name', xdrString(60)],
  ['cases', varArray(2147483647, SCSpecUDTEnumCaseV0)],
]);

export interface SCSpecUDTErrorEnumCaseV0 {
  readonly doc: string;
  readonly name: string;
  readonly value: Uint32;
}
export const SCSpecUDTErrorEnumCaseV0: XdrCodec<SCSpecUDTErrorEnumCaseV0> = xdrStruct<SCSpecUDTErrorEnumCaseV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['name', xdrString(60)],
  ['value', Uint32],
]);

export interface SCSpecUDTErrorEnumV0 {
  readonly doc: string;
  readonly lib: string;
  readonly name: string;
  readonly cases: readonly SCSpecUDTErrorEnumCaseV0[];
}
export const SCSpecUDTErrorEnumV0: XdrCodec<SCSpecUDTErrorEnumV0> = xdrStruct<SCSpecUDTErrorEnumV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['lib', xdrString(80)],
  ['name', xdrString(60)],
  ['cases', varArray(2147483647, SCSpecUDTErrorEnumCaseV0)],
]);

export interface SCSpecFunctionInputV0 {
  readonly doc: string;
  readonly name: string;
  readonly type: SCSpecTypeDef;
}
export const SCSpecFunctionInputV0: XdrCodec<SCSpecFunctionInputV0> = xdrStruct<SCSpecFunctionInputV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['name', xdrString(30)],
  ['type', lazy(() => SCSpecTypeDef)],
]);

export const SCSYMBOL_LIMIT = 32;

export type SCSymbol = string;
export const SCSymbol: XdrCodec<SCSymbol> = xdrString(SCSYMBOL_LIMIT);

export interface SCSpecFunctionV0 {
  readonly doc: string;
  readonly name: SCSymbol;
  readonly inputs: readonly SCSpecFunctionInputV0[];
  readonly outputs: readonly SCSpecTypeDef[];
}
export const SCSpecFunctionV0: XdrCodec<SCSpecFunctionV0> = xdrStruct<SCSpecFunctionV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['name', SCSymbol],
  ['inputs', varArray(2147483647, SCSpecFunctionInputV0)],
  ['outputs', varArray(1, lazy(() => SCSpecTypeDef))],
]);

export type SCSpecEventParamLocationV0 = 'Data' | 'TopicList';
export const SCSpecEventParamLocationV0 = xdrEnum({
  Data: 0,
  TopicList: 1,
});

export interface SCSpecEventParamV0 {
  readonly doc: string;
  readonly name: string;
  readonly type: SCSpecTypeDef;
  readonly location: SCSpecEventParamLocationV0;
}
export const SCSpecEventParamV0: XdrCodec<SCSpecEventParamV0> = xdrStruct<SCSpecEventParamV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['name', xdrString(30)],
  ['type', lazy(() => SCSpecTypeDef)],
  ['location', SCSpecEventParamLocationV0],
]);

export type SCSpecEventDataFormat = 'SingleValue' | 'Vec' | 'Map';
export const SCSpecEventDataFormat = xdrEnum({
  SingleValue: 0,
  Vec: 1,
  Map: 2,
});

export interface SCSpecEventV0 {
  readonly doc: string;
  readonly lib: string;
  readonly name: SCSymbol;
  readonly prefixTopics: readonly SCSymbol[];
  readonly params: readonly SCSpecEventParamV0[];
  readonly dataFormat: SCSpecEventDataFormat;
}
export const SCSpecEventV0: XdrCodec<SCSpecEventV0> = xdrStruct<SCSpecEventV0>([
  ['doc', xdrString(SC_SPEC_DOC_LIMIT)],
  ['lib', xdrString(80)],
  ['name', SCSymbol],
  ['prefixTopics', varArray(2, SCSymbol)],
  ['params', varArray(2147483647, SCSpecEventParamV0)],
  ['dataFormat', SCSpecEventDataFormat],
]);

export type SCSpecEntryKind = 'FunctionV0' | 'UdtStructV0' | 'UdtUnionV0' | 'UdtEnumV0' | 'UdtErrorEnumV0' | 'EventV0';
export const SCSpecEntryKind = xdrEnum({
  FunctionV0: 0,
  UdtStructV0: 1,
  UdtUnionV0: 2,
  UdtEnumV0: 3,
  UdtErrorEnumV0: 4,
  EventV0: 5,
});

export type SCSpecEntry =
  | { readonly tag: 'FunctionV0'; readonly value: SCSpecFunctionV0 }
  | { readonly tag: 'UdtStructV0'; readonly value: SCSpecUDTStructV0 }
  | { readonly tag: 'UdtUnionV0'; readonly value: SCSpecUDTUnionV0 }
  | { readonly tag: 'UdtEnumV0'; readonly value: SCSpecUDTEnumV0 }
  | { readonly tag: 'UdtErrorEnumV0'; readonly value: SCSpecUDTErrorEnumV0 }
  | { readonly tag: 'EventV0'; readonly value: SCSpecEventV0 }
;

export const SCSpecEntry: XdrCodec<SCSpecEntry> = taggedUnion({
  switchOn: SCSpecEntryKind,
  arms: [
    { tags: ['FunctionV0'], codec: SCSpecFunctionV0 },
    { tags: ['UdtStructV0'], codec: SCSpecUDTStructV0 },
    { tags: ['UdtUnionV0'], codec: SCSpecUDTUnionV0 },
    { tags: ['UdtEnumV0'], codec: SCSpecUDTEnumV0 },
    { tags: ['UdtErrorEnumV0'], codec: SCSpecUDTErrorEnumV0 },
    { tags: ['EventV0'], codec: SCSpecEventV0 },
  ],
}) as XdrCodec<SCSpecEntry>;

export type SCValType = 'Bool' | 'Void' | 'Error' | 'U32' | 'I32' | 'U64' | 'I64' | 'Timepoint' | 'Duration' | 'U128' | 'I128' | 'U256' | 'I256' | 'Bytes' | 'String' | 'Symbol' | 'Vec' | 'Map' | 'Address' | 'ContractInstance' | 'LedgerKeyContractInstance' | 'LedgerKeyNonce';
export const SCValType = xdrEnum({
  Bool: 0,
  Void: 1,
  Error: 2,
  U32: 3,
  I32: 4,
  U64: 5,
  I64: 6,
  Timepoint: 7,
  Duration: 8,
  U128: 9,
  I128: 10,
  U256: 11,
  I256: 12,
  Bytes: 13,
  String: 14,
  Symbol: 15,
  Vec: 16,
  Map: 17,
  Address: 18,
  ContractInstance: 19,
  LedgerKeyContractInstance: 20,
  LedgerKeyNonce: 21,
});

export type SCErrorType = 'Contract' | 'WasmVm' | 'Context' | 'Storage' | 'Object' | 'Crypto' | 'Events' | 'Budget' | 'Value' | 'Auth';
export const SCErrorType = xdrEnum({
  Contract: 0,
  WasmVm: 1,
  Context: 2,
  Storage: 3,
  Object: 4,
  Crypto: 5,
  Events: 6,
  Budget: 7,
  Value: 8,
  Auth: 9,
});

export type SCErrorCode = 'ArithDomain' | 'IndexBounds' | 'InvalidInput' | 'MissingValue' | 'ExistingValue' | 'ExceededLimit' | 'InvalidAction' | 'InternalError' | 'UnexpectedType' | 'UnexpectedSize';
export const SCErrorCode = xdrEnum({
  ArithDomain: 0,
  IndexBounds: 1,
  InvalidInput: 2,
  MissingValue: 3,
  ExistingValue: 4,
  ExceededLimit: 5,
  InvalidAction: 6,
  InternalError: 7,
  UnexpectedType: 8,
  UnexpectedSize: 9,
});

export type SCError =
  | { readonly tag: 'Contract'; readonly value: Uint32 }
  | { readonly tag: 'WasmVm'; readonly value: SCErrorCode }
  | { readonly tag: 'Context'; readonly value: SCErrorCode }
  | { readonly tag: 'Storage'; readonly value: SCErrorCode }
  | { readonly tag: 'Object'; readonly value: SCErrorCode }
  | { readonly tag: 'Crypto'; readonly value: SCErrorCode }
  | { readonly tag: 'Events'; readonly value: SCErrorCode }
  | { readonly tag: 'Budget'; readonly value: SCErrorCode }
  | { readonly tag: 'Value'; readonly value: SCErrorCode }
  | { readonly tag: 'Auth'; readonly value: SCErrorCode }
;

export const SCError: XdrCodec<SCError> = taggedUnion({
  switchOn: SCErrorType,
  arms: [
    { tags: ['Contract'], codec: Uint32 },
    { tags: ['WasmVm', 'Context', 'Storage', 'Object', 'Crypto', 'Events', 'Budget', 'Value', 'Auth'], codec: SCErrorCode },
  ],
}) as XdrCodec<SCError>;

export interface UInt128Parts {
  readonly hi: Uint64;
  readonly lo: Uint64;
}
export const UInt128Parts: XdrCodec<UInt128Parts> = xdrStruct<UInt128Parts>([
  ['hi', Uint64],
  ['lo', Uint64],
]);

export interface Int128Parts {
  readonly hi: Int64;
  readonly lo: Uint64;
}
export const Int128Parts: XdrCodec<Int128Parts> = xdrStruct<Int128Parts>([
  ['hi', Int64],
  ['lo', Uint64],
]);

export interface UInt256Parts {
  readonly hiHi: Uint64;
  readonly hiLo: Uint64;
  readonly loHi: Uint64;
  readonly loLo: Uint64;
}
export const UInt256Parts: XdrCodec<UInt256Parts> = xdrStruct<UInt256Parts>([
  ['hiHi', Uint64],
  ['hiLo', Uint64],
  ['loHi', Uint64],
  ['loLo', Uint64],
]);

export interface Int256Parts {
  readonly hiHi: Int64;
  readonly hiLo: Uint64;
  readonly loHi: Uint64;
  readonly loLo: Uint64;
}
export const Int256Parts: XdrCodec<Int256Parts> = xdrStruct<Int256Parts>([
  ['hiHi', Int64],
  ['hiLo', Uint64],
  ['loHi', Uint64],
  ['loLo', Uint64],
]);

export type ContractExecutableType = 'Wasm' | 'StellarAsset';
export const ContractExecutableType = xdrEnum({
  Wasm: 0,
  StellarAsset: 1,
});

export type Hash = Uint8Array;
export const Hash: XdrCodec<Hash> = fixedOpaque(32);

export type ContractExecutable =
  | { readonly tag: 'Wasm'; readonly value: Hash }
  | { readonly tag: 'StellarAsset' }
;

export const ContractExecutable: XdrCodec<ContractExecutable> = taggedUnion({
  switchOn: ContractExecutableType,
  arms: [
    { tags: ['Wasm'], codec: Hash },
    { tags: ['StellarAsset'] },
  ],
}) as XdrCodec<ContractExecutable>;

export type SCAddressType = 'Account' | 'Contract' | 'MuxedAccount' | 'ClaimableBalance' | 'LiquidityPool';
export const SCAddressType = xdrEnum({
  Account: 0,
  Contract: 1,
  MuxedAccount: 2,
  ClaimableBalance: 3,
  LiquidityPool: 4,
});

export type Uint256 = Uint8Array;
export const Uint256: XdrCodec<Uint256> = fixedOpaque(32);

export interface MuxedEd25519Account {
  readonly id: Uint64;
  readonly ed25519: Uint256;
}
export const MuxedEd25519Account: XdrCodec<MuxedEd25519Account> = xdrStruct<MuxedEd25519Account>([
  ['id', Uint64],
  ['ed25519', Uint256],
]);

export type PublicKeyType = 'PublicKeyTypeEd25519';
export const PublicKeyType = xdrEnum({
  PublicKeyTypeEd25519: 0,
});

export type PublicKey =
  | { readonly tag: 'PublicKeyTypeEd25519'; readonly value: Uint256 }
;

export const PublicKey: XdrCodec<PublicKey> = taggedUnion({
  switchOn: PublicKeyType,
  arms: [
    { tags: ['PublicKeyTypeEd25519'], codec: Uint256 },
  ],
}) as XdrCodec<PublicKey>;

export type AccountID = PublicKey;
export const AccountID: XdrCodec<AccountID> = PublicKey;

export type ContractID = Hash;
export const ContractID: XdrCodec<ContractID> = Hash;

export type ClaimableBalanceIDType = 'ClaimableBalanceIdTypeV0';
export const ClaimableBalanceIDType = xdrEnum({
  ClaimableBalanceIdTypeV0: 0,
});

export type ClaimableBalanceID =
  | { readonly tag: 'ClaimableBalanceIdTypeV0'; readonly value: Hash }
;

export const ClaimableBalanceID: XdrCodec<ClaimableBalanceID> = taggedUnion({
  switchOn: ClaimableBalanceIDType,
  arms: [
    { tags: ['ClaimableBalanceIdTypeV0'], codec: Hash },
  ],
}) as XdrCodec<ClaimableBalanceID>;

export type PoolID = Hash;
export const PoolID: XdrCodec<PoolID> = Hash;

export type SCAddress =
  | { readonly tag: 'Account'; readonly value: AccountID }
  | { readonly tag: 'Contract'; readonly value: ContractID }
  | { readonly tag: 'MuxedAccount'; readonly value: MuxedEd25519Account }
  | { readonly tag: 'ClaimableBalance'; readonly value: ClaimableBalanceID }
  | { readonly tag: 'LiquidityPool'; readonly value: PoolID }
;

export const SCAddress: XdrCodec<SCAddress> = taggedUnion({
  switchOn: SCAddressType,
  arms: [
    { tags: ['Account'], codec: AccountID },
    { tags: ['Contract'], codec: ContractID },
    { tags: ['MuxedAccount'], codec: MuxedEd25519Account },
    { tags: ['ClaimableBalance'], codec: ClaimableBalanceID },
    { tags: ['LiquidityPool'], codec: PoolID },
  ],
}) as XdrCodec<SCAddress>;

export type Int32 = number;
export const Int32: XdrCodec<Int32> = int32;

export type TimePoint = Uint64;
export const TimePoint: XdrCodec<TimePoint> = Uint64;

export type Duration = Uint64;
export const Duration: XdrCodec<Duration> = Uint64;

export type SCBytes = Uint8Array;
export const SCBytes: XdrCodec<SCBytes> = varOpaque(2147483647);

export type SCString = string;
export const SCString: XdrCodec<SCString> = xdrString(2147483647);

export interface SCMapEntry {
  readonly key: SCVal;
  readonly val: SCVal;
}
export const SCMapEntry: XdrCodec<SCMapEntry> = xdrStruct<SCMapEntry>([
  ['key', lazy(() => SCVal)],
  ['val', lazy(() => SCVal)],
]);

export type SCMap = readonly SCMapEntry[];
export const SCMap: XdrCodec<SCMap> = varArray(2147483647, SCMapEntry);

export interface SCContractInstance {
  readonly executable: ContractExecutable;
  readonly storage: SCMap | undefined;
}
export const SCContractInstance: XdrCodec<SCContractInstance> = xdrStruct<SCContractInstance>([
  ['executable', ContractExecutable],
  ['storage', option(SCMap)],
]);

export interface SCNonceKey {
  readonly nonce: Int64;
}
export const SCNonceKey: XdrCodec<SCNonceKey> = xdrStruct<SCNonceKey>([
  ['nonce', Int64],
]);

export type SCVal =
  | { readonly tag: 'Bool'; readonly value: boolean }
  | { readonly tag: 'Void' }
  | { readonly tag: 'Error'; readonly value: SCError }
  | { readonly tag: 'U32'; readonly value: Uint32 }
  | { readonly tag: 'I32'; readonly value: Int32 }
  | { readonly tag: 'U64'; readonly value: Uint64 }
  | { readonly tag: 'I64'; readonly value: Int64 }
  | { readonly tag: 'Timepoint'; readonly value: TimePoint }
  | { readonly tag: 'Duration'; readonly value: Duration }
  | { readonly tag: 'U128'; readonly value: UInt128Parts }
  | { readonly tag: 'I128'; readonly value: Int128Parts }
  | { readonly tag: 'U256'; readonly value: UInt256Parts }
  | { readonly tag: 'I256'; readonly value: Int256Parts }
  | { readonly tag: 'Bytes'; readonly value: SCBytes }
  | { readonly tag: 'String'; readonly value: SCString }
  | { readonly tag: 'Symbol'; readonly value: SCSymbol }
  | { readonly tag: 'Vec'; readonly value: SCVec | undefined }
  | { readonly tag: 'Map'; readonly value: SCMap | undefined }
  | { readonly tag: 'Address'; readonly value: SCAddress }
  | { readonly tag: 'ContractInstance'; readonly value: SCContractInstance }
  | { readonly tag: 'LedgerKeyContractInstance' }
  | { readonly tag: 'LedgerKeyNonce'; readonly value: SCNonceKey }
;

export const SCVal: XdrCodec<SCVal> = taggedUnion({
  switchOn: SCValType,
  arms: [
    { tags: ['Bool'], codec: bool },
    { tags: ['Void'] },
    { tags: ['Error'], codec: SCError },
    { tags: ['U32'], codec: Uint32 },
    { tags: ['I32'], codec: Int32 },
    { tags: ['U64'], codec: Uint64 },
    { tags: ['I64'], codec: Int64 },
    { tags: ['Timepoint'], codec: TimePoint },
    { tags: ['Duration'], codec: Duration },
    { tags: ['U128'], codec: UInt128Parts },
    { tags: ['I128'], codec: Int128Parts },
    { tags: ['U256'], codec: UInt256Parts },
    { tags: ['I256'], codec: Int256Parts },
    { tags: ['Bytes'], codec: SCBytes },
    { tags: ['String'], codec: SCString },
    { tags: ['Symbol'], codec: SCSymbol },
    { tags: ['Vec'], codec: option(lazy(() => SCVec)) },
    { tags: ['Map'], codec: option(SCMap) },
    { tags: ['Address'], codec: SCAddress },
    { tags: ['ContractInstance'], codec: SCContractInstance },
    { tags: ['LedgerKeyContractInstance'] },
    { tags: ['LedgerKeyNonce'], codec: SCNonceKey },
  ],
}) as XdrCodec<SCVal>;

export type SCVec = readonly SCVal[];
export const SCVec: XdrCodec<SCVec> = varArray(2147483647, lazy(() => SCVal));

export type UpgradeType = Uint8Array;
export const UpgradeType: XdrCodec<UpgradeType> = varOpaque(128);

export type StellarValueType = 'Basic' | 'Signed';
export const StellarValueType = xdrEnum({
  Basic: 0,
  Signed: 1,
});

export type NodeID = PublicKey;
export const NodeID: XdrCodec<NodeID> = PublicKey;

export type Signature = Uint8Array;
export const Signature: XdrCodec<Signature> = varOpaque(64);

export interface LedgerCloseValueSignature {
  readonly nodeID: NodeID;
  readonly signature: Signature;
}
export const LedgerCloseValueSignature: XdrCodec<LedgerCloseValueSignature> = xdrStruct<LedgerCloseValueSignature>([
  ['nodeID', NodeID],
  ['signature', Signature],
]);

export type StellarValueExt =
  | { readonly tag: 'Basic' }
  | { readonly tag: 'Signed'; readonly value: LedgerCloseValueSignature }
;

export const StellarValueExt: XdrCodec<StellarValueExt> = taggedUnion({
  switchOn: StellarValueType,
  arms: [
    { tags: ['Basic'] },
    { tags: ['Signed'], codec: LedgerCloseValueSignature },
  ],
}) as XdrCodec<StellarValueExt>;

export interface StellarValue {
  readonly txSetHash: Hash;
  readonly closeTime: TimePoint;
  readonly upgrades: readonly UpgradeType[];
  readonly ext: StellarValueExt;
}
export const StellarValue: XdrCodec<StellarValue> = xdrStruct<StellarValue>([
  ['txSetHash', Hash],
  ['closeTime', TimePoint],
  ['upgrades', varArray(6, UpgradeType)],
  ['ext', StellarValueExt],
]);

export type LedgerHeaderExtensionV1Ext =
  | { readonly tag: 0 }
;

export const LedgerHeaderExtensionV1Ext: XdrCodec<LedgerHeaderExtensionV1Ext> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<LedgerHeaderExtensionV1Ext>;

export interface LedgerHeaderExtensionV1 {
  readonly flags: Uint32;
  readonly ext: LedgerHeaderExtensionV1Ext;
}
export const LedgerHeaderExtensionV1: XdrCodec<LedgerHeaderExtensionV1> = xdrStruct<LedgerHeaderExtensionV1>([
  ['flags', Uint32],
  ['ext', LedgerHeaderExtensionV1Ext],
]);

export type LedgerHeaderExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: LedgerHeaderExtensionV1 }
;

export const LedgerHeaderExt: XdrCodec<LedgerHeaderExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: LedgerHeaderExtensionV1 },
  ],
}) as XdrCodec<LedgerHeaderExt>;

export interface LedgerHeader {
  readonly ledgerVersion: Uint32;
  readonly previousLedgerHash: Hash;
  readonly scpValue: StellarValue;
  readonly txSetResultHash: Hash;
  readonly bucketListHash: Hash;
  readonly ledgerSeq: Uint32;
  readonly totalCoins: Int64;
  readonly feePool: Int64;
  readonly inflationSeq: Uint32;
  readonly idPool: Uint64;
  readonly baseFee: Uint32;
  readonly baseReserve: Uint32;
  readonly maxTxSetSize: Uint32;
  readonly skipList: readonly Hash[];
  readonly ext: LedgerHeaderExt;
}
export const LedgerHeader: XdrCodec<LedgerHeader> = xdrStruct<LedgerHeader>([
  ['ledgerVersion', Uint32],
  ['previousLedgerHash', Hash],
  ['scpValue', StellarValue],
  ['txSetResultHash', Hash],
  ['bucketListHash', Hash],
  ['ledgerSeq', Uint32],
  ['totalCoins', Int64],
  ['feePool', Int64],
  ['inflationSeq', Uint32],
  ['idPool', Uint64],
  ['baseFee', Uint32],
  ['baseReserve', Uint32],
  ['maxTxSetSize', Uint32],
  ['skipList', fixedArray(4, Hash)],
  ['ext', LedgerHeaderExt],
]);

export type LedgerHeaderHistoryEntryExt =
  | { readonly tag: 0 }
;

export const LedgerHeaderHistoryEntryExt: XdrCodec<LedgerHeaderHistoryEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<LedgerHeaderHistoryEntryExt>;

export interface LedgerHeaderHistoryEntry {
  readonly hash: Hash;
  readonly header: LedgerHeader;
  readonly ext: LedgerHeaderHistoryEntryExt;
}
export const LedgerHeaderHistoryEntry: XdrCodec<LedgerHeaderHistoryEntry> = xdrStruct<LedgerHeaderHistoryEntry>([
  ['hash', Hash],
  ['header', LedgerHeader],
  ['ext', LedgerHeaderHistoryEntryExt],
]);

export type EnvelopeType = 'TxV0' | 'Scp' | 'Tx' | 'Auth' | 'Scpvalue' | 'TxFeeBump' | 'OpId' | 'PoolRevokeOpId' | 'ContractId' | 'SorobanAuthorization';
export const EnvelopeType = xdrEnum({
  TxV0: 0,
  Scp: 1,
  Tx: 2,
  Auth: 3,
  Scpvalue: 4,
  TxFeeBump: 5,
  OpId: 6,
  PoolRevokeOpId: 7,
  ContractId: 8,
  SorobanAuthorization: 9,
});

export type SequenceNumber = Int64;
export const SequenceNumber: XdrCodec<SequenceNumber> = Int64;

export interface TimeBounds {
  readonly minTime: TimePoint;
  readonly maxTime: TimePoint;
}
export const TimeBounds: XdrCodec<TimeBounds> = xdrStruct<TimeBounds>([
  ['minTime', TimePoint],
  ['maxTime', TimePoint],
]);

export type MemoType = 'None' | 'Text' | 'Id' | 'Hash' | 'Return';
export const MemoType = xdrEnum({
  None: 0,
  Text: 1,
  Id: 2,
  Hash: 3,
  Return: 4,
});

export type Memo =
  | { readonly tag: 'None' }
  | { readonly tag: 'Text'; readonly value: string }
  | { readonly tag: 'Id'; readonly value: Uint64 }
  | { readonly tag: 'Hash'; readonly value: Hash }
  | { readonly tag: 'Return'; readonly value: Hash }
;

export const Memo: XdrCodec<Memo> = taggedUnion({
  switchOn: MemoType,
  arms: [
    { tags: ['None'] },
    { tags: ['Text'], codec: xdrString(28) },
    { tags: ['Id'], codec: Uint64 },
    { tags: ['Hash'], codec: Hash },
    { tags: ['Return'], codec: Hash },
  ],
}) as XdrCodec<Memo>;

export type CryptoKeyType = 'Ed25519' | 'PreAuthTx' | 'HashX' | 'Ed25519SignedPayload' | 'MuxedEd25519';
export const CryptoKeyType = xdrEnum({
  Ed25519: 0,
  PreAuthTx: 1,
  HashX: 2,
  Ed25519SignedPayload: 3,
  MuxedEd25519: 256,
});

export interface MuxedAccountMed25519 {
  readonly id: Uint64;
  readonly ed25519: Uint256;
}
export const MuxedAccountMed25519: XdrCodec<MuxedAccountMed25519> = xdrStruct<MuxedAccountMed25519>([
  ['id', Uint64],
  ['ed25519', Uint256],
]);

export type MuxedAccount =
  | { readonly tag: 'Ed25519'; readonly value: Uint256 }
  | { readonly tag: 'MuxedEd25519'; readonly value: MuxedAccountMed25519 }
;

export const MuxedAccount: XdrCodec<MuxedAccount> = taggedUnion({
  switchOn: CryptoKeyType,
  arms: [
    { tags: ['Ed25519'], codec: Uint256 },
    { tags: ['MuxedEd25519'], codec: MuxedAccountMed25519 },
  ],
}) as XdrCodec<MuxedAccount>;

export type OperationType = 'CreateAccount' | 'Payment' | 'PathPaymentStrictReceive' | 'ManageSellOffer' | 'CreatePassiveSellOffer' | 'SetOptions' | 'ChangeTrust' | 'AllowTrust' | 'AccountMerge' | 'Inflation' | 'ManageData' | 'BumpSequence' | 'ManageBuyOffer' | 'PathPaymentStrictSend' | 'CreateClaimableBalance' | 'ClaimClaimableBalance' | 'BeginSponsoringFutureReserves' | 'EndSponsoringFutureReserves' | 'RevokeSponsorship' | 'Clawback' | 'ClawbackClaimableBalance' | 'SetTrustLineFlags' | 'LiquidityPoolDeposit' | 'LiquidityPoolWithdraw' | 'InvokeHostFunction' | 'ExtendFootprintTtl' | 'RestoreFootprint';
export const OperationType = xdrEnum({
  CreateAccount: 0,
  Payment: 1,
  PathPaymentStrictReceive: 2,
  ManageSellOffer: 3,
  CreatePassiveSellOffer: 4,
  SetOptions: 5,
  ChangeTrust: 6,
  AllowTrust: 7,
  AccountMerge: 8,
  Inflation: 9,
  ManageData: 10,
  BumpSequence: 11,
  ManageBuyOffer: 12,
  PathPaymentStrictSend: 13,
  CreateClaimableBalance: 14,
  ClaimClaimableBalance: 15,
  BeginSponsoringFutureReserves: 16,
  EndSponsoringFutureReserves: 17,
  RevokeSponsorship: 18,
  Clawback: 19,
  ClawbackClaimableBalance: 20,
  SetTrustLineFlags: 21,
  LiquidityPoolDeposit: 22,
  LiquidityPoolWithdraw: 23,
  InvokeHostFunction: 24,
  ExtendFootprintTtl: 25,
  RestoreFootprint: 26,
});

export interface CreateAccountOp {
  readonly destination: AccountID;
  readonly startingBalance: Int64;
}
export const CreateAccountOp: XdrCodec<CreateAccountOp> = xdrStruct<CreateAccountOp>([
  ['destination', AccountID],
  ['startingBalance', Int64],
]);

export type AssetType = 'Native' | 'CreditAlphanum4' | 'CreditAlphanum12' | 'PoolShare';
export const AssetType = xdrEnum({
  Native: 0,
  CreditAlphanum4: 1,
  CreditAlphanum12: 2,
  PoolShare: 3,
});

export type AssetCode4 = Uint8Array;
export const AssetCode4: XdrCodec<AssetCode4> = fixedOpaque(4);

export interface AlphaNum4 {
  readonly assetCode: AssetCode4;
  readonly issuer: AccountID;
}
export const AlphaNum4: XdrCodec<AlphaNum4> = xdrStruct<AlphaNum4>([
  ['assetCode', AssetCode4],
  ['issuer', AccountID],
]);

export type AssetCode12 = Uint8Array;
export const AssetCode12: XdrCodec<AssetCode12> = fixedOpaque(12);

export interface AlphaNum12 {
  readonly assetCode: AssetCode12;
  readonly issuer: AccountID;
}
export const AlphaNum12: XdrCodec<AlphaNum12> = xdrStruct<AlphaNum12>([
  ['assetCode', AssetCode12],
  ['issuer', AccountID],
]);

export type Asset =
  | { readonly tag: 'Native' }
  | { readonly tag: 'CreditAlphanum4'; readonly value: AlphaNum4 }
  | { readonly tag: 'CreditAlphanum12'; readonly value: AlphaNum12 }
;

export const Asset: XdrCodec<Asset> = taggedUnion({
  switchOn: AssetType,
  arms: [
    { tags: ['Native'] },
    { tags: ['CreditAlphanum4'], codec: AlphaNum4 },
    { tags: ['CreditAlphanum12'], codec: AlphaNum12 },
  ],
}) as XdrCodec<Asset>;

export interface PaymentOp {
  readonly destination: MuxedAccount;
  readonly asset: Asset;
  readonly amount: Int64;
}
export const PaymentOp: XdrCodec<PaymentOp> = xdrStruct<PaymentOp>([
  ['destination', MuxedAccount],
  ['asset', Asset],
  ['amount', Int64],
]);

export interface PathPaymentStrictReceiveOp {
  readonly sendAsset: Asset;
  readonly sendMax: Int64;
  readonly destination: MuxedAccount;
  readonly destAsset: Asset;
  readonly destAmount: Int64;
  readonly path: readonly Asset[];
}
export const PathPaymentStrictReceiveOp: XdrCodec<PathPaymentStrictReceiveOp> = xdrStruct<PathPaymentStrictReceiveOp>([
  ['sendAsset', Asset],
  ['sendMax', Int64],
  ['destination', MuxedAccount],
  ['destAsset', Asset],
  ['destAmount', Int64],
  ['path', varArray(5, Asset)],
]);

export interface Price {
  readonly n: Int32;
  readonly d: Int32;
}
export const Price: XdrCodec<Price> = xdrStruct<Price>([
  ['n', Int32],
  ['d', Int32],
]);

export interface ManageSellOfferOp {
  readonly selling: Asset;
  readonly buying: Asset;
  readonly amount: Int64;
  readonly price: Price;
  readonly offerID: Int64;
}
export const ManageSellOfferOp: XdrCodec<ManageSellOfferOp> = xdrStruct<ManageSellOfferOp>([
  ['selling', Asset],
  ['buying', Asset],
  ['amount', Int64],
  ['price', Price],
  ['offerID', Int64],
]);

export interface CreatePassiveSellOfferOp {
  readonly selling: Asset;
  readonly buying: Asset;
  readonly amount: Int64;
  readonly price: Price;
}
export const CreatePassiveSellOfferOp: XdrCodec<CreatePassiveSellOfferOp> = xdrStruct<CreatePassiveSellOfferOp>([
  ['selling', Asset],
  ['buying', Asset],
  ['amount', Int64],
  ['price', Price],
]);

export type String32 = string;
export const String32: XdrCodec<String32> = xdrString(32);

export type SignerKeyType = 'Ed25519' | 'PreAuthTx' | 'HashX' | 'Ed25519SignedPayload';
export const SignerKeyType = xdrEnum({
  Ed25519: 0,
  PreAuthTx: 1,
  HashX: 2,
  Ed25519SignedPayload: 3,
});

export interface SignerKeyEd25519SignedPayload {
  readonly ed25519: Uint256;
  readonly payload: Uint8Array;
}
export const SignerKeyEd25519SignedPayload: XdrCodec<SignerKeyEd25519SignedPayload> = xdrStruct<SignerKeyEd25519SignedPayload>([
  ['ed25519', Uint256],
  ['payload', varOpaque(64)],
]);

export type SignerKey =
  | { readonly tag: 'Ed25519'; readonly value: Uint256 }
  | { readonly tag: 'PreAuthTx'; readonly value: Uint256 }
  | { readonly tag: 'HashX'; readonly value: Uint256 }
  | { readonly tag: 'Ed25519SignedPayload'; readonly value: SignerKeyEd25519SignedPayload }
;

export const SignerKey: XdrCodec<SignerKey> = taggedUnion({
  switchOn: SignerKeyType,
  arms: [
    { tags: ['Ed25519'], codec: Uint256 },
    { tags: ['PreAuthTx'], codec: Uint256 },
    { tags: ['HashX'], codec: Uint256 },
    { tags: ['Ed25519SignedPayload'], codec: SignerKeyEd25519SignedPayload },
  ],
}) as XdrCodec<SignerKey>;

export interface Signer {
  readonly key: SignerKey;
  readonly weight: Uint32;
}
export const Signer: XdrCodec<Signer> = xdrStruct<Signer>([
  ['key', SignerKey],
  ['weight', Uint32],
]);

export interface SetOptionsOp {
  readonly inflationDest: AccountID | undefined;
  readonly clearFlags: Uint32 | undefined;
  readonly setFlags: Uint32 | undefined;
  readonly masterWeight: Uint32 | undefined;
  readonly lowThreshold: Uint32 | undefined;
  readonly medThreshold: Uint32 | undefined;
  readonly highThreshold: Uint32 | undefined;
  readonly homeDomain: String32 | undefined;
  readonly signer: Signer | undefined;
}
export const SetOptionsOp: XdrCodec<SetOptionsOp> = xdrStruct<SetOptionsOp>([
  ['inflationDest', option(AccountID)],
  ['clearFlags', option(Uint32)],
  ['setFlags', option(Uint32)],
  ['masterWeight', option(Uint32)],
  ['lowThreshold', option(Uint32)],
  ['medThreshold', option(Uint32)],
  ['highThreshold', option(Uint32)],
  ['homeDomain', option(String32)],
  ['signer', option(Signer)],
]);

export type LiquidityPoolType = 'LiquidityPoolConstantProduct';
export const LiquidityPoolType = xdrEnum({
  LiquidityPoolConstantProduct: 0,
});

export interface LiquidityPoolConstantProductParameters {
  readonly assetA: Asset;
  readonly assetB: Asset;
  readonly fee: Int32;
}
export const LiquidityPoolConstantProductParameters: XdrCodec<LiquidityPoolConstantProductParameters> = xdrStruct<LiquidityPoolConstantProductParameters>([
  ['assetA', Asset],
  ['assetB', Asset],
  ['fee', Int32],
]);

export type LiquidityPoolParameters =
  | { readonly tag: 'LiquidityPoolConstantProduct'; readonly value: LiquidityPoolConstantProductParameters }
;

export const LiquidityPoolParameters: XdrCodec<LiquidityPoolParameters> = taggedUnion({
  switchOn: LiquidityPoolType,
  arms: [
    { tags: ['LiquidityPoolConstantProduct'], codec: LiquidityPoolConstantProductParameters },
  ],
}) as XdrCodec<LiquidityPoolParameters>;

export type ChangeTrustAsset =
  | { readonly tag: 'Native' }
  | { readonly tag: 'CreditAlphanum4'; readonly value: AlphaNum4 }
  | { readonly tag: 'CreditAlphanum12'; readonly value: AlphaNum12 }
  | { readonly tag: 'PoolShare'; readonly value: LiquidityPoolParameters }
;

export const ChangeTrustAsset: XdrCodec<ChangeTrustAsset> = taggedUnion({
  switchOn: AssetType,
  arms: [
    { tags: ['Native'] },
    { tags: ['CreditAlphanum4'], codec: AlphaNum4 },
    { tags: ['CreditAlphanum12'], codec: AlphaNum12 },
    { tags: ['PoolShare'], codec: LiquidityPoolParameters },
  ],
}) as XdrCodec<ChangeTrustAsset>;

export interface ChangeTrustOp {
  readonly line: ChangeTrustAsset;
  readonly limit: Int64;
}
export const ChangeTrustOp: XdrCodec<ChangeTrustOp> = xdrStruct<ChangeTrustOp>([
  ['line', ChangeTrustAsset],
  ['limit', Int64],
]);

export type AssetCode =
  | { readonly tag: 'CreditAlphanum4'; readonly value: AssetCode4 }
  | { readonly tag: 'CreditAlphanum12'; readonly value: AssetCode12 }
;

export const AssetCode: XdrCodec<AssetCode> = taggedUnion({
  switchOn: AssetType,
  arms: [
    { tags: ['CreditAlphanum4'], codec: AssetCode4 },
    { tags: ['CreditAlphanum12'], codec: AssetCode12 },
  ],
}) as XdrCodec<AssetCode>;

export interface AllowTrustOp {
  readonly trustor: AccountID;
  readonly asset: AssetCode;
  readonly authorize: Uint32;
}
export const AllowTrustOp: XdrCodec<AllowTrustOp> = xdrStruct<AllowTrustOp>([
  ['trustor', AccountID],
  ['asset', AssetCode],
  ['authorize', Uint32],
]);

export type String64 = string;
export const String64: XdrCodec<String64> = xdrString(64);

export type DataValue = Uint8Array;
export const DataValue: XdrCodec<DataValue> = varOpaque(64);

export interface ManageDataOp {
  readonly dataName: String64;
  readonly dataValue: DataValue | undefined;
}
export const ManageDataOp: XdrCodec<ManageDataOp> = xdrStruct<ManageDataOp>([
  ['dataName', String64],
  ['dataValue', option(DataValue)],
]);

export interface BumpSequenceOp {
  readonly bumpTo: SequenceNumber;
}
export const BumpSequenceOp: XdrCodec<BumpSequenceOp> = xdrStruct<BumpSequenceOp>([
  ['bumpTo', SequenceNumber],
]);

export interface ManageBuyOfferOp {
  readonly selling: Asset;
  readonly buying: Asset;
  readonly buyAmount: Int64;
  readonly price: Price;
  readonly offerID: Int64;
}
export const ManageBuyOfferOp: XdrCodec<ManageBuyOfferOp> = xdrStruct<ManageBuyOfferOp>([
  ['selling', Asset],
  ['buying', Asset],
  ['buyAmount', Int64],
  ['price', Price],
  ['offerID', Int64],
]);

export interface PathPaymentStrictSendOp {
  readonly sendAsset: Asset;
  readonly sendAmount: Int64;
  readonly destination: MuxedAccount;
  readonly destAsset: Asset;
  readonly destMin: Int64;
  readonly path: readonly Asset[];
}
export const PathPaymentStrictSendOp: XdrCodec<PathPaymentStrictSendOp> = xdrStruct<PathPaymentStrictSendOp>([
  ['sendAsset', Asset],
  ['sendAmount', Int64],
  ['destination', MuxedAccount],
  ['destAsset', Asset],
  ['destMin', Int64],
  ['path', varArray(5, Asset)],
]);

export type ClaimantType = 'ClaimantTypeV0';
export const ClaimantType = xdrEnum({
  ClaimantTypeV0: 0,
});

export type ClaimPredicateType = 'Unconditional' | 'And' | 'Or' | 'Not' | 'BeforeAbsoluteTime' | 'BeforeRelativeTime';
export const ClaimPredicateType = xdrEnum({
  Unconditional: 0,
  And: 1,
  Or: 2,
  Not: 3,
  BeforeAbsoluteTime: 4,
  BeforeRelativeTime: 5,
});

export type ClaimPredicate =
  | { readonly tag: 'Unconditional' }
  | { readonly tag: 'And'; readonly value: readonly ClaimPredicate[] }
  | { readonly tag: 'Or'; readonly value: readonly ClaimPredicate[] }
  | { readonly tag: 'Not'; readonly value: ClaimPredicate | undefined }
  | { readonly tag: 'BeforeAbsoluteTime'; readonly value: Int64 }
  | { readonly tag: 'BeforeRelativeTime'; readonly value: Int64 }
;

export const ClaimPredicate: XdrCodec<ClaimPredicate> = taggedUnion({
  switchOn: ClaimPredicateType,
  arms: [
    { tags: ['Unconditional'] },
    { tags: ['And'], codec: varArray(2, lazy(() => ClaimPredicate)) },
    { tags: ['Or'], codec: varArray(2, lazy(() => ClaimPredicate)) },
    { tags: ['Not'], codec: option(lazy(() => ClaimPredicate)) },
    { tags: ['BeforeAbsoluteTime'], codec: Int64 },
    { tags: ['BeforeRelativeTime'], codec: Int64 },
  ],
}) as XdrCodec<ClaimPredicate>;

export interface ClaimantV0 {
  readonly destination: AccountID;
  readonly predicate: ClaimPredicate;
}
export const ClaimantV0: XdrCodec<ClaimantV0> = xdrStruct<ClaimantV0>([
  ['destination', AccountID],
  ['predicate', lazy(() => ClaimPredicate)],
]);

export type Claimant =
  | { readonly tag: 'ClaimantTypeV0'; readonly value: ClaimantV0 }
;

export const Claimant: XdrCodec<Claimant> = taggedUnion({
  switchOn: ClaimantType,
  arms: [
    { tags: ['ClaimantTypeV0'], codec: ClaimantV0 },
  ],
}) as XdrCodec<Claimant>;

export interface CreateClaimableBalanceOp {
  readonly asset: Asset;
  readonly amount: Int64;
  readonly claimants: readonly Claimant[];
}
export const CreateClaimableBalanceOp: XdrCodec<CreateClaimableBalanceOp> = xdrStruct<CreateClaimableBalanceOp>([
  ['asset', Asset],
  ['amount', Int64],
  ['claimants', varArray(10, Claimant)],
]);

export interface ClaimClaimableBalanceOp {
  readonly balanceID: ClaimableBalanceID;
}
export const ClaimClaimableBalanceOp: XdrCodec<ClaimClaimableBalanceOp> = xdrStruct<ClaimClaimableBalanceOp>([
  ['balanceID', ClaimableBalanceID],
]);

export interface BeginSponsoringFutureReservesOp {
  readonly sponsoredID: AccountID;
}
export const BeginSponsoringFutureReservesOp: XdrCodec<BeginSponsoringFutureReservesOp> = xdrStruct<BeginSponsoringFutureReservesOp>([
  ['sponsoredID', AccountID],
]);

export type RevokeSponsorshipType = 'LedgerEntry' | 'Signer';
export const RevokeSponsorshipType = xdrEnum({
  LedgerEntry: 0,
  Signer: 1,
});

export type LedgerEntryType = 'Account' | 'Trustline' | 'Offer' | 'Data' | 'ClaimableBalance' | 'LiquidityPool' | 'ContractData' | 'ContractCode' | 'ConfigSetting' | 'Ttl';
export const LedgerEntryType = xdrEnum({
  Account: 0,
  Trustline: 1,
  Offer: 2,
  Data: 3,
  ClaimableBalance: 4,
  LiquidityPool: 5,
  ContractData: 6,
  ContractCode: 7,
  ConfigSetting: 8,
  Ttl: 9,
});

export interface LedgerKeyAccount {
  readonly accountID: AccountID;
}
export const LedgerKeyAccount: XdrCodec<LedgerKeyAccount> = xdrStruct<LedgerKeyAccount>([
  ['accountID', AccountID],
]);

export type TrustLineAsset =
  | { readonly tag: 'Native' }
  | { readonly tag: 'CreditAlphanum4'; readonly value: AlphaNum4 }
  | { readonly tag: 'CreditAlphanum12'; readonly value: AlphaNum12 }
  | { readonly tag: 'PoolShare'; readonly value: PoolID }
;

export const TrustLineAsset: XdrCodec<TrustLineAsset> = taggedUnion({
  switchOn: AssetType,
  arms: [
    { tags: ['Native'] },
    { tags: ['CreditAlphanum4'], codec: AlphaNum4 },
    { tags: ['CreditAlphanum12'], codec: AlphaNum12 },
    { tags: ['PoolShare'], codec: PoolID },
  ],
}) as XdrCodec<TrustLineAsset>;

export interface LedgerKeyTrustLine {
  readonly accountID: AccountID;
  readonly asset: TrustLineAsset;
}
export const LedgerKeyTrustLine: XdrCodec<LedgerKeyTrustLine> = xdrStruct<LedgerKeyTrustLine>([
  ['accountID', AccountID],
  ['asset', TrustLineAsset],
]);

export interface LedgerKeyOffer {
  readonly sellerID: AccountID;
  readonly offerID: Int64;
}
export const LedgerKeyOffer: XdrCodec<LedgerKeyOffer> = xdrStruct<LedgerKeyOffer>([
  ['sellerID', AccountID],
  ['offerID', Int64],
]);

export interface LedgerKeyData {
  readonly accountID: AccountID;
  readonly dataName: String64;
}
export const LedgerKeyData: XdrCodec<LedgerKeyData> = xdrStruct<LedgerKeyData>([
  ['accountID', AccountID],
  ['dataName', String64],
]);

export interface LedgerKeyClaimableBalance {
  readonly balanceID: ClaimableBalanceID;
}
export const LedgerKeyClaimableBalance: XdrCodec<LedgerKeyClaimableBalance> = xdrStruct<LedgerKeyClaimableBalance>([
  ['balanceID', ClaimableBalanceID],
]);

export interface LedgerKeyLiquidityPool {
  readonly liquidityPoolID: PoolID;
}
export const LedgerKeyLiquidityPool: XdrCodec<LedgerKeyLiquidityPool> = xdrStruct<LedgerKeyLiquidityPool>([
  ['liquidityPoolID', PoolID],
]);

export type ContractDataDurability = 'Temporary' | 'Persistent';
export const ContractDataDurability = xdrEnum({
  Temporary: 0,
  Persistent: 1,
});

export interface LedgerKeyContractData {
  readonly contract: SCAddress;
  readonly key: SCVal;
  readonly durability: ContractDataDurability;
}
export const LedgerKeyContractData: XdrCodec<LedgerKeyContractData> = xdrStruct<LedgerKeyContractData>([
  ['contract', SCAddress],
  ['key', lazy(() => SCVal)],
  ['durability', ContractDataDurability],
]);

export interface LedgerKeyContractCode {
  readonly hash: Hash;
}
export const LedgerKeyContractCode: XdrCodec<LedgerKeyContractCode> = xdrStruct<LedgerKeyContractCode>([
  ['hash', Hash],
]);

export interface LedgerKeyConfigSetting {
  readonly configSettingID: ConfigSettingID;
}
export const LedgerKeyConfigSetting: XdrCodec<LedgerKeyConfigSetting> = xdrStruct<LedgerKeyConfigSetting>([
  ['configSettingID', ConfigSettingID],
]);

export interface LedgerKeyTtl {
  readonly keyHash: Hash;
}
export const LedgerKeyTtl: XdrCodec<LedgerKeyTtl> = xdrStruct<LedgerKeyTtl>([
  ['keyHash', Hash],
]);

export type LedgerKey =
  | { readonly tag: 'Account'; readonly value: LedgerKeyAccount }
  | { readonly tag: 'Trustline'; readonly value: LedgerKeyTrustLine }
  | { readonly tag: 'Offer'; readonly value: LedgerKeyOffer }
  | { readonly tag: 'Data'; readonly value: LedgerKeyData }
  | { readonly tag: 'ClaimableBalance'; readonly value: LedgerKeyClaimableBalance }
  | { readonly tag: 'LiquidityPool'; readonly value: LedgerKeyLiquidityPool }
  | { readonly tag: 'ContractData'; readonly value: LedgerKeyContractData }
  | { readonly tag: 'ContractCode'; readonly value: LedgerKeyContractCode }
  | { readonly tag: 'ConfigSetting'; readonly value: LedgerKeyConfigSetting }
  | { readonly tag: 'Ttl'; readonly value: LedgerKeyTtl }
;

export const LedgerKey: XdrCodec<LedgerKey> = taggedUnion({
  switchOn: LedgerEntryType,
  arms: [
    { tags: ['Account'], codec: LedgerKeyAccount },
    { tags: ['Trustline'], codec: LedgerKeyTrustLine },
    { tags: ['Offer'], codec: LedgerKeyOffer },
    { tags: ['Data'], codec: LedgerKeyData },
    { tags: ['ClaimableBalance'], codec: LedgerKeyClaimableBalance },
    { tags: ['LiquidityPool'], codec: LedgerKeyLiquidityPool },
    { tags: ['ContractData'], codec: LedgerKeyContractData },
    { tags: ['ContractCode'], codec: LedgerKeyContractCode },
    { tags: ['ConfigSetting'], codec: LedgerKeyConfigSetting },
    { tags: ['Ttl'], codec: LedgerKeyTtl },
  ],
}) as XdrCodec<LedgerKey>;

export interface RevokeSponsorshipOpSigner {
  readonly accountID: AccountID;
  readonly signerKey: SignerKey;
}
export const RevokeSponsorshipOpSigner: XdrCodec<RevokeSponsorshipOpSigner> = xdrStruct<RevokeSponsorshipOpSigner>([
  ['accountID', AccountID],
  ['signerKey', SignerKey],
]);

export type RevokeSponsorshipOp =
  | { readonly tag: 'LedgerEntry'; readonly value: LedgerKey }
  | { readonly tag: 'Signer'; readonly value: RevokeSponsorshipOpSigner }
;

export const RevokeSponsorshipOp: XdrCodec<RevokeSponsorshipOp> = taggedUnion({
  switchOn: RevokeSponsorshipType,
  arms: [
    { tags: ['LedgerEntry'], codec: LedgerKey },
    { tags: ['Signer'], codec: RevokeSponsorshipOpSigner },
  ],
}) as XdrCodec<RevokeSponsorshipOp>;

export interface ClawbackOp {
  readonly asset: Asset;
  readonly from: MuxedAccount;
  readonly amount: Int64;
}
export const ClawbackOp: XdrCodec<ClawbackOp> = xdrStruct<ClawbackOp>([
  ['asset', Asset],
  ['from', MuxedAccount],
  ['amount', Int64],
]);

export interface ClawbackClaimableBalanceOp {
  readonly balanceID: ClaimableBalanceID;
}
export const ClawbackClaimableBalanceOp: XdrCodec<ClawbackClaimableBalanceOp> = xdrStruct<ClawbackClaimableBalanceOp>([
  ['balanceID', ClaimableBalanceID],
]);

export interface SetTrustLineFlagsOp {
  readonly trustor: AccountID;
  readonly asset: Asset;
  readonly clearFlags: Uint32;
  readonly setFlags: Uint32;
}
export const SetTrustLineFlagsOp: XdrCodec<SetTrustLineFlagsOp> = xdrStruct<SetTrustLineFlagsOp>([
  ['trustor', AccountID],
  ['asset', Asset],
  ['clearFlags', Uint32],
  ['setFlags', Uint32],
]);

export interface LiquidityPoolDepositOp {
  readonly liquidityPoolID: PoolID;
  readonly maxAmountA: Int64;
  readonly maxAmountB: Int64;
  readonly minPrice: Price;
  readonly maxPrice: Price;
}
export const LiquidityPoolDepositOp: XdrCodec<LiquidityPoolDepositOp> = xdrStruct<LiquidityPoolDepositOp>([
  ['liquidityPoolID', PoolID],
  ['maxAmountA', Int64],
  ['maxAmountB', Int64],
  ['minPrice', Price],
  ['maxPrice', Price],
]);

export interface LiquidityPoolWithdrawOp {
  readonly liquidityPoolID: PoolID;
  readonly amount: Int64;
  readonly minAmountA: Int64;
  readonly minAmountB: Int64;
}
export const LiquidityPoolWithdrawOp: XdrCodec<LiquidityPoolWithdrawOp> = xdrStruct<LiquidityPoolWithdrawOp>([
  ['liquidityPoolID', PoolID],
  ['amount', Int64],
  ['minAmountA', Int64],
  ['minAmountB', Int64],
]);

export type HostFunctionType = 'InvokeContract' | 'CreateContract' | 'UploadContractWasm' | 'CreateContractV2';
export const HostFunctionType = xdrEnum({
  InvokeContract: 0,
  CreateContract: 1,
  UploadContractWasm: 2,
  CreateContractV2: 3,
});

export interface InvokeContractArgs {
  readonly contractAddress: SCAddress;
  readonly functionName: SCSymbol;
  readonly args: readonly SCVal[];
}
export const InvokeContractArgs: XdrCodec<InvokeContractArgs> = xdrStruct<InvokeContractArgs>([
  ['contractAddress', SCAddress],
  ['functionName', SCSymbol],
  ['args', varArray(2147483647, lazy(() => SCVal))],
]);

export type ContractIDPreimageType = 'Address' | 'Asset';
export const ContractIDPreimageType = xdrEnum({
  Address: 0,
  Asset: 1,
});

export interface ContractIDPreimageFromAddress {
  readonly address: SCAddress;
  readonly salt: Uint256;
}
export const ContractIDPreimageFromAddress: XdrCodec<ContractIDPreimageFromAddress> = xdrStruct<ContractIDPreimageFromAddress>([
  ['address', SCAddress],
  ['salt', Uint256],
]);

export type ContractIDPreimage =
  | { readonly tag: 'Address'; readonly value: ContractIDPreimageFromAddress }
  | { readonly tag: 'Asset'; readonly value: Asset }
;

export const ContractIDPreimage: XdrCodec<ContractIDPreimage> = taggedUnion({
  switchOn: ContractIDPreimageType,
  arms: [
    { tags: ['Address'], codec: ContractIDPreimageFromAddress },
    { tags: ['Asset'], codec: Asset },
  ],
}) as XdrCodec<ContractIDPreimage>;

export interface CreateContractArgs {
  readonly contractIDPreimage: ContractIDPreimage;
  readonly executable: ContractExecutable;
}
export const CreateContractArgs: XdrCodec<CreateContractArgs> = xdrStruct<CreateContractArgs>([
  ['contractIDPreimage', ContractIDPreimage],
  ['executable', ContractExecutable],
]);

export interface CreateContractArgsV2 {
  readonly contractIDPreimage: ContractIDPreimage;
  readonly executable: ContractExecutable;
  readonly constructorArgs: readonly SCVal[];
}
export const CreateContractArgsV2: XdrCodec<CreateContractArgsV2> = xdrStruct<CreateContractArgsV2>([
  ['contractIDPreimage', ContractIDPreimage],
  ['executable', ContractExecutable],
  ['constructorArgs', varArray(2147483647, lazy(() => SCVal))],
]);

export type HostFunction =
  | { readonly tag: 'InvokeContract'; readonly value: InvokeContractArgs }
  | { readonly tag: 'CreateContract'; readonly value: CreateContractArgs }
  | { readonly tag: 'UploadContractWasm'; readonly value: Uint8Array }
  | { readonly tag: 'CreateContractV2'; readonly value: CreateContractArgsV2 }
;

export const HostFunction: XdrCodec<HostFunction> = taggedUnion({
  switchOn: HostFunctionType,
  arms: [
    { tags: ['InvokeContract'], codec: InvokeContractArgs },
    { tags: ['CreateContract'], codec: CreateContractArgs },
    { tags: ['UploadContractWasm'], codec: varOpaque(2147483647) },
    { tags: ['CreateContractV2'], codec: CreateContractArgsV2 },
  ],
}) as XdrCodec<HostFunction>;

export type SorobanCredentialsType = 'SourceAccount' | 'Address';
export const SorobanCredentialsType = xdrEnum({
  SourceAccount: 0,
  Address: 1,
});

export interface SorobanAddressCredentials {
  readonly address: SCAddress;
  readonly nonce: Int64;
  readonly signatureExpirationLedger: Uint32;
  readonly signature: SCVal;
}
export const SorobanAddressCredentials: XdrCodec<SorobanAddressCredentials> = xdrStruct<SorobanAddressCredentials>([
  ['address', SCAddress],
  ['nonce', Int64],
  ['signatureExpirationLedger', Uint32],
  ['signature', lazy(() => SCVal)],
]);

export type SorobanCredentials =
  | { readonly tag: 'SourceAccount' }
  | { readonly tag: 'Address'; readonly value: SorobanAddressCredentials }
;

export const SorobanCredentials: XdrCodec<SorobanCredentials> = taggedUnion({
  switchOn: SorobanCredentialsType,
  arms: [
    { tags: ['SourceAccount'] },
    { tags: ['Address'], codec: SorobanAddressCredentials },
  ],
}) as XdrCodec<SorobanCredentials>;

export type SorobanAuthorizedFunctionType = 'ContractFn' | 'CreateContractHostFn' | 'CreateContractV2HostFn';
export const SorobanAuthorizedFunctionType = xdrEnum({
  ContractFn: 0,
  CreateContractHostFn: 1,
  CreateContractV2HostFn: 2,
});

export type SorobanAuthorizedFunction =
  | { readonly tag: 'ContractFn'; readonly value: InvokeContractArgs }
  | { readonly tag: 'CreateContractHostFn'; readonly value: CreateContractArgs }
  | { readonly tag: 'CreateContractV2HostFn'; readonly value: CreateContractArgsV2 }
;

export const SorobanAuthorizedFunction: XdrCodec<SorobanAuthorizedFunction> = taggedUnion({
  switchOn: SorobanAuthorizedFunctionType,
  arms: [
    { tags: ['ContractFn'], codec: InvokeContractArgs },
    { tags: ['CreateContractHostFn'], codec: CreateContractArgs },
    { tags: ['CreateContractV2HostFn'], codec: CreateContractArgsV2 },
  ],
}) as XdrCodec<SorobanAuthorizedFunction>;

export interface SorobanAuthorizedInvocation {
  readonly function: SorobanAuthorizedFunction;
  readonly subInvocations: readonly SorobanAuthorizedInvocation[];
}
export const SorobanAuthorizedInvocation: XdrCodec<SorobanAuthorizedInvocation> = xdrStruct<SorobanAuthorizedInvocation>([
  ['function', SorobanAuthorizedFunction],
  ['subInvocations', varArray(2147483647, lazy(() => SorobanAuthorizedInvocation))],
]);

export interface SorobanAuthorizationEntry {
  readonly credentials: SorobanCredentials;
  readonly rootInvocation: SorobanAuthorizedInvocation;
}
export const SorobanAuthorizationEntry: XdrCodec<SorobanAuthorizationEntry> = xdrStruct<SorobanAuthorizationEntry>([
  ['credentials', SorobanCredentials],
  ['rootInvocation', lazy(() => SorobanAuthorizedInvocation)],
]);

export interface InvokeHostFunctionOp {
  readonly hostFunction: HostFunction;
  readonly auth: readonly SorobanAuthorizationEntry[];
}
export const InvokeHostFunctionOp: XdrCodec<InvokeHostFunctionOp> = xdrStruct<InvokeHostFunctionOp>([
  ['hostFunction', HostFunction],
  ['auth', varArray(2147483647, SorobanAuthorizationEntry)],
]);

export interface ExtendFootprintTTLOp {
  readonly ext: ExtensionPoint;
  readonly extendTo: Uint32;
}
export const ExtendFootprintTTLOp: XdrCodec<ExtendFootprintTTLOp> = xdrStruct<ExtendFootprintTTLOp>([
  ['ext', ExtensionPoint],
  ['extendTo', Uint32],
]);

export interface RestoreFootprintOp {
  readonly ext: ExtensionPoint;
}
export const RestoreFootprintOp: XdrCodec<RestoreFootprintOp> = xdrStruct<RestoreFootprintOp>([
  ['ext', ExtensionPoint],
]);

export type OperationBody =
  | { readonly tag: 'CreateAccount'; readonly value: CreateAccountOp }
  | { readonly tag: 'Payment'; readonly value: PaymentOp }
  | { readonly tag: 'PathPaymentStrictReceive'; readonly value: PathPaymentStrictReceiveOp }
  | { readonly tag: 'ManageSellOffer'; readonly value: ManageSellOfferOp }
  | { readonly tag: 'CreatePassiveSellOffer'; readonly value: CreatePassiveSellOfferOp }
  | { readonly tag: 'SetOptions'; readonly value: SetOptionsOp }
  | { readonly tag: 'ChangeTrust'; readonly value: ChangeTrustOp }
  | { readonly tag: 'AllowTrust'; readonly value: AllowTrustOp }
  | { readonly tag: 'AccountMerge'; readonly value: MuxedAccount }
  | { readonly tag: 'Inflation' }
  | { readonly tag: 'ManageData'; readonly value: ManageDataOp }
  | { readonly tag: 'BumpSequence'; readonly value: BumpSequenceOp }
  | { readonly tag: 'ManageBuyOffer'; readonly value: ManageBuyOfferOp }
  | { readonly tag: 'PathPaymentStrictSend'; readonly value: PathPaymentStrictSendOp }
  | { readonly tag: 'CreateClaimableBalance'; readonly value: CreateClaimableBalanceOp }
  | { readonly tag: 'ClaimClaimableBalance'; readonly value: ClaimClaimableBalanceOp }
  | { readonly tag: 'BeginSponsoringFutureReserves'; readonly value: BeginSponsoringFutureReservesOp }
  | { readonly tag: 'EndSponsoringFutureReserves' }
  | { readonly tag: 'RevokeSponsorship'; readonly value: RevokeSponsorshipOp }
  | { readonly tag: 'Clawback'; readonly value: ClawbackOp }
  | { readonly tag: 'ClawbackClaimableBalance'; readonly value: ClawbackClaimableBalanceOp }
  | { readonly tag: 'SetTrustLineFlags'; readonly value: SetTrustLineFlagsOp }
  | { readonly tag: 'LiquidityPoolDeposit'; readonly value: LiquidityPoolDepositOp }
  | { readonly tag: 'LiquidityPoolWithdraw'; readonly value: LiquidityPoolWithdrawOp }
  | { readonly tag: 'InvokeHostFunction'; readonly value: InvokeHostFunctionOp }
  | { readonly tag: 'ExtendFootprintTtl'; readonly value: ExtendFootprintTTLOp }
  | { readonly tag: 'RestoreFootprint'; readonly value: RestoreFootprintOp }
;

export const OperationBody: XdrCodec<OperationBody> = taggedUnion({
  switchOn: OperationType,
  arms: [
    { tags: ['CreateAccount'], codec: CreateAccountOp },
    { tags: ['Payment'], codec: PaymentOp },
    { tags: ['PathPaymentStrictReceive'], codec: PathPaymentStrictReceiveOp },
    { tags: ['ManageSellOffer'], codec: ManageSellOfferOp },
    { tags: ['CreatePassiveSellOffer'], codec: CreatePassiveSellOfferOp },
    { tags: ['SetOptions'], codec: SetOptionsOp },
    { tags: ['ChangeTrust'], codec: ChangeTrustOp },
    { tags: ['AllowTrust'], codec: AllowTrustOp },
    { tags: ['AccountMerge'], codec: MuxedAccount },
    { tags: ['Inflation'] },
    { tags: ['ManageData'], codec: ManageDataOp },
    { tags: ['BumpSequence'], codec: BumpSequenceOp },
    { tags: ['ManageBuyOffer'], codec: ManageBuyOfferOp },
    { tags: ['PathPaymentStrictSend'], codec: PathPaymentStrictSendOp },
    { tags: ['CreateClaimableBalance'], codec: CreateClaimableBalanceOp },
    { tags: ['ClaimClaimableBalance'], codec: ClaimClaimableBalanceOp },
    { tags: ['BeginSponsoringFutureReserves'], codec: BeginSponsoringFutureReservesOp },
    { tags: ['EndSponsoringFutureReserves'] },
    { tags: ['RevokeSponsorship'], codec: RevokeSponsorshipOp },
    { tags: ['Clawback'], codec: ClawbackOp },
    { tags: ['ClawbackClaimableBalance'], codec: ClawbackClaimableBalanceOp },
    { tags: ['SetTrustLineFlags'], codec: SetTrustLineFlagsOp },
    { tags: ['LiquidityPoolDeposit'], codec: LiquidityPoolDepositOp },
    { tags: ['LiquidityPoolWithdraw'], codec: LiquidityPoolWithdrawOp },
    { tags: ['InvokeHostFunction'], codec: InvokeHostFunctionOp },
    { tags: ['ExtendFootprintTtl'], codec: ExtendFootprintTTLOp },
    { tags: ['RestoreFootprint'], codec: RestoreFootprintOp },
  ],
}) as XdrCodec<OperationBody>;

export interface Operation {
  readonly sourceAccount: MuxedAccount | undefined;
  readonly body: OperationBody;
}
export const Operation: XdrCodec<Operation> = xdrStruct<Operation>([
  ['sourceAccount', option(MuxedAccount)],
  ['body', OperationBody],
]);

export const MAX_OPS_PER_TX = 100;

export type TransactionV0Ext =
  | { readonly tag: 0 }
;

export const TransactionV0Ext: XdrCodec<TransactionV0Ext> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<TransactionV0Ext>;

export interface TransactionV0 {
  readonly sourceAccountEd25519: Uint256;
  readonly fee: Uint32;
  readonly seqNum: SequenceNumber;
  readonly timeBounds: TimeBounds | undefined;
  readonly memo: Memo;
  readonly operations: readonly Operation[];
  readonly ext: TransactionV0Ext;
}
export const TransactionV0: XdrCodec<TransactionV0> = xdrStruct<TransactionV0>([
  ['sourceAccountEd25519', Uint256],
  ['fee', Uint32],
  ['seqNum', SequenceNumber],
  ['timeBounds', option(TimeBounds)],
  ['memo', Memo],
  ['operations', varArray(MAX_OPS_PER_TX, Operation)],
  ['ext', TransactionV0Ext],
]);

export type SignatureHint = Uint8Array;
export const SignatureHint: XdrCodec<SignatureHint> = fixedOpaque(4);

export interface DecoratedSignature {
  readonly hint: SignatureHint;
  readonly signature: Signature;
}
export const DecoratedSignature: XdrCodec<DecoratedSignature> = xdrStruct<DecoratedSignature>([
  ['hint', SignatureHint],
  ['signature', Signature],
]);

export interface TransactionV0Envelope {
  readonly tx: TransactionV0;
  readonly signatures: readonly DecoratedSignature[];
}
export const TransactionV0Envelope: XdrCodec<TransactionV0Envelope> = xdrStruct<TransactionV0Envelope>([
  ['tx', TransactionV0],
  ['signatures', varArray(20, DecoratedSignature)],
]);

export type PreconditionType = 'None' | 'Time' | 'V2';
export const PreconditionType = xdrEnum({
  None: 0,
  Time: 1,
  V2: 2,
});

export interface LedgerBounds {
  readonly minLedger: Uint32;
  readonly maxLedger: Uint32;
}
export const LedgerBounds: XdrCodec<LedgerBounds> = xdrStruct<LedgerBounds>([
  ['minLedger', Uint32],
  ['maxLedger', Uint32],
]);

export interface PreconditionsV2 {
  readonly timeBounds: TimeBounds | undefined;
  readonly ledgerBounds: LedgerBounds | undefined;
  readonly minSeqNum: SequenceNumber | undefined;
  readonly minSeqAge: Duration;
  readonly minSeqLedgerGap: Uint32;
  readonly extraSigners: readonly SignerKey[];
}
export const PreconditionsV2: XdrCodec<PreconditionsV2> = xdrStruct<PreconditionsV2>([
  ['timeBounds', option(TimeBounds)],
  ['ledgerBounds', option(LedgerBounds)],
  ['minSeqNum', option(SequenceNumber)],
  ['minSeqAge', Duration],
  ['minSeqLedgerGap', Uint32],
  ['extraSigners', varArray(2, SignerKey)],
]);

export type Preconditions =
  | { readonly tag: 'None' }
  | { readonly tag: 'Time'; readonly value: TimeBounds }
  | { readonly tag: 'V2'; readonly value: PreconditionsV2 }
;

export const Preconditions: XdrCodec<Preconditions> = taggedUnion({
  switchOn: PreconditionType,
  arms: [
    { tags: ['None'] },
    { tags: ['Time'], codec: TimeBounds },
    { tags: ['V2'], codec: PreconditionsV2 },
  ],
}) as XdrCodec<Preconditions>;

export interface SorobanResourcesExtV0 {
  readonly archivedSorobanEntries: readonly Uint32[];
}
export const SorobanResourcesExtV0: XdrCodec<SorobanResourcesExtV0> = xdrStruct<SorobanResourcesExtV0>([
  ['archivedSorobanEntries', varArray(2147483647, Uint32)],
]);

export type SorobanTransactionDataExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: SorobanResourcesExtV0 }
;

export const SorobanTransactionDataExt: XdrCodec<SorobanTransactionDataExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: SorobanResourcesExtV0 },
  ],
}) as XdrCodec<SorobanTransactionDataExt>;

export interface LedgerFootprint {
  readonly readOnly: readonly LedgerKey[];
  readonly readWrite: readonly LedgerKey[];
}
export const LedgerFootprint: XdrCodec<LedgerFootprint> = xdrStruct<LedgerFootprint>([
  ['readOnly', varArray(2147483647, LedgerKey)],
  ['readWrite', varArray(2147483647, LedgerKey)],
]);

export interface SorobanResources {
  readonly footprint: LedgerFootprint;
  readonly instructions: Uint32;
  readonly diskReadBytes: Uint32;
  readonly writeBytes: Uint32;
}
export const SorobanResources: XdrCodec<SorobanResources> = xdrStruct<SorobanResources>([
  ['footprint', LedgerFootprint],
  ['instructions', Uint32],
  ['diskReadBytes', Uint32],
  ['writeBytes', Uint32],
]);

export interface SorobanTransactionData {
  readonly ext: SorobanTransactionDataExt;
  readonly resources: SorobanResources;
  readonly resourceFee: Int64;
}
export const SorobanTransactionData: XdrCodec<SorobanTransactionData> = xdrStruct<SorobanTransactionData>([
  ['ext', SorobanTransactionDataExt],
  ['resources', SorobanResources],
  ['resourceFee', Int64],
]);

export type TransactionExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: SorobanTransactionData }
;

export const TransactionExt: XdrCodec<TransactionExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: SorobanTransactionData },
  ],
}) as XdrCodec<TransactionExt>;

export interface Transaction {
  readonly sourceAccount: MuxedAccount;
  readonly fee: Uint32;
  readonly seqNum: SequenceNumber;
  readonly cond: Preconditions;
  readonly memo: Memo;
  readonly operations: readonly Operation[];
  readonly ext: TransactionExt;
}
export const Transaction: XdrCodec<Transaction> = xdrStruct<Transaction>([
  ['sourceAccount', MuxedAccount],
  ['fee', Uint32],
  ['seqNum', SequenceNumber],
  ['cond', Preconditions],
  ['memo', Memo],
  ['operations', varArray(MAX_OPS_PER_TX, Operation)],
  ['ext', TransactionExt],
]);

export interface TransactionV1Envelope {
  readonly tx: Transaction;
  readonly signatures: readonly DecoratedSignature[];
}
export const TransactionV1Envelope: XdrCodec<TransactionV1Envelope> = xdrStruct<TransactionV1Envelope>([
  ['tx', Transaction],
  ['signatures', varArray(20, DecoratedSignature)],
]);

export type FeeBumpTransactionInnerTx =
  | { readonly tag: 'Tx'; readonly value: TransactionV1Envelope }
;

export const FeeBumpTransactionInnerTx: XdrCodec<FeeBumpTransactionInnerTx> = taggedUnion({
  switchOn: EnvelopeType,
  arms: [
    { tags: ['Tx'], codec: TransactionV1Envelope },
  ],
}) as XdrCodec<FeeBumpTransactionInnerTx>;

export type FeeBumpTransactionExt =
  | { readonly tag: 0 }
;

export const FeeBumpTransactionExt: XdrCodec<FeeBumpTransactionExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<FeeBumpTransactionExt>;

export interface FeeBumpTransaction {
  readonly feeSource: MuxedAccount;
  readonly fee: Int64;
  readonly innerTx: FeeBumpTransactionInnerTx;
  readonly ext: FeeBumpTransactionExt;
}
export const FeeBumpTransaction: XdrCodec<FeeBumpTransaction> = xdrStruct<FeeBumpTransaction>([
  ['feeSource', MuxedAccount],
  ['fee', Int64],
  ['innerTx', FeeBumpTransactionInnerTx],
  ['ext', FeeBumpTransactionExt],
]);

export interface FeeBumpTransactionEnvelope {
  readonly tx: FeeBumpTransaction;
  readonly signatures: readonly DecoratedSignature[];
}
export const FeeBumpTransactionEnvelope: XdrCodec<FeeBumpTransactionEnvelope> = xdrStruct<FeeBumpTransactionEnvelope>([
  ['tx', FeeBumpTransaction],
  ['signatures', varArray(20, DecoratedSignature)],
]);

export type TransactionEnvelope =
  | { readonly tag: 'TxV0'; readonly value: TransactionV0Envelope }
  | { readonly tag: 'Tx'; readonly value: TransactionV1Envelope }
  | { readonly tag: 'TxFeeBump'; readonly value: FeeBumpTransactionEnvelope }
;

export const TransactionEnvelope: XdrCodec<TransactionEnvelope> = taggedUnion({
  switchOn: EnvelopeType,
  arms: [
    { tags: ['TxV0'], codec: TransactionV0Envelope },
    { tags: ['Tx'], codec: TransactionV1Envelope },
    { tags: ['TxFeeBump'], codec: FeeBumpTransactionEnvelope },
  ],
}) as XdrCodec<TransactionEnvelope>;

export interface TransactionSet {
  readonly previousLedgerHash: Hash;
  readonly txs: readonly TransactionEnvelope[];
}
export const TransactionSet: XdrCodec<TransactionSet> = xdrStruct<TransactionSet>([
  ['previousLedgerHash', Hash],
  ['txs', varArray(2147483647, TransactionEnvelope)],
]);

export type TransactionResultCode = 'TxFEEBumpInnerSuccess' | 'TxSUCCESS' | 'TxFAILED' | 'TxTOOEarly' | 'TxTOOLate' | 'TxMISSINGOperation' | 'TxBADSeq' | 'TxBADAuth' | 'TxINSUFFICIENTBalance' | 'TxNOAccount' | 'TxINSUFFICIENTFee' | 'TxBADAuthExtra' | 'TxINTERNALError' | 'TxNOTSupported' | 'TxFEEBumpInnerFailed' | 'TxBADSponsorship' | 'TxBADMinSeqAgeOrGap' | 'TxMALFORMED' | 'TxSOROBANInvalid';
export const TransactionResultCode = xdrEnum({
  TxFEEBumpInnerSuccess: 1,
  TxSUCCESS: 0,
  TxFAILED: -1,
  TxTOOEarly: -2,
  TxTOOLate: -3,
  TxMISSINGOperation: -4,
  TxBADSeq: -5,
  TxBADAuth: -6,
  TxINSUFFICIENTBalance: -7,
  TxNOAccount: -8,
  TxINSUFFICIENTFee: -9,
  TxBADAuthExtra: -10,
  TxINTERNALError: -11,
  TxNOTSupported: -12,
  TxFEEBumpInnerFailed: -13,
  TxBADSponsorship: -14,
  TxBADMinSeqAgeOrGap: -15,
  TxMALFORMED: -16,
  TxSOROBANInvalid: -17,
});

export type OperationResultCode = 'OpINNER' | 'OpBADAuth' | 'OpNOAccount' | 'OpNOTSupported' | 'OpTOOManySubentries' | 'OpEXCEEDEDWorkLimit' | 'OpTOOManySponsoring';
export const OperationResultCode = xdrEnum({
  OpINNER: 0,
  OpBADAuth: -1,
  OpNOAccount: -2,
  OpNOTSupported: -3,
  OpTOOManySubentries: -4,
  OpEXCEEDEDWorkLimit: -5,
  OpTOOManySponsoring: -6,
});

export type CreateAccountResultCode = 'Success' | 'Malformed' | 'Underfunded' | 'LowReserve' | 'AlreadyExist';
export const CreateAccountResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  Underfunded: -2,
  LowReserve: -3,
  AlreadyExist: -4,
});

export type CreateAccountResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'Underfunded' }
  | { readonly tag: 'LowReserve' }
  | { readonly tag: 'AlreadyExist' }
;

export const CreateAccountResult: XdrCodec<CreateAccountResult> = taggedUnion({
  switchOn: CreateAccountResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'Underfunded', 'LowReserve', 'AlreadyExist'] },
  ],
}) as XdrCodec<CreateAccountResult>;

export type PaymentResultCode = 'Success' | 'Malformed' | 'Underfunded' | 'SrcNoTrust' | 'SrcNotAuthorized' | 'NoDestination' | 'NoTrust' | 'NotAuthorized' | 'LineFull' | 'NoIssuer';
export const PaymentResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  Underfunded: -2,
  SrcNoTrust: -3,
  SrcNotAuthorized: -4,
  NoDestination: -5,
  NoTrust: -6,
  NotAuthorized: -7,
  LineFull: -8,
  NoIssuer: -9,
});

export type PaymentResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'Underfunded' }
  | { readonly tag: 'SrcNoTrust' }
  | { readonly tag: 'SrcNotAuthorized' }
  | { readonly tag: 'NoDestination' }
  | { readonly tag: 'NoTrust' }
  | { readonly tag: 'NotAuthorized' }
  | { readonly tag: 'LineFull' }
  | { readonly tag: 'NoIssuer' }
;

export const PaymentResult: XdrCodec<PaymentResult> = taggedUnion({
  switchOn: PaymentResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'Underfunded', 'SrcNoTrust', 'SrcNotAuthorized', 'NoDestination', 'NoTrust', 'NotAuthorized', 'LineFull', 'NoIssuer'] },
  ],
}) as XdrCodec<PaymentResult>;

export type PathPaymentStrictReceiveResultCode = 'Success' | 'Malformed' | 'Underfunded' | 'SrcNoTrust' | 'SrcNotAuthorized' | 'NoDestination' | 'NoTrust' | 'NotAuthorized' | 'LineFull' | 'NoIssuer' | 'TooFewOffers' | 'OfferCrossSelf' | 'OverSendmax';
export const PathPaymentStrictReceiveResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  Underfunded: -2,
  SrcNoTrust: -3,
  SrcNotAuthorized: -4,
  NoDestination: -5,
  NoTrust: -6,
  NotAuthorized: -7,
  LineFull: -8,
  NoIssuer: -9,
  TooFewOffers: -10,
  OfferCrossSelf: -11,
  OverSendmax: -12,
});

export type ClaimAtomType = 'V0' | 'OrderBook' | 'LiquidityPool';
export const ClaimAtomType = xdrEnum({
  V0: 0,
  OrderBook: 1,
  LiquidityPool: 2,
});

export interface ClaimOfferAtomV0 {
  readonly sellerEd25519: Uint256;
  readonly offerID: Int64;
  readonly assetSold: Asset;
  readonly amountSold: Int64;
  readonly assetBought: Asset;
  readonly amountBought: Int64;
}
export const ClaimOfferAtomV0: XdrCodec<ClaimOfferAtomV0> = xdrStruct<ClaimOfferAtomV0>([
  ['sellerEd25519', Uint256],
  ['offerID', Int64],
  ['assetSold', Asset],
  ['amountSold', Int64],
  ['assetBought', Asset],
  ['amountBought', Int64],
]);

export interface ClaimOfferAtom {
  readonly sellerID: AccountID;
  readonly offerID: Int64;
  readonly assetSold: Asset;
  readonly amountSold: Int64;
  readonly assetBought: Asset;
  readonly amountBought: Int64;
}
export const ClaimOfferAtom: XdrCodec<ClaimOfferAtom> = xdrStruct<ClaimOfferAtom>([
  ['sellerID', AccountID],
  ['offerID', Int64],
  ['assetSold', Asset],
  ['amountSold', Int64],
  ['assetBought', Asset],
  ['amountBought', Int64],
]);

export interface ClaimLiquidityAtom {
  readonly liquidityPoolID: PoolID;
  readonly assetSold: Asset;
  readonly amountSold: Int64;
  readonly assetBought: Asset;
  readonly amountBought: Int64;
}
export const ClaimLiquidityAtom: XdrCodec<ClaimLiquidityAtom> = xdrStruct<ClaimLiquidityAtom>([
  ['liquidityPoolID', PoolID],
  ['assetSold', Asset],
  ['amountSold', Int64],
  ['assetBought', Asset],
  ['amountBought', Int64],
]);

export type ClaimAtom =
  | { readonly tag: 'V0'; readonly value: ClaimOfferAtomV0 }
  | { readonly tag: 'OrderBook'; readonly value: ClaimOfferAtom }
  | { readonly tag: 'LiquidityPool'; readonly value: ClaimLiquidityAtom }
;

export const ClaimAtom: XdrCodec<ClaimAtom> = taggedUnion({
  switchOn: ClaimAtomType,
  arms: [
    { tags: ['V0'], codec: ClaimOfferAtomV0 },
    { tags: ['OrderBook'], codec: ClaimOfferAtom },
    { tags: ['LiquidityPool'], codec: ClaimLiquidityAtom },
  ],
}) as XdrCodec<ClaimAtom>;

export interface SimplePaymentResult {
  readonly destination: AccountID;
  readonly asset: Asset;
  readonly amount: Int64;
}
export const SimplePaymentResult: XdrCodec<SimplePaymentResult> = xdrStruct<SimplePaymentResult>([
  ['destination', AccountID],
  ['asset', Asset],
  ['amount', Int64],
]);

export interface PathPaymentStrictReceiveResultSuccess {
  readonly offers: readonly ClaimAtom[];
  readonly last: SimplePaymentResult;
}
export const PathPaymentStrictReceiveResultSuccess: XdrCodec<PathPaymentStrictReceiveResultSuccess> = xdrStruct<PathPaymentStrictReceiveResultSuccess>([
  ['offers', varArray(2147483647, ClaimAtom)],
  ['last', SimplePaymentResult],
]);

export type PathPaymentStrictReceiveResult =
  | { readonly tag: 'Success'; readonly value: PathPaymentStrictReceiveResultSuccess }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'Underfunded' }
  | { readonly tag: 'SrcNoTrust' }
  | { readonly tag: 'SrcNotAuthorized' }
  | { readonly tag: 'NoDestination' }
  | { readonly tag: 'NoTrust' }
  | { readonly tag: 'NotAuthorized' }
  | { readonly tag: 'LineFull' }
  | { readonly tag: 'NoIssuer'; readonly value: Asset }
  | { readonly tag: 'TooFewOffers' }
  | { readonly tag: 'OfferCrossSelf' }
  | { readonly tag: 'OverSendmax' }
;

export const PathPaymentStrictReceiveResult: XdrCodec<PathPaymentStrictReceiveResult> = taggedUnion({
  switchOn: PathPaymentStrictReceiveResultCode,
  arms: [
    { tags: ['Success'], codec: PathPaymentStrictReceiveResultSuccess },
    { tags: ['Malformed', 'Underfunded', 'SrcNoTrust', 'SrcNotAuthorized', 'NoDestination', 'NoTrust', 'NotAuthorized', 'LineFull'] },
    { tags: ['NoIssuer'], codec: Asset },
    { tags: ['TooFewOffers', 'OfferCrossSelf', 'OverSendmax'] },
  ],
}) as XdrCodec<PathPaymentStrictReceiveResult>;

export type ManageSellOfferResultCode = 'Success' | 'Malformed' | 'SellNoTrust' | 'BuyNoTrust' | 'SellNotAuthorized' | 'BuyNotAuthorized' | 'LineFull' | 'Underfunded' | 'CrossSelf' | 'SellNoIssuer' | 'BuyNoIssuer' | 'NotFound' | 'LowReserve';
export const ManageSellOfferResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  SellNoTrust: -2,
  BuyNoTrust: -3,
  SellNotAuthorized: -4,
  BuyNotAuthorized: -5,
  LineFull: -6,
  Underfunded: -7,
  CrossSelf: -8,
  SellNoIssuer: -9,
  BuyNoIssuer: -10,
  NotFound: -11,
  LowReserve: -12,
});

export type ManageOfferEffect = 'Created' | 'Updated' | 'Deleted';
export const ManageOfferEffect = xdrEnum({
  Created: 0,
  Updated: 1,
  Deleted: 2,
});

export type OfferEntryExt =
  | { readonly tag: 0 }
;

export const OfferEntryExt: XdrCodec<OfferEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<OfferEntryExt>;

export interface OfferEntry {
  readonly sellerID: AccountID;
  readonly offerID: Int64;
  readonly selling: Asset;
  readonly buying: Asset;
  readonly amount: Int64;
  readonly price: Price;
  readonly flags: Uint32;
  readonly ext: OfferEntryExt;
}
export const OfferEntry: XdrCodec<OfferEntry> = xdrStruct<OfferEntry>([
  ['sellerID', AccountID],
  ['offerID', Int64],
  ['selling', Asset],
  ['buying', Asset],
  ['amount', Int64],
  ['price', Price],
  ['flags', Uint32],
  ['ext', OfferEntryExt],
]);

export type ManageOfferSuccessResultOffer =
  | { readonly tag: 'Created'; readonly value: OfferEntry }
  | { readonly tag: 'Updated'; readonly value: OfferEntry }
  | { readonly tag: 'Deleted' }
;

export const ManageOfferSuccessResultOffer: XdrCodec<ManageOfferSuccessResultOffer> = taggedUnion({
  switchOn: ManageOfferEffect,
  arms: [
    { tags: ['Created', 'Updated'], codec: OfferEntry },
    { tags: ['Deleted'] },
  ],
}) as XdrCodec<ManageOfferSuccessResultOffer>;

export interface ManageOfferSuccessResult {
  readonly offersClaimed: readonly ClaimAtom[];
  readonly offer: ManageOfferSuccessResultOffer;
}
export const ManageOfferSuccessResult: XdrCodec<ManageOfferSuccessResult> = xdrStruct<ManageOfferSuccessResult>([
  ['offersClaimed', varArray(2147483647, ClaimAtom)],
  ['offer', ManageOfferSuccessResultOffer],
]);

export type ManageSellOfferResult =
  | { readonly tag: 'Success'; readonly value: ManageOfferSuccessResult }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'SellNoTrust' }
  | { readonly tag: 'BuyNoTrust' }
  | { readonly tag: 'SellNotAuthorized' }
  | { readonly tag: 'BuyNotAuthorized' }
  | { readonly tag: 'LineFull' }
  | { readonly tag: 'Underfunded' }
  | { readonly tag: 'CrossSelf' }
  | { readonly tag: 'SellNoIssuer' }
  | { readonly tag: 'BuyNoIssuer' }
  | { readonly tag: 'NotFound' }
  | { readonly tag: 'LowReserve' }
;

export const ManageSellOfferResult: XdrCodec<ManageSellOfferResult> = taggedUnion({
  switchOn: ManageSellOfferResultCode,
  arms: [
    { tags: ['Success'], codec: ManageOfferSuccessResult },
    { tags: ['Malformed', 'SellNoTrust', 'BuyNoTrust', 'SellNotAuthorized', 'BuyNotAuthorized', 'LineFull', 'Underfunded', 'CrossSelf', 'SellNoIssuer', 'BuyNoIssuer', 'NotFound', 'LowReserve'] },
  ],
}) as XdrCodec<ManageSellOfferResult>;

export type SetOptionsResultCode = 'Success' | 'LowReserve' | 'TooManySigners' | 'BadFlags' | 'InvalidInflation' | 'CantChange' | 'UnknownFlag' | 'ThresholdOutOfRange' | 'BadSigner' | 'InvalidHomeDomain' | 'AuthRevocableRequired';
export const SetOptionsResultCode = xdrEnum({
  Success: 0,
  LowReserve: -1,
  TooManySigners: -2,
  BadFlags: -3,
  InvalidInflation: -4,
  CantChange: -5,
  UnknownFlag: -6,
  ThresholdOutOfRange: -7,
  BadSigner: -8,
  InvalidHomeDomain: -9,
  AuthRevocableRequired: -10,
});

export type SetOptionsResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'LowReserve' }
  | { readonly tag: 'TooManySigners' }
  | { readonly tag: 'BadFlags' }
  | { readonly tag: 'InvalidInflation' }
  | { readonly tag: 'CantChange' }
  | { readonly tag: 'UnknownFlag' }
  | { readonly tag: 'ThresholdOutOfRange' }
  | { readonly tag: 'BadSigner' }
  | { readonly tag: 'InvalidHomeDomain' }
  | { readonly tag: 'AuthRevocableRequired' }
;

export const SetOptionsResult: XdrCodec<SetOptionsResult> = taggedUnion({
  switchOn: SetOptionsResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['LowReserve', 'TooManySigners', 'BadFlags', 'InvalidInflation', 'CantChange', 'UnknownFlag', 'ThresholdOutOfRange', 'BadSigner', 'InvalidHomeDomain', 'AuthRevocableRequired'] },
  ],
}) as XdrCodec<SetOptionsResult>;

export type ChangeTrustResultCode = 'Success' | 'Malformed' | 'NoIssuer' | 'InvalidLimit' | 'LowReserve' | 'SelfNotAllowed' | 'TrustLineMissing' | 'CannotDelete' | 'NotAuthMaintainLiabilities';
export const ChangeTrustResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  NoIssuer: -2,
  InvalidLimit: -3,
  LowReserve: -4,
  SelfNotAllowed: -5,
  TrustLineMissing: -6,
  CannotDelete: -7,
  NotAuthMaintainLiabilities: -8,
});

export type ChangeTrustResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'NoIssuer' }
  | { readonly tag: 'InvalidLimit' }
  | { readonly tag: 'LowReserve' }
  | { readonly tag: 'SelfNotAllowed' }
  | { readonly tag: 'TrustLineMissing' }
  | { readonly tag: 'CannotDelete' }
  | { readonly tag: 'NotAuthMaintainLiabilities' }
;

export const ChangeTrustResult: XdrCodec<ChangeTrustResult> = taggedUnion({
  switchOn: ChangeTrustResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'NoIssuer', 'InvalidLimit', 'LowReserve', 'SelfNotAllowed', 'TrustLineMissing', 'CannotDelete', 'NotAuthMaintainLiabilities'] },
  ],
}) as XdrCodec<ChangeTrustResult>;

export type AllowTrustResultCode = 'Success' | 'Malformed' | 'NoTrustLine' | 'TrustNotRequired' | 'CantRevoke' | 'SelfNotAllowed' | 'LowReserve';
export const AllowTrustResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  NoTrustLine: -2,
  TrustNotRequired: -3,
  CantRevoke: -4,
  SelfNotAllowed: -5,
  LowReserve: -6,
});

export type AllowTrustResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'NoTrustLine' }
  | { readonly tag: 'TrustNotRequired' }
  | { readonly tag: 'CantRevoke' }
  | { readonly tag: 'SelfNotAllowed' }
  | { readonly tag: 'LowReserve' }
;

export const AllowTrustResult: XdrCodec<AllowTrustResult> = taggedUnion({
  switchOn: AllowTrustResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'NoTrustLine', 'TrustNotRequired', 'CantRevoke', 'SelfNotAllowed', 'LowReserve'] },
  ],
}) as XdrCodec<AllowTrustResult>;

export type AccountMergeResultCode = 'Success' | 'Malformed' | 'NoAccount' | 'ImmutableSet' | 'HasSubEntries' | 'SeqnumTooFar' | 'DestFull' | 'IsSponsor';
export const AccountMergeResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  NoAccount: -2,
  ImmutableSet: -3,
  HasSubEntries: -4,
  SeqnumTooFar: -5,
  DestFull: -6,
  IsSponsor: -7,
});

export type AccountMergeResult =
  | { readonly tag: 'Success'; readonly value: Int64 }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'NoAccount' }
  | { readonly tag: 'ImmutableSet' }
  | { readonly tag: 'HasSubEntries' }
  | { readonly tag: 'SeqnumTooFar' }
  | { readonly tag: 'DestFull' }
  | { readonly tag: 'IsSponsor' }
;

export const AccountMergeResult: XdrCodec<AccountMergeResult> = taggedUnion({
  switchOn: AccountMergeResultCode,
  arms: [
    { tags: ['Success'], codec: Int64 },
    { tags: ['Malformed', 'NoAccount', 'ImmutableSet', 'HasSubEntries', 'SeqnumTooFar', 'DestFull', 'IsSponsor'] },
  ],
}) as XdrCodec<AccountMergeResult>;

export type InflationResultCode = 'Success' | 'NotTime';
export const InflationResultCode = xdrEnum({
  Success: 0,
  NotTime: -1,
});

export interface InflationPayout {
  readonly destination: AccountID;
  readonly amount: Int64;
}
export const InflationPayout: XdrCodec<InflationPayout> = xdrStruct<InflationPayout>([
  ['destination', AccountID],
  ['amount', Int64],
]);

export type InflationResult =
  | { readonly tag: 'Success'; readonly value: readonly InflationPayout[] }
  | { readonly tag: 'NotTime' }
;

export const InflationResult: XdrCodec<InflationResult> = taggedUnion({
  switchOn: InflationResultCode,
  arms: [
    { tags: ['Success'], codec: varArray(2147483647, InflationPayout) },
    { tags: ['NotTime'] },
  ],
}) as XdrCodec<InflationResult>;

export type ManageDataResultCode = 'Success' | 'NotSupportedYet' | 'NameNotFound' | 'LowReserve' | 'InvalidName';
export const ManageDataResultCode = xdrEnum({
  Success: 0,
  NotSupportedYet: -1,
  NameNotFound: -2,
  LowReserve: -3,
  InvalidName: -4,
});

export type ManageDataResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'NotSupportedYet' }
  | { readonly tag: 'NameNotFound' }
  | { readonly tag: 'LowReserve' }
  | { readonly tag: 'InvalidName' }
;

export const ManageDataResult: XdrCodec<ManageDataResult> = taggedUnion({
  switchOn: ManageDataResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['NotSupportedYet', 'NameNotFound', 'LowReserve', 'InvalidName'] },
  ],
}) as XdrCodec<ManageDataResult>;

export type BumpSequenceResultCode = 'Success' | 'BadSeq';
export const BumpSequenceResultCode = xdrEnum({
  Success: 0,
  BadSeq: -1,
});

export type BumpSequenceResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'BadSeq' }
;

export const BumpSequenceResult: XdrCodec<BumpSequenceResult> = taggedUnion({
  switchOn: BumpSequenceResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['BadSeq'] },
  ],
}) as XdrCodec<BumpSequenceResult>;

export type ManageBuyOfferResultCode = 'Success' | 'Malformed' | 'SellNoTrust' | 'BuyNoTrust' | 'SellNotAuthorized' | 'BuyNotAuthorized' | 'LineFull' | 'Underfunded' | 'CrossSelf' | 'SellNoIssuer' | 'BuyNoIssuer' | 'NotFound' | 'LowReserve';
export const ManageBuyOfferResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  SellNoTrust: -2,
  BuyNoTrust: -3,
  SellNotAuthorized: -4,
  BuyNotAuthorized: -5,
  LineFull: -6,
  Underfunded: -7,
  CrossSelf: -8,
  SellNoIssuer: -9,
  BuyNoIssuer: -10,
  NotFound: -11,
  LowReserve: -12,
});

export type ManageBuyOfferResult =
  | { readonly tag: 'Success'; readonly value: ManageOfferSuccessResult }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'SellNoTrust' }
  | { readonly tag: 'BuyNoTrust' }
  | { readonly tag: 'SellNotAuthorized' }
  | { readonly tag: 'BuyNotAuthorized' }
  | { readonly tag: 'LineFull' }
  | { readonly tag: 'Underfunded' }
  | { readonly tag: 'CrossSelf' }
  | { readonly tag: 'SellNoIssuer' }
  | { readonly tag: 'BuyNoIssuer' }
  | { readonly tag: 'NotFound' }
  | { readonly tag: 'LowReserve' }
;

export const ManageBuyOfferResult: XdrCodec<ManageBuyOfferResult> = taggedUnion({
  switchOn: ManageBuyOfferResultCode,
  arms: [
    { tags: ['Success'], codec: ManageOfferSuccessResult },
    { tags: ['Malformed', 'SellNoTrust', 'BuyNoTrust', 'SellNotAuthorized', 'BuyNotAuthorized', 'LineFull', 'Underfunded', 'CrossSelf', 'SellNoIssuer', 'BuyNoIssuer', 'NotFound', 'LowReserve'] },
  ],
}) as XdrCodec<ManageBuyOfferResult>;

export type PathPaymentStrictSendResultCode = 'Success' | 'Malformed' | 'Underfunded' | 'SrcNoTrust' | 'SrcNotAuthorized' | 'NoDestination' | 'NoTrust' | 'NotAuthorized' | 'LineFull' | 'NoIssuer' | 'TooFewOffers' | 'OfferCrossSelf' | 'UnderDestmin';
export const PathPaymentStrictSendResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  Underfunded: -2,
  SrcNoTrust: -3,
  SrcNotAuthorized: -4,
  NoDestination: -5,
  NoTrust: -6,
  NotAuthorized: -7,
  LineFull: -8,
  NoIssuer: -9,
  TooFewOffers: -10,
  OfferCrossSelf: -11,
  UnderDestmin: -12,
});

export interface PathPaymentStrictSendResultSuccess {
  readonly offers: readonly ClaimAtom[];
  readonly last: SimplePaymentResult;
}
export const PathPaymentStrictSendResultSuccess: XdrCodec<PathPaymentStrictSendResultSuccess> = xdrStruct<PathPaymentStrictSendResultSuccess>([
  ['offers', varArray(2147483647, ClaimAtom)],
  ['last', SimplePaymentResult],
]);

export type PathPaymentStrictSendResult =
  | { readonly tag: 'Success'; readonly value: PathPaymentStrictSendResultSuccess }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'Underfunded' }
  | { readonly tag: 'SrcNoTrust' }
  | { readonly tag: 'SrcNotAuthorized' }
  | { readonly tag: 'NoDestination' }
  | { readonly tag: 'NoTrust' }
  | { readonly tag: 'NotAuthorized' }
  | { readonly tag: 'LineFull' }
  | { readonly tag: 'NoIssuer'; readonly value: Asset }
  | { readonly tag: 'TooFewOffers' }
  | { readonly tag: 'OfferCrossSelf' }
  | { readonly tag: 'UnderDestmin' }
;

export const PathPaymentStrictSendResult: XdrCodec<PathPaymentStrictSendResult> = taggedUnion({
  switchOn: PathPaymentStrictSendResultCode,
  arms: [
    { tags: ['Success'], codec: PathPaymentStrictSendResultSuccess },
    { tags: ['Malformed', 'Underfunded', 'SrcNoTrust', 'SrcNotAuthorized', 'NoDestination', 'NoTrust', 'NotAuthorized', 'LineFull'] },
    { tags: ['NoIssuer'], codec: Asset },
    { tags: ['TooFewOffers', 'OfferCrossSelf', 'UnderDestmin'] },
  ],
}) as XdrCodec<PathPaymentStrictSendResult>;

export type CreateClaimableBalanceResultCode = 'Success' | 'Malformed' | 'LowReserve' | 'NoTrust' | 'NotAuthorized' | 'Underfunded';
export const CreateClaimableBalanceResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  LowReserve: -2,
  NoTrust: -3,
  NotAuthorized: -4,
  Underfunded: -5,
});

export type CreateClaimableBalanceResult =
  | { readonly tag: 'Success'; readonly value: ClaimableBalanceID }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'LowReserve' }
  | { readonly tag: 'NoTrust' }
  | { readonly tag: 'NotAuthorized' }
  | { readonly tag: 'Underfunded' }
;

export const CreateClaimableBalanceResult: XdrCodec<CreateClaimableBalanceResult> = taggedUnion({
  switchOn: CreateClaimableBalanceResultCode,
  arms: [
    { tags: ['Success'], codec: ClaimableBalanceID },
    { tags: ['Malformed', 'LowReserve', 'NoTrust', 'NotAuthorized', 'Underfunded'] },
  ],
}) as XdrCodec<CreateClaimableBalanceResult>;

export type ClaimClaimableBalanceResultCode = 'Success' | 'DoesNotExist' | 'CannotClaim' | 'LineFull' | 'NoTrust' | 'NotAuthorized';
export const ClaimClaimableBalanceResultCode = xdrEnum({
  Success: 0,
  DoesNotExist: -1,
  CannotClaim: -2,
  LineFull: -3,
  NoTrust: -4,
  NotAuthorized: -5,
});

export type ClaimClaimableBalanceResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'DoesNotExist' }
  | { readonly tag: 'CannotClaim' }
  | { readonly tag: 'LineFull' }
  | { readonly tag: 'NoTrust' }
  | { readonly tag: 'NotAuthorized' }
;

export const ClaimClaimableBalanceResult: XdrCodec<ClaimClaimableBalanceResult> = taggedUnion({
  switchOn: ClaimClaimableBalanceResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['DoesNotExist', 'CannotClaim', 'LineFull', 'NoTrust', 'NotAuthorized'] },
  ],
}) as XdrCodec<ClaimClaimableBalanceResult>;

export type BeginSponsoringFutureReservesResultCode = 'Success' | 'Malformed' | 'AlreadySponsored' | 'Recursive';
export const BeginSponsoringFutureReservesResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  AlreadySponsored: -2,
  Recursive: -3,
});

export type BeginSponsoringFutureReservesResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'AlreadySponsored' }
  | { readonly tag: 'Recursive' }
;

export const BeginSponsoringFutureReservesResult: XdrCodec<BeginSponsoringFutureReservesResult> = taggedUnion({
  switchOn: BeginSponsoringFutureReservesResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'AlreadySponsored', 'Recursive'] },
  ],
}) as XdrCodec<BeginSponsoringFutureReservesResult>;

export type EndSponsoringFutureReservesResultCode = 'Success' | 'NotSponsored';
export const EndSponsoringFutureReservesResultCode = xdrEnum({
  Success: 0,
  NotSponsored: -1,
});

export type EndSponsoringFutureReservesResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'NotSponsored' }
;

export const EndSponsoringFutureReservesResult: XdrCodec<EndSponsoringFutureReservesResult> = taggedUnion({
  switchOn: EndSponsoringFutureReservesResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['NotSponsored'] },
  ],
}) as XdrCodec<EndSponsoringFutureReservesResult>;

export type RevokeSponsorshipResultCode = 'Success' | 'DoesNotExist' | 'NotSponsor' | 'LowReserve' | 'OnlyTransferable' | 'Malformed';
export const RevokeSponsorshipResultCode = xdrEnum({
  Success: 0,
  DoesNotExist: -1,
  NotSponsor: -2,
  LowReserve: -3,
  OnlyTransferable: -4,
  Malformed: -5,
});

export type RevokeSponsorshipResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'DoesNotExist' }
  | { readonly tag: 'NotSponsor' }
  | { readonly tag: 'LowReserve' }
  | { readonly tag: 'OnlyTransferable' }
  | { readonly tag: 'Malformed' }
;

export const RevokeSponsorshipResult: XdrCodec<RevokeSponsorshipResult> = taggedUnion({
  switchOn: RevokeSponsorshipResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['DoesNotExist', 'NotSponsor', 'LowReserve', 'OnlyTransferable', 'Malformed'] },
  ],
}) as XdrCodec<RevokeSponsorshipResult>;

export type ClawbackResultCode = 'Success' | 'Malformed' | 'NotClawbackEnabled' | 'NoTrust' | 'Underfunded';
export const ClawbackResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  NotClawbackEnabled: -2,
  NoTrust: -3,
  Underfunded: -4,
});

export type ClawbackResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'NotClawbackEnabled' }
  | { readonly tag: 'NoTrust' }
  | { readonly tag: 'Underfunded' }
;

export const ClawbackResult: XdrCodec<ClawbackResult> = taggedUnion({
  switchOn: ClawbackResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'NotClawbackEnabled', 'NoTrust', 'Underfunded'] },
  ],
}) as XdrCodec<ClawbackResult>;

export type ClawbackClaimableBalanceResultCode = 'Success' | 'DoesNotExist' | 'NotIssuer' | 'NotClawbackEnabled';
export const ClawbackClaimableBalanceResultCode = xdrEnum({
  Success: 0,
  DoesNotExist: -1,
  NotIssuer: -2,
  NotClawbackEnabled: -3,
});

export type ClawbackClaimableBalanceResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'DoesNotExist' }
  | { readonly tag: 'NotIssuer' }
  | { readonly tag: 'NotClawbackEnabled' }
;

export const ClawbackClaimableBalanceResult: XdrCodec<ClawbackClaimableBalanceResult> = taggedUnion({
  switchOn: ClawbackClaimableBalanceResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['DoesNotExist', 'NotIssuer', 'NotClawbackEnabled'] },
  ],
}) as XdrCodec<ClawbackClaimableBalanceResult>;

export type SetTrustLineFlagsResultCode = 'Success' | 'Malformed' | 'NoTrustLine' | 'CantRevoke' | 'InvalidState' | 'LowReserve';
export const SetTrustLineFlagsResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  NoTrustLine: -2,
  CantRevoke: -3,
  InvalidState: -4,
  LowReserve: -5,
});

export type SetTrustLineFlagsResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'NoTrustLine' }
  | { readonly tag: 'CantRevoke' }
  | { readonly tag: 'InvalidState' }
  | { readonly tag: 'LowReserve' }
;

export const SetTrustLineFlagsResult: XdrCodec<SetTrustLineFlagsResult> = taggedUnion({
  switchOn: SetTrustLineFlagsResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'NoTrustLine', 'CantRevoke', 'InvalidState', 'LowReserve'] },
  ],
}) as XdrCodec<SetTrustLineFlagsResult>;

export type LiquidityPoolDepositResultCode = 'Success' | 'Malformed' | 'NoTrust' | 'NotAuthorized' | 'Underfunded' | 'LineFull' | 'BadPrice' | 'PoolFull';
export const LiquidityPoolDepositResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  NoTrust: -2,
  NotAuthorized: -3,
  Underfunded: -4,
  LineFull: -5,
  BadPrice: -6,
  PoolFull: -7,
});

export type LiquidityPoolDepositResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'NoTrust' }
  | { readonly tag: 'NotAuthorized' }
  | { readonly tag: 'Underfunded' }
  | { readonly tag: 'LineFull' }
  | { readonly tag: 'BadPrice' }
  | { readonly tag: 'PoolFull' }
;

export const LiquidityPoolDepositResult: XdrCodec<LiquidityPoolDepositResult> = taggedUnion({
  switchOn: LiquidityPoolDepositResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'NoTrust', 'NotAuthorized', 'Underfunded', 'LineFull', 'BadPrice', 'PoolFull'] },
  ],
}) as XdrCodec<LiquidityPoolDepositResult>;

export type LiquidityPoolWithdrawResultCode = 'Success' | 'Malformed' | 'NoTrust' | 'Underfunded' | 'LineFull' | 'UnderMinimum';
export const LiquidityPoolWithdrawResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  NoTrust: -2,
  Underfunded: -3,
  LineFull: -4,
  UnderMinimum: -5,
});

export type LiquidityPoolWithdrawResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'NoTrust' }
  | { readonly tag: 'Underfunded' }
  | { readonly tag: 'LineFull' }
  | { readonly tag: 'UnderMinimum' }
;

export const LiquidityPoolWithdrawResult: XdrCodec<LiquidityPoolWithdrawResult> = taggedUnion({
  switchOn: LiquidityPoolWithdrawResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'NoTrust', 'Underfunded', 'LineFull', 'UnderMinimum'] },
  ],
}) as XdrCodec<LiquidityPoolWithdrawResult>;

export type InvokeHostFunctionResultCode = 'Success' | 'Malformed' | 'Trapped' | 'ResourceLimitExceeded' | 'EntryArchived' | 'InsufficientRefundableFee';
export const InvokeHostFunctionResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  Trapped: -2,
  ResourceLimitExceeded: -3,
  EntryArchived: -4,
  InsufficientRefundableFee: -5,
});

export type InvokeHostFunctionResult =
  | { readonly tag: 'Success'; readonly value: Hash }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'Trapped' }
  | { readonly tag: 'ResourceLimitExceeded' }
  | { readonly tag: 'EntryArchived' }
  | { readonly tag: 'InsufficientRefundableFee' }
;

export const InvokeHostFunctionResult: XdrCodec<InvokeHostFunctionResult> = taggedUnion({
  switchOn: InvokeHostFunctionResultCode,
  arms: [
    { tags: ['Success'], codec: Hash },
    { tags: ['Malformed', 'Trapped', 'ResourceLimitExceeded', 'EntryArchived', 'InsufficientRefundableFee'] },
  ],
}) as XdrCodec<InvokeHostFunctionResult>;

export type ExtendFootprintTTLResultCode = 'Success' | 'Malformed' | 'ResourceLimitExceeded' | 'InsufficientRefundableFee';
export const ExtendFootprintTTLResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  ResourceLimitExceeded: -2,
  InsufficientRefundableFee: -3,
});

export type ExtendFootprintTTLResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'ResourceLimitExceeded' }
  | { readonly tag: 'InsufficientRefundableFee' }
;

export const ExtendFootprintTTLResult: XdrCodec<ExtendFootprintTTLResult> = taggedUnion({
  switchOn: ExtendFootprintTTLResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'ResourceLimitExceeded', 'InsufficientRefundableFee'] },
  ],
}) as XdrCodec<ExtendFootprintTTLResult>;

export type RestoreFootprintResultCode = 'Success' | 'Malformed' | 'ResourceLimitExceeded' | 'InsufficientRefundableFee';
export const RestoreFootprintResultCode = xdrEnum({
  Success: 0,
  Malformed: -1,
  ResourceLimitExceeded: -2,
  InsufficientRefundableFee: -3,
});

export type RestoreFootprintResult =
  | { readonly tag: 'Success' }
  | { readonly tag: 'Malformed' }
  | { readonly tag: 'ResourceLimitExceeded' }
  | { readonly tag: 'InsufficientRefundableFee' }
;

export const RestoreFootprintResult: XdrCodec<RestoreFootprintResult> = taggedUnion({
  switchOn: RestoreFootprintResultCode,
  arms: [
    { tags: ['Success'] },
    { tags: ['Malformed', 'ResourceLimitExceeded', 'InsufficientRefundableFee'] },
  ],
}) as XdrCodec<RestoreFootprintResult>;

export type OperationResultTr =
  | { readonly tag: 'CreateAccount'; readonly value: CreateAccountResult }
  | { readonly tag: 'Payment'; readonly value: PaymentResult }
  | { readonly tag: 'PathPaymentStrictReceive'; readonly value: PathPaymentStrictReceiveResult }
  | { readonly tag: 'ManageSellOffer'; readonly value: ManageSellOfferResult }
  | { readonly tag: 'CreatePassiveSellOffer'; readonly value: ManageSellOfferResult }
  | { readonly tag: 'SetOptions'; readonly value: SetOptionsResult }
  | { readonly tag: 'ChangeTrust'; readonly value: ChangeTrustResult }
  | { readonly tag: 'AllowTrust'; readonly value: AllowTrustResult }
  | { readonly tag: 'AccountMerge'; readonly value: AccountMergeResult }
  | { readonly tag: 'Inflation'; readonly value: InflationResult }
  | { readonly tag: 'ManageData'; readonly value: ManageDataResult }
  | { readonly tag: 'BumpSequence'; readonly value: BumpSequenceResult }
  | { readonly tag: 'ManageBuyOffer'; readonly value: ManageBuyOfferResult }
  | { readonly tag: 'PathPaymentStrictSend'; readonly value: PathPaymentStrictSendResult }
  | { readonly tag: 'CreateClaimableBalance'; readonly value: CreateClaimableBalanceResult }
  | { readonly tag: 'ClaimClaimableBalance'; readonly value: ClaimClaimableBalanceResult }
  | { readonly tag: 'BeginSponsoringFutureReserves'; readonly value: BeginSponsoringFutureReservesResult }
  | { readonly tag: 'EndSponsoringFutureReserves'; readonly value: EndSponsoringFutureReservesResult }
  | { readonly tag: 'RevokeSponsorship'; readonly value: RevokeSponsorshipResult }
  | { readonly tag: 'Clawback'; readonly value: ClawbackResult }
  | { readonly tag: 'ClawbackClaimableBalance'; readonly value: ClawbackClaimableBalanceResult }
  | { readonly tag: 'SetTrustLineFlags'; readonly value: SetTrustLineFlagsResult }
  | { readonly tag: 'LiquidityPoolDeposit'; readonly value: LiquidityPoolDepositResult }
  | { readonly tag: 'LiquidityPoolWithdraw'; readonly value: LiquidityPoolWithdrawResult }
  | { readonly tag: 'InvokeHostFunction'; readonly value: InvokeHostFunctionResult }
  | { readonly tag: 'ExtendFootprintTtl'; readonly value: ExtendFootprintTTLResult }
  | { readonly tag: 'RestoreFootprint'; readonly value: RestoreFootprintResult }
;

export const OperationResultTr: XdrCodec<OperationResultTr> = taggedUnion({
  switchOn: OperationType,
  arms: [
    { tags: ['CreateAccount'], codec: CreateAccountResult },
    { tags: ['Payment'], codec: PaymentResult },
    { tags: ['PathPaymentStrictReceive'], codec: PathPaymentStrictReceiveResult },
    { tags: ['ManageSellOffer'], codec: ManageSellOfferResult },
    { tags: ['CreatePassiveSellOffer'], codec: ManageSellOfferResult },
    { tags: ['SetOptions'], codec: SetOptionsResult },
    { tags: ['ChangeTrust'], codec: ChangeTrustResult },
    { tags: ['AllowTrust'], codec: AllowTrustResult },
    { tags: ['AccountMerge'], codec: AccountMergeResult },
    { tags: ['Inflation'], codec: InflationResult },
    { tags: ['ManageData'], codec: ManageDataResult },
    { tags: ['BumpSequence'], codec: BumpSequenceResult },
    { tags: ['ManageBuyOffer'], codec: ManageBuyOfferResult },
    { tags: ['PathPaymentStrictSend'], codec: PathPaymentStrictSendResult },
    { tags: ['CreateClaimableBalance'], codec: CreateClaimableBalanceResult },
    { tags: ['ClaimClaimableBalance'], codec: ClaimClaimableBalanceResult },
    { tags: ['BeginSponsoringFutureReserves'], codec: BeginSponsoringFutureReservesResult },
    { tags: ['EndSponsoringFutureReserves'], codec: EndSponsoringFutureReservesResult },
    { tags: ['RevokeSponsorship'], codec: RevokeSponsorshipResult },
    { tags: ['Clawback'], codec: ClawbackResult },
    { tags: ['ClawbackClaimableBalance'], codec: ClawbackClaimableBalanceResult },
    { tags: ['SetTrustLineFlags'], codec: SetTrustLineFlagsResult },
    { tags: ['LiquidityPoolDeposit'], codec: LiquidityPoolDepositResult },
    { tags: ['LiquidityPoolWithdraw'], codec: LiquidityPoolWithdrawResult },
    { tags: ['InvokeHostFunction'], codec: InvokeHostFunctionResult },
    { tags: ['ExtendFootprintTtl'], codec: ExtendFootprintTTLResult },
    { tags: ['RestoreFootprint'], codec: RestoreFootprintResult },
  ],
}) as XdrCodec<OperationResultTr>;

export type OperationResult =
  | { readonly tag: 'OpINNER'; readonly value: OperationResultTr }
  | { readonly tag: 'OpBADAuth' }
  | { readonly tag: 'OpNOAccount' }
  | { readonly tag: 'OpNOTSupported' }
  | { readonly tag: 'OpTOOManySubentries' }
  | { readonly tag: 'OpEXCEEDEDWorkLimit' }
  | { readonly tag: 'OpTOOManySponsoring' }
;

export const OperationResult: XdrCodec<OperationResult> = taggedUnion({
  switchOn: OperationResultCode,
  arms: [
    { tags: ['OpINNER'], codec: OperationResultTr },
    { tags: ['OpBADAuth', 'OpNOAccount', 'OpNOTSupported', 'OpTOOManySubentries', 'OpEXCEEDEDWorkLimit', 'OpTOOManySponsoring'] },
  ],
}) as XdrCodec<OperationResult>;

export type InnerTransactionResultResult =
  | { readonly tag: 'TxSUCCESS'; readonly value: readonly OperationResult[] }
  | { readonly tag: 'TxFAILED'; readonly value: readonly OperationResult[] }
  | { readonly tag: 'TxTOOEarly' }
  | { readonly tag: 'TxTOOLate' }
  | { readonly tag: 'TxMISSINGOperation' }
  | { readonly tag: 'TxBADSeq' }
  | { readonly tag: 'TxBADAuth' }
  | { readonly tag: 'TxINSUFFICIENTBalance' }
  | { readonly tag: 'TxNOAccount' }
  | { readonly tag: 'TxINSUFFICIENTFee' }
  | { readonly tag: 'TxBADAuthExtra' }
  | { readonly tag: 'TxINTERNALError' }
  | { readonly tag: 'TxNOTSupported' }
  | { readonly tag: 'TxBADSponsorship' }
  | { readonly tag: 'TxBADMinSeqAgeOrGap' }
  | { readonly tag: 'TxMALFORMED' }
  | { readonly tag: 'TxSOROBANInvalid' }
;

export const InnerTransactionResultResult: XdrCodec<InnerTransactionResultResult> = taggedUnion({
  switchOn: TransactionResultCode,
  arms: [
    { tags: ['TxSUCCESS', 'TxFAILED'], codec: varArray(2147483647, OperationResult) },
    { tags: ['TxTOOEarly', 'TxTOOLate', 'TxMISSINGOperation', 'TxBADSeq', 'TxBADAuth', 'TxINSUFFICIENTBalance', 'TxNOAccount', 'TxINSUFFICIENTFee', 'TxBADAuthExtra', 'TxINTERNALError', 'TxNOTSupported', 'TxBADSponsorship', 'TxBADMinSeqAgeOrGap', 'TxMALFORMED', 'TxSOROBANInvalid'] },
  ],
}) as XdrCodec<InnerTransactionResultResult>;

export type InnerTransactionResultExt =
  | { readonly tag: 0 }
;

export const InnerTransactionResultExt: XdrCodec<InnerTransactionResultExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<InnerTransactionResultExt>;

export interface InnerTransactionResult {
  readonly feeCharged: Int64;
  readonly result: InnerTransactionResultResult;
  readonly ext: InnerTransactionResultExt;
}
export const InnerTransactionResult: XdrCodec<InnerTransactionResult> = xdrStruct<InnerTransactionResult>([
  ['feeCharged', Int64],
  ['result', InnerTransactionResultResult],
  ['ext', InnerTransactionResultExt],
]);

export interface InnerTransactionResultPair {
  readonly transactionHash: Hash;
  readonly result: InnerTransactionResult;
}
export const InnerTransactionResultPair: XdrCodec<InnerTransactionResultPair> = xdrStruct<InnerTransactionResultPair>([
  ['transactionHash', Hash],
  ['result', InnerTransactionResult],
]);

export type TransactionResultResult =
  | { readonly tag: 'TxFEEBumpInnerSuccess'; readonly value: InnerTransactionResultPair }
  | { readonly tag: 'TxFEEBumpInnerFailed'; readonly value: InnerTransactionResultPair }
  | { readonly tag: 'TxSUCCESS'; readonly value: readonly OperationResult[] }
  | { readonly tag: 'TxFAILED'; readonly value: readonly OperationResult[] }
  | { readonly tag: 'TxTOOEarly' }
  | { readonly tag: 'TxTOOLate' }
  | { readonly tag: 'TxMISSINGOperation' }
  | { readonly tag: 'TxBADSeq' }
  | { readonly tag: 'TxBADAuth' }
  | { readonly tag: 'TxINSUFFICIENTBalance' }
  | { readonly tag: 'TxNOAccount' }
  | { readonly tag: 'TxINSUFFICIENTFee' }
  | { readonly tag: 'TxBADAuthExtra' }
  | { readonly tag: 'TxINTERNALError' }
  | { readonly tag: 'TxNOTSupported' }
  | { readonly tag: 'TxBADSponsorship' }
  | { readonly tag: 'TxBADMinSeqAgeOrGap' }
  | { readonly tag: 'TxMALFORMED' }
  | { readonly tag: 'TxSOROBANInvalid' }
;

export const TransactionResultResult: XdrCodec<TransactionResultResult> = taggedUnion({
  switchOn: TransactionResultCode,
  arms: [
    { tags: ['TxFEEBumpInnerSuccess', 'TxFEEBumpInnerFailed'], codec: InnerTransactionResultPair },
    { tags: ['TxSUCCESS', 'TxFAILED'], codec: varArray(2147483647, OperationResult) },
    { tags: ['TxTOOEarly', 'TxTOOLate', 'TxMISSINGOperation', 'TxBADSeq', 'TxBADAuth', 'TxINSUFFICIENTBalance', 'TxNOAccount', 'TxINSUFFICIENTFee', 'TxBADAuthExtra', 'TxINTERNALError', 'TxNOTSupported', 'TxBADSponsorship', 'TxBADMinSeqAgeOrGap', 'TxMALFORMED', 'TxSOROBANInvalid'] },
  ],
}) as XdrCodec<TransactionResultResult>;

export type TransactionResultExt =
  | { readonly tag: 0 }
;

export const TransactionResultExt: XdrCodec<TransactionResultExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<TransactionResultExt>;

export interface TransactionResult {
  readonly feeCharged: Int64;
  readonly result: TransactionResultResult;
  readonly ext: TransactionResultExt;
}
export const TransactionResult: XdrCodec<TransactionResult> = xdrStruct<TransactionResult>([
  ['feeCharged', Int64],
  ['result', TransactionResultResult],
  ['ext', TransactionResultExt],
]);

export interface TransactionResultPair {
  readonly transactionHash: Hash;
  readonly result: TransactionResult;
}
export const TransactionResultPair: XdrCodec<TransactionResultPair> = xdrStruct<TransactionResultPair>([
  ['transactionHash', Hash],
  ['result', TransactionResult],
]);

export type LedgerEntryChangeType = 'Created' | 'Updated' | 'Removed' | 'State' | 'Restored';
export const LedgerEntryChangeType = xdrEnum({
  Created: 0,
  Updated: 1,
  Removed: 2,
  State: 3,
  Restored: 4,
});

export type Thresholds = Uint8Array;
export const Thresholds: XdrCodec<Thresholds> = fixedOpaque(4);

export const MAX_SIGNERS = 20;

export interface Liabilities {
  readonly buying: Int64;
  readonly selling: Int64;
}
export const Liabilities: XdrCodec<Liabilities> = xdrStruct<Liabilities>([
  ['buying', Int64],
  ['selling', Int64],
]);

export type SponsorshipDescriptor = AccountID | undefined;
export const SponsorshipDescriptor: XdrCodec<SponsorshipDescriptor> = option(AccountID);

export interface AccountEntryExtensionV3 {
  readonly ext: ExtensionPoint;
  readonly seqLedger: Uint32;
  readonly seqTime: TimePoint;
}
export const AccountEntryExtensionV3: XdrCodec<AccountEntryExtensionV3> = xdrStruct<AccountEntryExtensionV3>([
  ['ext', ExtensionPoint],
  ['seqLedger', Uint32],
  ['seqTime', TimePoint],
]);

export type AccountEntryExtensionV2Ext =
  | { readonly tag: 0 }
  | { readonly tag: 3; readonly value: AccountEntryExtensionV3 }
;

export const AccountEntryExtensionV2Ext: XdrCodec<AccountEntryExtensionV2Ext> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [3], codec: AccountEntryExtensionV3 },
  ],
}) as XdrCodec<AccountEntryExtensionV2Ext>;

export interface AccountEntryExtensionV2 {
  readonly numSponsored: Uint32;
  readonly numSponsoring: Uint32;
  readonly signerSponsoringIDs: readonly SponsorshipDescriptor[];
  readonly ext: AccountEntryExtensionV2Ext;
}
export const AccountEntryExtensionV2: XdrCodec<AccountEntryExtensionV2> = xdrStruct<AccountEntryExtensionV2>([
  ['numSponsored', Uint32],
  ['numSponsoring', Uint32],
  ['signerSponsoringIDs', varArray(MAX_SIGNERS, SponsorshipDescriptor)],
  ['ext', AccountEntryExtensionV2Ext],
]);

export type AccountEntryExtensionV1Ext =
  | { readonly tag: 0 }
  | { readonly tag: 2; readonly value: AccountEntryExtensionV2 }
;

export const AccountEntryExtensionV1Ext: XdrCodec<AccountEntryExtensionV1Ext> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [2], codec: AccountEntryExtensionV2 },
  ],
}) as XdrCodec<AccountEntryExtensionV1Ext>;

export interface AccountEntryExtensionV1 {
  readonly liabilities: Liabilities;
  readonly ext: AccountEntryExtensionV1Ext;
}
export const AccountEntryExtensionV1: XdrCodec<AccountEntryExtensionV1> = xdrStruct<AccountEntryExtensionV1>([
  ['liabilities', Liabilities],
  ['ext', AccountEntryExtensionV1Ext],
]);

export type AccountEntryExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: AccountEntryExtensionV1 }
;

export const AccountEntryExt: XdrCodec<AccountEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: AccountEntryExtensionV1 },
  ],
}) as XdrCodec<AccountEntryExt>;

export interface AccountEntry {
  readonly accountID: AccountID;
  readonly balance: Int64;
  readonly seqNum: SequenceNumber;
  readonly numSubEntries: Uint32;
  readonly inflationDest: AccountID | undefined;
  readonly flags: Uint32;
  readonly homeDomain: String32;
  readonly thresholds: Thresholds;
  readonly signers: readonly Signer[];
  readonly ext: AccountEntryExt;
}
export const AccountEntry: XdrCodec<AccountEntry> = xdrStruct<AccountEntry>([
  ['accountID', AccountID],
  ['balance', Int64],
  ['seqNum', SequenceNumber],
  ['numSubEntries', Uint32],
  ['inflationDest', option(AccountID)],
  ['flags', Uint32],
  ['homeDomain', String32],
  ['thresholds', Thresholds],
  ['signers', varArray(MAX_SIGNERS, Signer)],
  ['ext', AccountEntryExt],
]);

export type TrustLineEntryExtensionV2Ext =
  | { readonly tag: 0 }
;

export const TrustLineEntryExtensionV2Ext: XdrCodec<TrustLineEntryExtensionV2Ext> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<TrustLineEntryExtensionV2Ext>;

export interface TrustLineEntryExtensionV2 {
  readonly liquidityPoolUseCount: Int32;
  readonly ext: TrustLineEntryExtensionV2Ext;
}
export const TrustLineEntryExtensionV2: XdrCodec<TrustLineEntryExtensionV2> = xdrStruct<TrustLineEntryExtensionV2>([
  ['liquidityPoolUseCount', Int32],
  ['ext', TrustLineEntryExtensionV2Ext],
]);

export type TrustLineEntryV1Ext =
  | { readonly tag: 0 }
  | { readonly tag: 2; readonly value: TrustLineEntryExtensionV2 }
;

export const TrustLineEntryV1Ext: XdrCodec<TrustLineEntryV1Ext> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [2], codec: TrustLineEntryExtensionV2 },
  ],
}) as XdrCodec<TrustLineEntryV1Ext>;

export interface TrustLineEntryV1 {
  readonly liabilities: Liabilities;
  readonly ext: TrustLineEntryV1Ext;
}
export const TrustLineEntryV1: XdrCodec<TrustLineEntryV1> = xdrStruct<TrustLineEntryV1>([
  ['liabilities', Liabilities],
  ['ext', TrustLineEntryV1Ext],
]);

export type TrustLineEntryExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: TrustLineEntryV1 }
;

export const TrustLineEntryExt: XdrCodec<TrustLineEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: TrustLineEntryV1 },
  ],
}) as XdrCodec<TrustLineEntryExt>;

export interface TrustLineEntry {
  readonly accountID: AccountID;
  readonly asset: TrustLineAsset;
  readonly balance: Int64;
  readonly limit: Int64;
  readonly flags: Uint32;
  readonly ext: TrustLineEntryExt;
}
export const TrustLineEntry: XdrCodec<TrustLineEntry> = xdrStruct<TrustLineEntry>([
  ['accountID', AccountID],
  ['asset', TrustLineAsset],
  ['balance', Int64],
  ['limit', Int64],
  ['flags', Uint32],
  ['ext', TrustLineEntryExt],
]);

export type DataEntryExt =
  | { readonly tag: 0 }
;

export const DataEntryExt: XdrCodec<DataEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<DataEntryExt>;

export interface DataEntry {
  readonly accountID: AccountID;
  readonly dataName: String64;
  readonly dataValue: DataValue;
  readonly ext: DataEntryExt;
}
export const DataEntry: XdrCodec<DataEntry> = xdrStruct<DataEntry>([
  ['accountID', AccountID],
  ['dataName', String64],
  ['dataValue', DataValue],
  ['ext', DataEntryExt],
]);

export type ClaimableBalanceEntryExtensionV1Ext =
  | { readonly tag: 0 }
;

export const ClaimableBalanceEntryExtensionV1Ext: XdrCodec<ClaimableBalanceEntryExtensionV1Ext> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<ClaimableBalanceEntryExtensionV1Ext>;

export interface ClaimableBalanceEntryExtensionV1 {
  readonly ext: ClaimableBalanceEntryExtensionV1Ext;
  readonly flags: Uint32;
}
export const ClaimableBalanceEntryExtensionV1: XdrCodec<ClaimableBalanceEntryExtensionV1> = xdrStruct<ClaimableBalanceEntryExtensionV1>([
  ['ext', ClaimableBalanceEntryExtensionV1Ext],
  ['flags', Uint32],
]);

export type ClaimableBalanceEntryExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: ClaimableBalanceEntryExtensionV1 }
;

export const ClaimableBalanceEntryExt: XdrCodec<ClaimableBalanceEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: ClaimableBalanceEntryExtensionV1 },
  ],
}) as XdrCodec<ClaimableBalanceEntryExt>;

export interface ClaimableBalanceEntry {
  readonly balanceID: ClaimableBalanceID;
  readonly claimants: readonly Claimant[];
  readonly asset: Asset;
  readonly amount: Int64;
  readonly ext: ClaimableBalanceEntryExt;
}
export const ClaimableBalanceEntry: XdrCodec<ClaimableBalanceEntry> = xdrStruct<ClaimableBalanceEntry>([
  ['balanceID', ClaimableBalanceID],
  ['claimants', varArray(10, Claimant)],
  ['asset', Asset],
  ['amount', Int64],
  ['ext', ClaimableBalanceEntryExt],
]);

export interface LiquidityPoolEntryConstantProduct {
  readonly params: LiquidityPoolConstantProductParameters;
  readonly reserveA: Int64;
  readonly reserveB: Int64;
  readonly totalPoolShares: Int64;
  readonly poolSharesTrustLineCount: Int64;
}
export const LiquidityPoolEntryConstantProduct: XdrCodec<LiquidityPoolEntryConstantProduct> = xdrStruct<LiquidityPoolEntryConstantProduct>([
  ['params', LiquidityPoolConstantProductParameters],
  ['reserveA', Int64],
  ['reserveB', Int64],
  ['totalPoolShares', Int64],
  ['poolSharesTrustLineCount', Int64],
]);

export type LiquidityPoolEntryBody =
  | { readonly tag: 'LiquidityPoolConstantProduct'; readonly value: LiquidityPoolEntryConstantProduct }
;

export const LiquidityPoolEntryBody: XdrCodec<LiquidityPoolEntryBody> = taggedUnion({
  switchOn: LiquidityPoolType,
  arms: [
    { tags: ['LiquidityPoolConstantProduct'], codec: LiquidityPoolEntryConstantProduct },
  ],
}) as XdrCodec<LiquidityPoolEntryBody>;

export interface LiquidityPoolEntry {
  readonly liquidityPoolID: PoolID;
  readonly body: LiquidityPoolEntryBody;
}
export const LiquidityPoolEntry: XdrCodec<LiquidityPoolEntry> = xdrStruct<LiquidityPoolEntry>([
  ['liquidityPoolID', PoolID],
  ['body', LiquidityPoolEntryBody],
]);

export interface ContractDataEntry {
  readonly ext: ExtensionPoint;
  readonly contract: SCAddress;
  readonly key: SCVal;
  readonly durability: ContractDataDurability;
  readonly val: SCVal;
}
export const ContractDataEntry: XdrCodec<ContractDataEntry> = xdrStruct<ContractDataEntry>([
  ['ext', ExtensionPoint],
  ['contract', SCAddress],
  ['key', lazy(() => SCVal)],
  ['durability', ContractDataDurability],
  ['val', lazy(() => SCVal)],
]);

export interface ContractCodeCostInputs {
  readonly ext: ExtensionPoint;
  readonly nInstructions: Uint32;
  readonly nFunctions: Uint32;
  readonly nGlobals: Uint32;
  readonly nTableEntries: Uint32;
  readonly nTypes: Uint32;
  readonly nDataSegments: Uint32;
  readonly nElemSegments: Uint32;
  readonly nImports: Uint32;
  readonly nExports: Uint32;
  readonly nDataSegmentBytes: Uint32;
}
export const ContractCodeCostInputs: XdrCodec<ContractCodeCostInputs> = xdrStruct<ContractCodeCostInputs>([
  ['ext', ExtensionPoint],
  ['nInstructions', Uint32],
  ['nFunctions', Uint32],
  ['nGlobals', Uint32],
  ['nTableEntries', Uint32],
  ['nTypes', Uint32],
  ['nDataSegments', Uint32],
  ['nElemSegments', Uint32],
  ['nImports', Uint32],
  ['nExports', Uint32],
  ['nDataSegmentBytes', Uint32],
]);

export interface ContractCodeEntryV1 {
  readonly ext: ExtensionPoint;
  readonly costInputs: ContractCodeCostInputs;
}
export const ContractCodeEntryV1: XdrCodec<ContractCodeEntryV1> = xdrStruct<ContractCodeEntryV1>([
  ['ext', ExtensionPoint],
  ['costInputs', ContractCodeCostInputs],
]);

export type ContractCodeEntryExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: ContractCodeEntryV1 }
;

export const ContractCodeEntryExt: XdrCodec<ContractCodeEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: ContractCodeEntryV1 },
  ],
}) as XdrCodec<ContractCodeEntryExt>;

export interface ContractCodeEntry {
  readonly ext: ContractCodeEntryExt;
  readonly hash: Hash;
  readonly code: Uint8Array;
}
export const ContractCodeEntry: XdrCodec<ContractCodeEntry> = xdrStruct<ContractCodeEntry>([
  ['ext', ContractCodeEntryExt],
  ['hash', Hash],
  ['code', varOpaque(2147483647)],
]);

export interface TTLEntry {
  readonly keyHash: Hash;
  readonly liveUntilLedgerSeq: Uint32;
}
export const TTLEntry: XdrCodec<TTLEntry> = xdrStruct<TTLEntry>([
  ['keyHash', Hash],
  ['liveUntilLedgerSeq', Uint32],
]);

export type LedgerEntryData =
  | { readonly tag: 'Account'; readonly value: AccountEntry }
  | { readonly tag: 'Trustline'; readonly value: TrustLineEntry }
  | { readonly tag: 'Offer'; readonly value: OfferEntry }
  | { readonly tag: 'Data'; readonly value: DataEntry }
  | { readonly tag: 'ClaimableBalance'; readonly value: ClaimableBalanceEntry }
  | { readonly tag: 'LiquidityPool'; readonly value: LiquidityPoolEntry }
  | { readonly tag: 'ContractData'; readonly value: ContractDataEntry }
  | { readonly tag: 'ContractCode'; readonly value: ContractCodeEntry }
  | { readonly tag: 'ConfigSetting'; readonly value: ConfigSettingEntry }
  | { readonly tag: 'Ttl'; readonly value: TTLEntry }
;

export const LedgerEntryData: XdrCodec<LedgerEntryData> = taggedUnion({
  switchOn: LedgerEntryType,
  arms: [
    { tags: ['Account'], codec: AccountEntry },
    { tags: ['Trustline'], codec: TrustLineEntry },
    { tags: ['Offer'], codec: OfferEntry },
    { tags: ['Data'], codec: DataEntry },
    { tags: ['ClaimableBalance'], codec: ClaimableBalanceEntry },
    { tags: ['LiquidityPool'], codec: LiquidityPoolEntry },
    { tags: ['ContractData'], codec: ContractDataEntry },
    { tags: ['ContractCode'], codec: ContractCodeEntry },
    { tags: ['ConfigSetting'], codec: ConfigSettingEntry },
    { tags: ['Ttl'], codec: TTLEntry },
  ],
}) as XdrCodec<LedgerEntryData>;

export type LedgerEntryExtensionV1Ext =
  | { readonly tag: 0 }
;

export const LedgerEntryExtensionV1Ext: XdrCodec<LedgerEntryExtensionV1Ext> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<LedgerEntryExtensionV1Ext>;

export interface LedgerEntryExtensionV1 {
  readonly sponsoringID: SponsorshipDescriptor;
  readonly ext: LedgerEntryExtensionV1Ext;
}
export const LedgerEntryExtensionV1: XdrCodec<LedgerEntryExtensionV1> = xdrStruct<LedgerEntryExtensionV1>([
  ['sponsoringID', SponsorshipDescriptor],
  ['ext', LedgerEntryExtensionV1Ext],
]);

export type LedgerEntryExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: LedgerEntryExtensionV1 }
;

export const LedgerEntryExt: XdrCodec<LedgerEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: LedgerEntryExtensionV1 },
  ],
}) as XdrCodec<LedgerEntryExt>;

export interface LedgerEntry {
  readonly lastModifiedLedgerSeq: Uint32;
  readonly data: LedgerEntryData;
  readonly ext: LedgerEntryExt;
}
export const LedgerEntry: XdrCodec<LedgerEntry> = xdrStruct<LedgerEntry>([
  ['lastModifiedLedgerSeq', Uint32],
  ['data', LedgerEntryData],
  ['ext', LedgerEntryExt],
]);

export type LedgerEntryChange =
  | { readonly tag: 'Created'; readonly value: LedgerEntry }
  | { readonly tag: 'Updated'; readonly value: LedgerEntry }
  | { readonly tag: 'Removed'; readonly value: LedgerKey }
  | { readonly tag: 'State'; readonly value: LedgerEntry }
  | { readonly tag: 'Restored'; readonly value: LedgerEntry }
;

export const LedgerEntryChange: XdrCodec<LedgerEntryChange> = taggedUnion({
  switchOn: LedgerEntryChangeType,
  arms: [
    { tags: ['Created'], codec: LedgerEntry },
    { tags: ['Updated'], codec: LedgerEntry },
    { tags: ['Removed'], codec: LedgerKey },
    { tags: ['State'], codec: LedgerEntry },
    { tags: ['Restored'], codec: LedgerEntry },
  ],
}) as XdrCodec<LedgerEntryChange>;

export type LedgerEntryChanges = readonly LedgerEntryChange[];
export const LedgerEntryChanges: XdrCodec<LedgerEntryChanges> = varArray(2147483647, LedgerEntryChange);

export interface OperationMeta {
  readonly changes: LedgerEntryChanges;
}
export const OperationMeta: XdrCodec<OperationMeta> = xdrStruct<OperationMeta>([
  ['changes', LedgerEntryChanges],
]);

export interface TransactionMetaV1 {
  readonly txChanges: LedgerEntryChanges;
  readonly operations: readonly OperationMeta[];
}
export const TransactionMetaV1: XdrCodec<TransactionMetaV1> = xdrStruct<TransactionMetaV1>([
  ['txChanges', LedgerEntryChanges],
  ['operations', varArray(2147483647, OperationMeta)],
]);

export interface TransactionMetaV2 {
  readonly txChangesBefore: LedgerEntryChanges;
  readonly operations: readonly OperationMeta[];
  readonly txChangesAfter: LedgerEntryChanges;
}
export const TransactionMetaV2: XdrCodec<TransactionMetaV2> = xdrStruct<TransactionMetaV2>([
  ['txChangesBefore', LedgerEntryChanges],
  ['operations', varArray(2147483647, OperationMeta)],
  ['txChangesAfter', LedgerEntryChanges],
]);

export interface SorobanTransactionMetaExtV1 {
  readonly ext: ExtensionPoint;
  readonly totalNonRefundableResourceFeeCharged: Int64;
  readonly totalRefundableResourceFeeCharged: Int64;
  readonly rentFeeCharged: Int64;
}
export const SorobanTransactionMetaExtV1: XdrCodec<SorobanTransactionMetaExtV1> = xdrStruct<SorobanTransactionMetaExtV1>([
  ['ext', ExtensionPoint],
  ['totalNonRefundableResourceFeeCharged', Int64],
  ['totalRefundableResourceFeeCharged', Int64],
  ['rentFeeCharged', Int64],
]);

export type SorobanTransactionMetaExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: SorobanTransactionMetaExtV1 }
;

export const SorobanTransactionMetaExt: XdrCodec<SorobanTransactionMetaExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: SorobanTransactionMetaExtV1 },
  ],
}) as XdrCodec<SorobanTransactionMetaExt>;

export type ContractEventType = 'System' | 'Contract' | 'Diagnostic';
export const ContractEventType = xdrEnum({
  System: 0,
  Contract: 1,
  Diagnostic: 2,
});

export interface ContractEventV0 {
  readonly topics: readonly SCVal[];
  readonly data: SCVal;
}
export const ContractEventV0: XdrCodec<ContractEventV0> = xdrStruct<ContractEventV0>([
  ['topics', varArray(2147483647, lazy(() => SCVal))],
  ['data', lazy(() => SCVal)],
]);

export type ContractEventBody =
  | { readonly tag: 0; readonly value: ContractEventV0 }
;

export const ContractEventBody: XdrCodec<ContractEventBody> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0], codec: ContractEventV0 },
  ],
}) as XdrCodec<ContractEventBody>;

export interface ContractEvent {
  readonly ext: ExtensionPoint;
  readonly contractID: ContractID | undefined;
  readonly type: ContractEventType;
  readonly body: ContractEventBody;
}
export const ContractEvent: XdrCodec<ContractEvent> = xdrStruct<ContractEvent>([
  ['ext', ExtensionPoint],
  ['contractID', option(ContractID)],
  ['type', ContractEventType],
  ['body', ContractEventBody],
]);

export interface DiagnosticEvent {
  readonly inSuccessfulContractCall: boolean;
  readonly event: ContractEvent;
}
export const DiagnosticEvent: XdrCodec<DiagnosticEvent> = xdrStruct<DiagnosticEvent>([
  ['inSuccessfulContractCall', bool],
  ['event', ContractEvent],
]);

export interface SorobanTransactionMeta {
  readonly ext: SorobanTransactionMetaExt;
  readonly events: readonly ContractEvent[];
  readonly returnValue: SCVal;
  readonly diagnosticEvents: readonly DiagnosticEvent[];
}
export const SorobanTransactionMeta: XdrCodec<SorobanTransactionMeta> = xdrStruct<SorobanTransactionMeta>([
  ['ext', SorobanTransactionMetaExt],
  ['events', varArray(2147483647, ContractEvent)],
  ['returnValue', lazy(() => SCVal)],
  ['diagnosticEvents', varArray(2147483647, DiagnosticEvent)],
]);

export interface TransactionMetaV3 {
  readonly ext: ExtensionPoint;
  readonly txChangesBefore: LedgerEntryChanges;
  readonly operations: readonly OperationMeta[];
  readonly txChangesAfter: LedgerEntryChanges;
  readonly sorobanMeta: SorobanTransactionMeta | undefined;
}
export const TransactionMetaV3: XdrCodec<TransactionMetaV3> = xdrStruct<TransactionMetaV3>([
  ['ext', ExtensionPoint],
  ['txChangesBefore', LedgerEntryChanges],
  ['operations', varArray(2147483647, OperationMeta)],
  ['txChangesAfter', LedgerEntryChanges],
  ['sorobanMeta', option(SorobanTransactionMeta)],
]);

export interface OperationMetaV2 {
  readonly ext: ExtensionPoint;
  readonly changes: LedgerEntryChanges;
  readonly events: readonly ContractEvent[];
}
export const OperationMetaV2: XdrCodec<OperationMetaV2> = xdrStruct<OperationMetaV2>([
  ['ext', ExtensionPoint],
  ['changes', LedgerEntryChanges],
  ['events', varArray(2147483647, ContractEvent)],
]);

export interface SorobanTransactionMetaV2 {
  readonly ext: SorobanTransactionMetaExt;
  readonly returnValue: SCVal | undefined;
}
export const SorobanTransactionMetaV2: XdrCodec<SorobanTransactionMetaV2> = xdrStruct<SorobanTransactionMetaV2>([
  ['ext', SorobanTransactionMetaExt],
  ['returnValue', option(lazy(() => SCVal))],
]);

export type TransactionEventStage = 'BeforeAllTxs' | 'AfterTx' | 'AfterAllTxs';
export const TransactionEventStage = xdrEnum({
  BeforeAllTxs: 0,
  AfterTx: 1,
  AfterAllTxs: 2,
});

export interface TransactionEvent {
  readonly stage: TransactionEventStage;
  readonly event: ContractEvent;
}
export const TransactionEvent: XdrCodec<TransactionEvent> = xdrStruct<TransactionEvent>([
  ['stage', TransactionEventStage],
  ['event', ContractEvent],
]);

export interface TransactionMetaV4 {
  readonly ext: ExtensionPoint;
  readonly txChangesBefore: LedgerEntryChanges;
  readonly operations: readonly OperationMetaV2[];
  readonly txChangesAfter: LedgerEntryChanges;
  readonly sorobanMeta: SorobanTransactionMetaV2 | undefined;
  readonly events: readonly TransactionEvent[];
  readonly diagnosticEvents: readonly DiagnosticEvent[];
}
export const TransactionMetaV4: XdrCodec<TransactionMetaV4> = xdrStruct<TransactionMetaV4>([
  ['ext', ExtensionPoint],
  ['txChangesBefore', LedgerEntryChanges],
  ['operations', varArray(2147483647, OperationMetaV2)],
  ['txChangesAfter', LedgerEntryChanges],
  ['sorobanMeta', option(SorobanTransactionMetaV2)],
  ['events', varArray(2147483647, TransactionEvent)],
  ['diagnosticEvents', varArray(2147483647, DiagnosticEvent)],
]);

export type TransactionMeta =
  | { readonly tag: 0; readonly value: readonly OperationMeta[] }
  | { readonly tag: 1; readonly value: TransactionMetaV1 }
  | { readonly tag: 2; readonly value: TransactionMetaV2 }
  | { readonly tag: 3; readonly value: TransactionMetaV3 }
  | { readonly tag: 4; readonly value: TransactionMetaV4 }
;

export const TransactionMeta: XdrCodec<TransactionMeta> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0], codec: varArray(2147483647, OperationMeta) },
    { tags: [1], codec: TransactionMetaV1 },
    { tags: [2], codec: TransactionMetaV2 },
    { tags: [3], codec: TransactionMetaV3 },
    { tags: [4], codec: TransactionMetaV4 },
  ],
}) as XdrCodec<TransactionMeta>;

export interface TransactionResultMeta {
  readonly result: TransactionResultPair;
  readonly feeProcessing: LedgerEntryChanges;
  readonly txApplyProcessing: TransactionMeta;
}
export const TransactionResultMeta: XdrCodec<TransactionResultMeta> = xdrStruct<TransactionResultMeta>([
  ['result', TransactionResultPair],
  ['feeProcessing', LedgerEntryChanges],
  ['txApplyProcessing', TransactionMeta],
]);

export type LedgerUpgradeType = 'Version' | 'BaseFee' | 'MaxTxSetSize' | 'BaseReserve' | 'Flags' | 'Config' | 'MaxSorobanTxSetSize';
export const LedgerUpgradeType = xdrEnum({
  Version: 1,
  BaseFee: 2,
  MaxTxSetSize: 3,
  BaseReserve: 4,
  Flags: 5,
  Config: 6,
  MaxSorobanTxSetSize: 7,
});

export interface ConfigUpgradeSetKey {
  readonly contractID: ContractID;
  readonly contentHash: Hash;
}
export const ConfigUpgradeSetKey: XdrCodec<ConfigUpgradeSetKey> = xdrStruct<ConfigUpgradeSetKey>([
  ['contractID', ContractID],
  ['contentHash', Hash],
]);

export type LedgerUpgrade =
  | { readonly tag: 'Version'; readonly value: Uint32 }
  | { readonly tag: 'BaseFee'; readonly value: Uint32 }
  | { readonly tag: 'MaxTxSetSize'; readonly value: Uint32 }
  | { readonly tag: 'BaseReserve'; readonly value: Uint32 }
  | { readonly tag: 'Flags'; readonly value: Uint32 }
  | { readonly tag: 'Config'; readonly value: ConfigUpgradeSetKey }
  | { readonly tag: 'MaxSorobanTxSetSize'; readonly value: Uint32 }
;

export const LedgerUpgrade: XdrCodec<LedgerUpgrade> = taggedUnion({
  switchOn: LedgerUpgradeType,
  arms: [
    { tags: ['Version'], codec: Uint32 },
    { tags: ['BaseFee'], codec: Uint32 },
    { tags: ['MaxTxSetSize'], codec: Uint32 },
    { tags: ['BaseReserve'], codec: Uint32 },
    { tags: ['Flags'], codec: Uint32 },
    { tags: ['Config'], codec: ConfigUpgradeSetKey },
    { tags: ['MaxSorobanTxSetSize'], codec: Uint32 },
  ],
}) as XdrCodec<LedgerUpgrade>;

export interface UpgradeEntryMeta {
  readonly upgrade: LedgerUpgrade;
  readonly changes: LedgerEntryChanges;
}
export const UpgradeEntryMeta: XdrCodec<UpgradeEntryMeta> = xdrStruct<UpgradeEntryMeta>([
  ['upgrade', LedgerUpgrade],
  ['changes', LedgerEntryChanges],
]);

export interface SCPQuorumSet {
  readonly threshold: Uint32;
  readonly validators: readonly NodeID[];
  readonly innerSets: readonly SCPQuorumSet[];
}
export const SCPQuorumSet: XdrCodec<SCPQuorumSet> = xdrStruct<SCPQuorumSet>([
  ['threshold', Uint32],
  ['validators', varArray(2147483647, NodeID)],
  ['innerSets', varArray(2147483647, lazy(() => SCPQuorumSet))],
]);

export type SCPStatementType = 'Prepare' | 'Confirm' | 'Externalize' | 'Nominate';
export const SCPStatementType = xdrEnum({
  Prepare: 0,
  Confirm: 1,
  Externalize: 2,
  Nominate: 3,
});

export type Value = Uint8Array;
export const Value: XdrCodec<Value> = varOpaque(2147483647);

export interface SCPBallot {
  readonly counter: Uint32;
  readonly value: Value;
}
export const SCPBallot: XdrCodec<SCPBallot> = xdrStruct<SCPBallot>([
  ['counter', Uint32],
  ['value', Value],
]);

export interface SCPStatementPrepare {
  readonly quorumSetHash: Hash;
  readonly ballot: SCPBallot;
  readonly prepared: SCPBallot | undefined;
  readonly preparedPrime: SCPBallot | undefined;
  readonly nC: Uint32;
  readonly nH: Uint32;
}
export const SCPStatementPrepare: XdrCodec<SCPStatementPrepare> = xdrStruct<SCPStatementPrepare>([
  ['quorumSetHash', Hash],
  ['ballot', SCPBallot],
  ['prepared', option(SCPBallot)],
  ['preparedPrime', option(SCPBallot)],
  ['nC', Uint32],
  ['nH', Uint32],
]);

export interface SCPStatementConfirm {
  readonly ballot: SCPBallot;
  readonly nPrepared: Uint32;
  readonly nCommit: Uint32;
  readonly nH: Uint32;
  readonly quorumSetHash: Hash;
}
export const SCPStatementConfirm: XdrCodec<SCPStatementConfirm> = xdrStruct<SCPStatementConfirm>([
  ['ballot', SCPBallot],
  ['nPrepared', Uint32],
  ['nCommit', Uint32],
  ['nH', Uint32],
  ['quorumSetHash', Hash],
]);

export interface SCPStatementExternalize {
  readonly commit: SCPBallot;
  readonly nH: Uint32;
  readonly commitQuorumSetHash: Hash;
}
export const SCPStatementExternalize: XdrCodec<SCPStatementExternalize> = xdrStruct<SCPStatementExternalize>([
  ['commit', SCPBallot],
  ['nH', Uint32],
  ['commitQuorumSetHash', Hash],
]);

export interface SCPNomination {
  readonly quorumSetHash: Hash;
  readonly votes: readonly Value[];
  readonly accepted: readonly Value[];
}
export const SCPNomination: XdrCodec<SCPNomination> = xdrStruct<SCPNomination>([
  ['quorumSetHash', Hash],
  ['votes', varArray(2147483647, Value)],
  ['accepted', varArray(2147483647, Value)],
]);

export type SCPStatementPledges =
  | { readonly tag: 'Prepare'; readonly value: SCPStatementPrepare }
  | { readonly tag: 'Confirm'; readonly value: SCPStatementConfirm }
  | { readonly tag: 'Externalize'; readonly value: SCPStatementExternalize }
  | { readonly tag: 'Nominate'; readonly value: SCPNomination }
;

export const SCPStatementPledges: XdrCodec<SCPStatementPledges> = taggedUnion({
  switchOn: SCPStatementType,
  arms: [
    { tags: ['Prepare'], codec: SCPStatementPrepare },
    { tags: ['Confirm'], codec: SCPStatementConfirm },
    { tags: ['Externalize'], codec: SCPStatementExternalize },
    { tags: ['Nominate'], codec: SCPNomination },
  ],
}) as XdrCodec<SCPStatementPledges>;

export interface SCPStatement {
  readonly nodeID: NodeID;
  readonly slotIndex: Uint64;
  readonly pledges: SCPStatementPledges;
}
export const SCPStatement: XdrCodec<SCPStatement> = xdrStruct<SCPStatement>([
  ['nodeID', NodeID],
  ['slotIndex', Uint64],
  ['pledges', SCPStatementPledges],
]);

export interface SCPEnvelope {
  readonly statement: SCPStatement;
  readonly signature: Signature;
}
export const SCPEnvelope: XdrCodec<SCPEnvelope> = xdrStruct<SCPEnvelope>([
  ['statement', SCPStatement],
  ['signature', Signature],
]);

export interface LedgerSCPMessages {
  readonly ledgerSeq: Uint32;
  readonly messages: readonly SCPEnvelope[];
}
export const LedgerSCPMessages: XdrCodec<LedgerSCPMessages> = xdrStruct<LedgerSCPMessages>([
  ['ledgerSeq', Uint32],
  ['messages', varArray(2147483647, SCPEnvelope)],
]);

export interface SCPHistoryEntryV0 {
  readonly quorumSets: readonly SCPQuorumSet[];
  readonly ledgerMessages: LedgerSCPMessages;
}
export const SCPHistoryEntryV0: XdrCodec<SCPHistoryEntryV0> = xdrStruct<SCPHistoryEntryV0>([
  ['quorumSets', varArray(2147483647, lazy(() => SCPQuorumSet))],
  ['ledgerMessages', LedgerSCPMessages],
]);

export type SCPHistoryEntry =
  | { readonly tag: 0; readonly value: SCPHistoryEntryV0 }
;

export const SCPHistoryEntry: XdrCodec<SCPHistoryEntry> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0], codec: SCPHistoryEntryV0 },
  ],
}) as XdrCodec<SCPHistoryEntry>;

export interface LedgerCloseMetaV0 {
  readonly ledgerHeader: LedgerHeaderHistoryEntry;
  readonly txSet: TransactionSet;
  readonly txProcessing: readonly TransactionResultMeta[];
  readonly upgradesProcessing: readonly UpgradeEntryMeta[];
  readonly scpInfo: readonly SCPHistoryEntry[];
}
export const LedgerCloseMetaV0: XdrCodec<LedgerCloseMetaV0> = xdrStruct<LedgerCloseMetaV0>([
  ['ledgerHeader', LedgerHeaderHistoryEntry],
  ['txSet', TransactionSet],
  ['txProcessing', varArray(2147483647, TransactionResultMeta)],
  ['upgradesProcessing', varArray(2147483647, UpgradeEntryMeta)],
  ['scpInfo', varArray(2147483647, SCPHistoryEntry)],
]);

export interface LedgerCloseMetaExtV1 {
  readonly ext: ExtensionPoint;
  readonly sorobanFeeWrite1KB: Int64;
}
export const LedgerCloseMetaExtV1: XdrCodec<LedgerCloseMetaExtV1> = xdrStruct<LedgerCloseMetaExtV1>([
  ['ext', ExtensionPoint],
  ['sorobanFeeWrite1KB', Int64],
]);

export type LedgerCloseMetaExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: LedgerCloseMetaExtV1 }
;

export const LedgerCloseMetaExt: XdrCodec<LedgerCloseMetaExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: LedgerCloseMetaExtV1 },
  ],
}) as XdrCodec<LedgerCloseMetaExt>;

export type TxSetComponentType = 'TxsetCompTxsMaybeDiscountedFee';
export const TxSetComponentType = xdrEnum({
  TxsetCompTxsMaybeDiscountedFee: 0,
});

export interface TxSetComponentTxsMaybeDiscountedFee {
  readonly baseFee: Int64 | undefined;
  readonly txs: readonly TransactionEnvelope[];
}
export const TxSetComponentTxsMaybeDiscountedFee: XdrCodec<TxSetComponentTxsMaybeDiscountedFee> = xdrStruct<TxSetComponentTxsMaybeDiscountedFee>([
  ['baseFee', option(Int64)],
  ['txs', varArray(2147483647, TransactionEnvelope)],
]);

export type TxSetComponent =
  | { readonly tag: 'TxsetCompTxsMaybeDiscountedFee'; readonly value: TxSetComponentTxsMaybeDiscountedFee }
;

export const TxSetComponent: XdrCodec<TxSetComponent> = taggedUnion({
  switchOn: TxSetComponentType,
  arms: [
    { tags: ['TxsetCompTxsMaybeDiscountedFee'], codec: TxSetComponentTxsMaybeDiscountedFee },
  ],
}) as XdrCodec<TxSetComponent>;

export type DependentTxCluster = readonly TransactionEnvelope[];
export const DependentTxCluster: XdrCodec<DependentTxCluster> = varArray(2147483647, TransactionEnvelope);

export type ParallelTxExecutionStage = readonly DependentTxCluster[];
export const ParallelTxExecutionStage: XdrCodec<ParallelTxExecutionStage> = varArray(2147483647, DependentTxCluster);

export interface ParallelTxsComponent {
  readonly baseFee: Int64 | undefined;
  readonly executionStages: readonly ParallelTxExecutionStage[];
}
export const ParallelTxsComponent: XdrCodec<ParallelTxsComponent> = xdrStruct<ParallelTxsComponent>([
  ['baseFee', option(Int64)],
  ['executionStages', varArray(2147483647, ParallelTxExecutionStage)],
]);

export type TransactionPhase =
  | { readonly tag: 0; readonly value: readonly TxSetComponent[] }
  | { readonly tag: 1; readonly value: ParallelTxsComponent }
;

export const TransactionPhase: XdrCodec<TransactionPhase> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0], codec: varArray(2147483647, TxSetComponent) },
    { tags: [1], codec: ParallelTxsComponent },
  ],
}) as XdrCodec<TransactionPhase>;

export interface TransactionSetV1 {
  readonly previousLedgerHash: Hash;
  readonly phases: readonly TransactionPhase[];
}
export const TransactionSetV1: XdrCodec<TransactionSetV1> = xdrStruct<TransactionSetV1>([
  ['previousLedgerHash', Hash],
  ['phases', varArray(2147483647, TransactionPhase)],
]);

export type GeneralizedTransactionSet =
  | { readonly tag: 1; readonly value: TransactionSetV1 }
;

export const GeneralizedTransactionSet: XdrCodec<GeneralizedTransactionSet> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [1], codec: TransactionSetV1 },
  ],
}) as XdrCodec<GeneralizedTransactionSet>;

export interface LedgerCloseMetaV1 {
  readonly ext: LedgerCloseMetaExt;
  readonly ledgerHeader: LedgerHeaderHistoryEntry;
  readonly txSet: GeneralizedTransactionSet;
  readonly txProcessing: readonly TransactionResultMeta[];
  readonly upgradesProcessing: readonly UpgradeEntryMeta[];
  readonly scpInfo: readonly SCPHistoryEntry[];
  readonly totalByteSizeOfLiveSorobanState: Uint64;
  readonly evictedKeys: readonly LedgerKey[];
  readonly unused: readonly LedgerEntry[];
}
export const LedgerCloseMetaV1: XdrCodec<LedgerCloseMetaV1> = xdrStruct<LedgerCloseMetaV1>([
  ['ext', LedgerCloseMetaExt],
  ['ledgerHeader', LedgerHeaderHistoryEntry],
  ['txSet', GeneralizedTransactionSet],
  ['txProcessing', varArray(2147483647, TransactionResultMeta)],
  ['upgradesProcessing', varArray(2147483647, UpgradeEntryMeta)],
  ['scpInfo', varArray(2147483647, SCPHistoryEntry)],
  ['totalByteSizeOfLiveSorobanState', Uint64],
  ['evictedKeys', varArray(2147483647, LedgerKey)],
  ['unused', varArray(2147483647, LedgerEntry)],
]);

export interface TransactionResultMetaV1 {
  readonly ext: ExtensionPoint;
  readonly result: TransactionResultPair;
  readonly feeProcessing: LedgerEntryChanges;
  readonly txApplyProcessing: TransactionMeta;
  readonly postTxApplyFeeProcessing: LedgerEntryChanges;
}
export const TransactionResultMetaV1: XdrCodec<TransactionResultMetaV1> = xdrStruct<TransactionResultMetaV1>([
  ['ext', ExtensionPoint],
  ['result', TransactionResultPair],
  ['feeProcessing', LedgerEntryChanges],
  ['txApplyProcessing', TransactionMeta],
  ['postTxApplyFeeProcessing', LedgerEntryChanges],
]);

export interface LedgerCloseMetaV2 {
  readonly ext: LedgerCloseMetaExt;
  readonly ledgerHeader: LedgerHeaderHistoryEntry;
  readonly txSet: GeneralizedTransactionSet;
  readonly txProcessing: readonly TransactionResultMetaV1[];
  readonly upgradesProcessing: readonly UpgradeEntryMeta[];
  readonly scpInfo: readonly SCPHistoryEntry[];
  readonly totalByteSizeOfLiveSorobanState: Uint64;
  readonly evictedKeys: readonly LedgerKey[];
}
export const LedgerCloseMetaV2: XdrCodec<LedgerCloseMetaV2> = xdrStruct<LedgerCloseMetaV2>([
  ['ext', LedgerCloseMetaExt],
  ['ledgerHeader', LedgerHeaderHistoryEntry],
  ['txSet', GeneralizedTransactionSet],
  ['txProcessing', varArray(2147483647, TransactionResultMetaV1)],
  ['upgradesProcessing', varArray(2147483647, UpgradeEntryMeta)],
  ['scpInfo', varArray(2147483647, SCPHistoryEntry)],
  ['totalByteSizeOfLiveSorobanState', Uint64],
  ['evictedKeys', varArray(2147483647, LedgerKey)],
]);

export type LedgerCloseMeta =
  | { readonly tag: 0; readonly value: LedgerCloseMetaV0 }
  | { readonly tag: 1; readonly value: LedgerCloseMetaV1 }
  | { readonly tag: 2; readonly value: LedgerCloseMetaV2 }
;

export const LedgerCloseMeta: XdrCodec<LedgerCloseMeta> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0], codec: LedgerCloseMetaV0 },
    { tags: [1], codec: LedgerCloseMetaV1 },
    { tags: [2], codec: LedgerCloseMetaV2 },
  ],
}) as XdrCodec<LedgerCloseMeta>;

export interface LedgerCloseMetaBatch {
  readonly startSequence: Uint32;
  readonly endSequence: Uint32;
  readonly ledgerCloseMetas: readonly LedgerCloseMeta[];
}
export const LedgerCloseMetaBatch: XdrCodec<LedgerCloseMetaBatch> = xdrStruct<LedgerCloseMetaBatch>([
  ['startSequence', Uint32],
  ['endSequence', Uint32],
  ['ledgerCloseMetas', varArray(2147483647, LedgerCloseMeta)],
]);

export type StoredTransactionSet =
  | { readonly tag: 0; readonly value: TransactionSet }
  | { readonly tag: 1; readonly value: GeneralizedTransactionSet }
;

export const StoredTransactionSet: XdrCodec<StoredTransactionSet> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0], codec: TransactionSet },
    { tags: [1], codec: GeneralizedTransactionSet },
  ],
}) as XdrCodec<StoredTransactionSet>;

export interface StoredDebugTransactionSet {
  readonly txSet: StoredTransactionSet;
  readonly ledgerSeq: Uint32;
  readonly scpValue: StellarValue;
}
export const StoredDebugTransactionSet: XdrCodec<StoredDebugTransactionSet> = xdrStruct<StoredDebugTransactionSet>([
  ['txSet', StoredTransactionSet],
  ['ledgerSeq', Uint32],
  ['scpValue', StellarValue],
]);

export interface PersistedSCPStateV0 {
  readonly scpEnvelopes: readonly SCPEnvelope[];
  readonly quorumSets: readonly SCPQuorumSet[];
  readonly txSets: readonly StoredTransactionSet[];
}
export const PersistedSCPStateV0: XdrCodec<PersistedSCPStateV0> = xdrStruct<PersistedSCPStateV0>([
  ['scpEnvelopes', varArray(2147483647, SCPEnvelope)],
  ['quorumSets', varArray(2147483647, lazy(() => SCPQuorumSet))],
  ['txSets', varArray(2147483647, StoredTransactionSet)],
]);

export interface PersistedSCPStateV1 {
  readonly scpEnvelopes: readonly SCPEnvelope[];
  readonly quorumSets: readonly SCPQuorumSet[];
}
export const PersistedSCPStateV1: XdrCodec<PersistedSCPStateV1> = xdrStruct<PersistedSCPStateV1>([
  ['scpEnvelopes', varArray(2147483647, SCPEnvelope)],
  ['quorumSets', varArray(2147483647, lazy(() => SCPQuorumSet))],
]);

export type PersistedSCPState =
  | { readonly tag: 0; readonly value: PersistedSCPStateV0 }
  | { readonly tag: 1; readonly value: PersistedSCPStateV1 }
;

export const PersistedSCPState: XdrCodec<PersistedSCPState> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0], codec: PersistedSCPStateV0 },
    { tags: [1], codec: PersistedSCPStateV1 },
  ],
}) as XdrCodec<PersistedSCPState>;

export type ThresholdIndexes = 'MasterWeight' | 'Low' | 'Med' | 'High';
export const ThresholdIndexes = xdrEnum({
  MasterWeight: 0,
  Low: 1,
  Med: 2,
  High: 3,
});

export type AccountFlags = 'RequiredFlag' | 'RevocableFlag' | 'ImmutableFlag' | 'ClawbackEnabledFlag';
export const AccountFlags = xdrEnum({
  RequiredFlag: 1,
  RevocableFlag: 2,
  ImmutableFlag: 4,
  ClawbackEnabledFlag: 8,
});

export const MASK_ACCOUNT_FLAGS = 0x7;

export const MASK_ACCOUNT_FLAGS_V17 = 0xF;

export type TrustLineFlags = 'AuthorizedFlag' | 'AuthorizedToMaintainLiabilitiesFlag' | 'TrustlineClawbackEnabledFlag';
export const TrustLineFlags = xdrEnum({
  AuthorizedFlag: 1,
  AuthorizedToMaintainLiabilitiesFlag: 2,
  TrustlineClawbackEnabledFlag: 4,
});

export const MASK_TRUSTLINE_FLAGS = 1;

export const MASK_TRUSTLINE_FLAGS_V13 = 3;

export const MASK_TRUSTLINE_FLAGS_V17 = 7;

export type OfferEntryFlags = 'PassiveFlag';
export const OfferEntryFlags = xdrEnum({
  PassiveFlag: 1,
});

export const MASK_OFFERENTRY_FLAGS = 1;

export type ClaimableBalanceFlags = 'ClaimableBalanceClawbackEnabledFlag';
export const ClaimableBalanceFlags = xdrEnum({
  ClaimableBalanceClawbackEnabledFlag: 1,
});

export const MASK_CLAIMABLE_BALANCE_FLAGS = 0x1;

export type BucketListType = 'Live' | 'HotArchive';
export const BucketListType = xdrEnum({
  Live: 0,
  HotArchive: 1,
});

export type BucketEntryType = 'Metaentry' | 'Liveentry' | 'Deadentry' | 'Initentry';
export const BucketEntryType = xdrEnum({
  Metaentry: -1,
  Liveentry: 0,
  Deadentry: 1,
  Initentry: 2,
});

export type HotArchiveBucketEntryType = 'Metaentry' | 'Archived' | 'Live';
export const HotArchiveBucketEntryType = xdrEnum({
  Metaentry: -1,
  Archived: 0,
  Live: 1,
});

export type BucketMetadataExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: BucketListType }
;

export const BucketMetadataExt: XdrCodec<BucketMetadataExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: BucketListType },
  ],
}) as XdrCodec<BucketMetadataExt>;

export interface BucketMetadata {
  readonly ledgerVersion: Uint32;
  readonly ext: BucketMetadataExt;
}
export const BucketMetadata: XdrCodec<BucketMetadata> = xdrStruct<BucketMetadata>([
  ['ledgerVersion', Uint32],
  ['ext', BucketMetadataExt],
]);

export type BucketEntry =
  | { readonly tag: 'Liveentry'; readonly value: LedgerEntry }
  | { readonly tag: 'Initentry'; readonly value: LedgerEntry }
  | { readonly tag: 'Deadentry'; readonly value: LedgerKey }
  | { readonly tag: 'Metaentry'; readonly value: BucketMetadata }
;

export const BucketEntry: XdrCodec<BucketEntry> = taggedUnion({
  switchOn: BucketEntryType,
  arms: [
    { tags: ['Liveentry', 'Initentry'], codec: LedgerEntry },
    { tags: ['Deadentry'], codec: LedgerKey },
    { tags: ['Metaentry'], codec: BucketMetadata },
  ],
}) as XdrCodec<BucketEntry>;

export type HotArchiveBucketEntry =
  | { readonly tag: 'Archived'; readonly value: LedgerEntry }
  | { readonly tag: 'Live'; readonly value: LedgerKey }
  | { readonly tag: 'Metaentry'; readonly value: BucketMetadata }
;

export const HotArchiveBucketEntry: XdrCodec<HotArchiveBucketEntry> = taggedUnion({
  switchOn: HotArchiveBucketEntryType,
  arms: [
    { tags: ['Archived'], codec: LedgerEntry },
    { tags: ['Live'], codec: LedgerKey },
    { tags: ['Metaentry'], codec: BucketMetadata },
  ],
}) as XdrCodec<HotArchiveBucketEntry>;

export const MASK_LEDGER_HEADER_FLAGS = 0x7;

export type LedgerHeaderFlags = 'TradingFlag' | 'DepositFlag' | 'WithdrawalFlag';
export const LedgerHeaderFlags = xdrEnum({
  TradingFlag: 1,
  DepositFlag: 2,
  WithdrawalFlag: 4,
});

export interface ConfigUpgradeSet {
  readonly updatedEntry: readonly ConfigSettingEntry[];
}
export const ConfigUpgradeSet: XdrCodec<ConfigUpgradeSet> = xdrStruct<ConfigUpgradeSet>([
  ['updatedEntry', varArray(2147483647, ConfigSettingEntry)],
]);

export interface TransactionResultSet {
  readonly results: readonly TransactionResultPair[];
}
export const TransactionResultSet: XdrCodec<TransactionResultSet> = xdrStruct<TransactionResultSet>([
  ['results', varArray(2147483647, TransactionResultPair)],
]);

export type TransactionHistoryEntryExt =
  | { readonly tag: 0 }
  | { readonly tag: 1; readonly value: GeneralizedTransactionSet }
;

export const TransactionHistoryEntryExt: XdrCodec<TransactionHistoryEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
    { tags: [1], codec: GeneralizedTransactionSet },
  ],
}) as XdrCodec<TransactionHistoryEntryExt>;

export interface TransactionHistoryEntry {
  readonly ledgerSeq: Uint32;
  readonly txSet: TransactionSet;
  readonly ext: TransactionHistoryEntryExt;
}
export const TransactionHistoryEntry: XdrCodec<TransactionHistoryEntry> = xdrStruct<TransactionHistoryEntry>([
  ['ledgerSeq', Uint32],
  ['txSet', TransactionSet],
  ['ext', TransactionHistoryEntryExt],
]);

export type TransactionHistoryResultEntryExt =
  | { readonly tag: 0 }
;

export const TransactionHistoryResultEntryExt: XdrCodec<TransactionHistoryResultEntryExt> = taggedUnion({
  switchOn: int32,
  arms: [
    { tags: [0] },
  ],
}) as XdrCodec<TransactionHistoryResultEntryExt>;

export interface TransactionHistoryResultEntry {
  readonly ledgerSeq: Uint32;
  readonly txResultSet: TransactionResultSet;
  readonly ext: TransactionHistoryResultEntryExt;
}
export const TransactionHistoryResultEntry: XdrCodec<TransactionHistoryResultEntry> = xdrStruct<TransactionHistoryResultEntry>([
  ['ledgerSeq', Uint32],
  ['txResultSet', TransactionResultSet],
  ['ext', TransactionHistoryResultEntryExt],
]);

export interface InvokeHostFunctionSuccessPreImage {
  readonly returnValue: SCVal;
  readonly events: readonly ContractEvent[];
}
export const InvokeHostFunctionSuccessPreImage: XdrCodec<InvokeHostFunctionSuccessPreImage> = xdrStruct<InvokeHostFunctionSuccessPreImage>([
  ['returnValue', lazy(() => SCVal)],
  ['events', varArray(2147483647, ContractEvent)],
]);

export type ErrorCode = 'Misc' | 'Data' | 'Conf' | 'Auth' | 'Load';
export const ErrorCode = xdrEnum({
  Misc: 0,
  Data: 1,
  Conf: 2,
  Auth: 3,
  Load: 4,
});

export interface Error {
  readonly code: ErrorCode;
  readonly msg: string;
}
export const Error: XdrCodec<Error> = xdrStruct<Error>([
  ['code', ErrorCode],
  ['msg', xdrString(100)],
]);

export interface SendMore {
  readonly numMessages: Uint32;
}
export const SendMore: XdrCodec<SendMore> = xdrStruct<SendMore>([
  ['numMessages', Uint32],
]);

export interface SendMoreExtended {
  readonly numMessages: Uint32;
  readonly numBytes: Uint32;
}
export const SendMoreExtended: XdrCodec<SendMoreExtended> = xdrStruct<SendMoreExtended>([
  ['numMessages', Uint32],
  ['numBytes', Uint32],
]);

export interface Curve25519Public {
  readonly key: Uint8Array;
}
export const Curve25519Public: XdrCodec<Curve25519Public> = xdrStruct<Curve25519Public>([
  ['key', fixedOpaque(32)],
]);

export interface AuthCert {
  readonly pubkey: Curve25519Public;
  readonly expiration: Uint64;
  readonly sig: Signature;
}
export const AuthCert: XdrCodec<AuthCert> = xdrStruct<AuthCert>([
  ['pubkey', Curve25519Public],
  ['expiration', Uint64],
  ['sig', Signature],
]);

export interface Hello {
  readonly ledgerVersion: Uint32;
  readonly overlayVersion: Uint32;
  readonly overlayMinVersion: Uint32;
  readonly networkID: Hash;
  readonly versionStr: string;
  readonly listeningPort: number;
  readonly peerID: NodeID;
  readonly cert: AuthCert;
  readonly nonce: Uint256;
}
export const Hello: XdrCodec<Hello> = xdrStruct<Hello>([
  ['ledgerVersion', Uint32],
  ['overlayVersion', Uint32],
  ['overlayMinVersion', Uint32],
  ['networkID', Hash],
  ['versionStr', xdrString(100)],
  ['listeningPort', int32],
  ['peerID', NodeID],
  ['cert', AuthCert],
  ['nonce', Uint256],
]);

export const AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED = 200;

export interface Auth {
  readonly flags: number;
}
export const Auth: XdrCodec<Auth> = xdrStruct<Auth>([
  ['flags', int32],
]);

export type IPAddrType = 'IPv4' | 'IPv6';
export const IPAddrType = xdrEnum({
  IPv4: 0,
  IPv6: 1,
});

export type PeerAddressIp =
  | { readonly tag: 'IPv4'; readonly value: Uint8Array }
  | { readonly tag: 'IPv6'; readonly value: Uint8Array }
;

export const PeerAddressIp: XdrCodec<PeerAddressIp> = taggedUnion({
  switchOn: IPAddrType,
  arms: [
    { tags: ['IPv4'], codec: fixedOpaque(4) },
    { tags: ['IPv6'], codec: fixedOpaque(16) },
  ],
}) as XdrCodec<PeerAddressIp>;

export interface PeerAddress {
  readonly ip: PeerAddressIp;
  readonly port: Uint32;
  readonly numFailures: Uint32;
}
export const PeerAddress: XdrCodec<PeerAddress> = xdrStruct<PeerAddress>([
  ['ip', PeerAddressIp],
  ['port', Uint32],
  ['numFailures', Uint32],
]);

export type MessageType = 'ErrorMsg' | 'Auth' | 'DontHave' | 'Peers' | 'GetTxSet' | 'TxSet' | 'GeneralizedTxSet' | 'Transaction' | 'GetScpQuorumset' | 'ScpQuorumset' | 'ScpMessage' | 'GetScpState' | 'Hello' | 'SendMore' | 'SendMoreExtended' | 'FloodAdvert' | 'FloodDemand' | 'TimeSlicedSurveyRequest' | 'TimeSlicedSurveyResponse' | 'TimeSlicedSurveyStartCollecting' | 'TimeSlicedSurveyStopCollecting';
export const MessageType = xdrEnum({
  ErrorMsg: 0,
  Auth: 2,
  DontHave: 3,
  Peers: 5,
  GetTxSet: 6,
  TxSet: 7,
  GeneralizedTxSet: 17,
  Transaction: 8,
  GetScpQuorumset: 9,
  ScpQuorumset: 10,
  ScpMessage: 11,
  GetScpState: 12,
  Hello: 13,
  SendMore: 16,
  SendMoreExtended: 20,
  FloodAdvert: 18,
  FloodDemand: 19,
  TimeSlicedSurveyRequest: 21,
  TimeSlicedSurveyResponse: 22,
  TimeSlicedSurveyStartCollecting: 23,
  TimeSlicedSurveyStopCollecting: 24,
});

export interface DontHave {
  readonly type: MessageType;
  readonly reqHash: Uint256;
}
export const DontHave: XdrCodec<DontHave> = xdrStruct<DontHave>([
  ['type', MessageType],
  ['reqHash', Uint256],
]);

export type SurveyMessageCommandType = 'TimeSlicedSurveyTopology';
export const SurveyMessageCommandType = xdrEnum({
  TimeSlicedSurveyTopology: 1,
});

export type SurveyMessageResponseType = 'SurveyTopologyResponseV2';
export const SurveyMessageResponseType = xdrEnum({
  SurveyTopologyResponseV2: 2,
});

export interface TimeSlicedSurveyStartCollectingMessage {
  readonly surveyorID: NodeID;
  readonly nonce: Uint32;
  readonly ledgerNum: Uint32;
}
export const TimeSlicedSurveyStartCollectingMessage: XdrCodec<TimeSlicedSurveyStartCollectingMessage> = xdrStruct<TimeSlicedSurveyStartCollectingMessage>([
  ['surveyorID', NodeID],
  ['nonce', Uint32],
  ['ledgerNum', Uint32],
]);

export interface SignedTimeSlicedSurveyStartCollectingMessage {
  readonly signature: Signature;
  readonly startCollecting: TimeSlicedSurveyStartCollectingMessage;
}
export const SignedTimeSlicedSurveyStartCollectingMessage: XdrCodec<SignedTimeSlicedSurveyStartCollectingMessage> = xdrStruct<SignedTimeSlicedSurveyStartCollectingMessage>([
  ['signature', Signature],
  ['startCollecting', TimeSlicedSurveyStartCollectingMessage],
]);

export interface TimeSlicedSurveyStopCollectingMessage {
  readonly surveyorID: NodeID;
  readonly nonce: Uint32;
  readonly ledgerNum: Uint32;
}
export const TimeSlicedSurveyStopCollectingMessage: XdrCodec<TimeSlicedSurveyStopCollectingMessage> = xdrStruct<TimeSlicedSurveyStopCollectingMessage>([
  ['surveyorID', NodeID],
  ['nonce', Uint32],
  ['ledgerNum', Uint32],
]);

export interface SignedTimeSlicedSurveyStopCollectingMessage {
  readonly signature: Signature;
  readonly stopCollecting: TimeSlicedSurveyStopCollectingMessage;
}
export const SignedTimeSlicedSurveyStopCollectingMessage: XdrCodec<SignedTimeSlicedSurveyStopCollectingMessage> = xdrStruct<SignedTimeSlicedSurveyStopCollectingMessage>([
  ['signature', Signature],
  ['stopCollecting', TimeSlicedSurveyStopCollectingMessage],
]);

export interface SurveyRequestMessage {
  readonly surveyorPeerID: NodeID;
  readonly surveyedPeerID: NodeID;
  readonly ledgerNum: Uint32;
  readonly encryptionKey: Curve25519Public;
  readonly commandType: SurveyMessageCommandType;
}
export const SurveyRequestMessage: XdrCodec<SurveyRequestMessage> = xdrStruct<SurveyRequestMessage>([
  ['surveyorPeerID', NodeID],
  ['surveyedPeerID', NodeID],
  ['ledgerNum', Uint32],
  ['encryptionKey', Curve25519Public],
  ['commandType', SurveyMessageCommandType],
]);

export interface TimeSlicedSurveyRequestMessage {
  readonly request: SurveyRequestMessage;
  readonly nonce: Uint32;
  readonly inboundPeersIndex: Uint32;
  readonly outboundPeersIndex: Uint32;
}
export const TimeSlicedSurveyRequestMessage: XdrCodec<TimeSlicedSurveyRequestMessage> = xdrStruct<TimeSlicedSurveyRequestMessage>([
  ['request', SurveyRequestMessage],
  ['nonce', Uint32],
  ['inboundPeersIndex', Uint32],
  ['outboundPeersIndex', Uint32],
]);

export interface SignedTimeSlicedSurveyRequestMessage {
  readonly requestSignature: Signature;
  readonly request: TimeSlicedSurveyRequestMessage;
}
export const SignedTimeSlicedSurveyRequestMessage: XdrCodec<SignedTimeSlicedSurveyRequestMessage> = xdrStruct<SignedTimeSlicedSurveyRequestMessage>([
  ['requestSignature', Signature],
  ['request', TimeSlicedSurveyRequestMessage],
]);

export type EncryptedBody = Uint8Array;
export const EncryptedBody: XdrCodec<EncryptedBody> = varOpaque(64000);

export interface SurveyResponseMessage {
  readonly surveyorPeerID: NodeID;
  readonly surveyedPeerID: NodeID;
  readonly ledgerNum: Uint32;
  readonly commandType: SurveyMessageCommandType;
  readonly encryptedBody: EncryptedBody;
}
export const SurveyResponseMessage: XdrCodec<SurveyResponseMessage> = xdrStruct<SurveyResponseMessage>([
  ['surveyorPeerID', NodeID],
  ['surveyedPeerID', NodeID],
  ['ledgerNum', Uint32],
  ['commandType', SurveyMessageCommandType],
  ['encryptedBody', EncryptedBody],
]);

export interface TimeSlicedSurveyResponseMessage {
  readonly response: SurveyResponseMessage;
  readonly nonce: Uint32;
}
export const TimeSlicedSurveyResponseMessage: XdrCodec<TimeSlicedSurveyResponseMessage> = xdrStruct<TimeSlicedSurveyResponseMessage>([
  ['response', SurveyResponseMessage],
  ['nonce', Uint32],
]);

export interface SignedTimeSlicedSurveyResponseMessage {
  readonly responseSignature: Signature;
  readonly response: TimeSlicedSurveyResponseMessage;
}
export const SignedTimeSlicedSurveyResponseMessage: XdrCodec<SignedTimeSlicedSurveyResponseMessage> = xdrStruct<SignedTimeSlicedSurveyResponseMessage>([
  ['responseSignature', Signature],
  ['response', TimeSlicedSurveyResponseMessage],
]);

export interface PeerStats {
  readonly id: NodeID;
  readonly versionStr: string;
  readonly messagesRead: Uint64;
  readonly messagesWritten: Uint64;
  readonly bytesRead: Uint64;
  readonly bytesWritten: Uint64;
  readonly secondsConnected: Uint64;
  readonly uniqueFloodBytesRecv: Uint64;
  readonly duplicateFloodBytesRecv: Uint64;
  readonly uniqueFetchBytesRecv: Uint64;
  readonly duplicateFetchBytesRecv: Uint64;
  readonly uniqueFloodMessageRecv: Uint64;
  readonly duplicateFloodMessageRecv: Uint64;
  readonly uniqueFetchMessageRecv: Uint64;
  readonly duplicateFetchMessageRecv: Uint64;
}
export const PeerStats: XdrCodec<PeerStats> = xdrStruct<PeerStats>([
  ['id', NodeID],
  ['versionStr', xdrString(100)],
  ['messagesRead', Uint64],
  ['messagesWritten', Uint64],
  ['bytesRead', Uint64],
  ['bytesWritten', Uint64],
  ['secondsConnected', Uint64],
  ['uniqueFloodBytesRecv', Uint64],
  ['duplicateFloodBytesRecv', Uint64],
  ['uniqueFetchBytesRecv', Uint64],
  ['duplicateFetchBytesRecv', Uint64],
  ['uniqueFloodMessageRecv', Uint64],
  ['duplicateFloodMessageRecv', Uint64],
  ['uniqueFetchMessageRecv', Uint64],
  ['duplicateFetchMessageRecv', Uint64],
]);

export interface TimeSlicedNodeData {
  readonly addedAuthenticatedPeers: Uint32;
  readonly droppedAuthenticatedPeers: Uint32;
  readonly totalInboundPeerCount: Uint32;
  readonly totalOutboundPeerCount: Uint32;
  readonly p75SCPFirstToSelfLatencyMs: Uint32;
  readonly p75SCPSelfToOtherLatencyMs: Uint32;
  readonly lostSyncCount: Uint32;
  readonly isValidator: boolean;
  readonly maxInboundPeerCount: Uint32;
  readonly maxOutboundPeerCount: Uint32;
}
export const TimeSlicedNodeData: XdrCodec<TimeSlicedNodeData> = xdrStruct<TimeSlicedNodeData>([
  ['addedAuthenticatedPeers', Uint32],
  ['droppedAuthenticatedPeers', Uint32],
  ['totalInboundPeerCount', Uint32],
  ['totalOutboundPeerCount', Uint32],
  ['p75SCPFirstToSelfLatencyMs', Uint32],
  ['p75SCPSelfToOtherLatencyMs', Uint32],
  ['lostSyncCount', Uint32],
  ['isValidator', bool],
  ['maxInboundPeerCount', Uint32],
  ['maxOutboundPeerCount', Uint32],
]);

export interface TimeSlicedPeerData {
  readonly peerStats: PeerStats;
  readonly averageLatencyMs: Uint32;
}
export const TimeSlicedPeerData: XdrCodec<TimeSlicedPeerData> = xdrStruct<TimeSlicedPeerData>([
  ['peerStats', PeerStats],
  ['averageLatencyMs', Uint32],
]);

export type TimeSlicedPeerDataList = readonly TimeSlicedPeerData[];
export const TimeSlicedPeerDataList: XdrCodec<TimeSlicedPeerDataList> = varArray(25, TimeSlicedPeerData);

export interface TopologyResponseBodyV2 {
  readonly inboundPeers: TimeSlicedPeerDataList;
  readonly outboundPeers: TimeSlicedPeerDataList;
  readonly nodeData: TimeSlicedNodeData;
}
export const TopologyResponseBodyV2: XdrCodec<TopologyResponseBodyV2> = xdrStruct<TopologyResponseBodyV2>([
  ['inboundPeers', TimeSlicedPeerDataList],
  ['outboundPeers', TimeSlicedPeerDataList],
  ['nodeData', TimeSlicedNodeData],
]);

export type SurveyResponseBody =
  | { readonly tag: 'SurveyTopologyResponseV2'; readonly value: TopologyResponseBodyV2 }
;

export const SurveyResponseBody: XdrCodec<SurveyResponseBody> = taggedUnion({
  switchOn: SurveyMessageResponseType,
  arms: [
    { tags: ['SurveyTopologyResponseV2'], codec: TopologyResponseBodyV2 },
  ],
}) as XdrCodec<SurveyResponseBody>;

export const TX_ADVERT_VECTOR_MAX_SIZE = 1000;

export type TxAdvertVector = readonly Hash[];
export const TxAdvertVector: XdrCodec<TxAdvertVector> = varArray(TX_ADVERT_VECTOR_MAX_SIZE, Hash);

export interface FloodAdvert {
  readonly txHashes: TxAdvertVector;
}
export const FloodAdvert: XdrCodec<FloodAdvert> = xdrStruct<FloodAdvert>([
  ['txHashes', TxAdvertVector],
]);

export const TX_DEMAND_VECTOR_MAX_SIZE = 1000;

export type TxDemandVector = readonly Hash[];
export const TxDemandVector: XdrCodec<TxDemandVector> = varArray(TX_DEMAND_VECTOR_MAX_SIZE, Hash);

export interface FloodDemand {
  readonly txHashes: TxDemandVector;
}
export const FloodDemand: XdrCodec<FloodDemand> = xdrStruct<FloodDemand>([
  ['txHashes', TxDemandVector],
]);

export type StellarMessage =
  | { readonly tag: 'ErrorMsg'; readonly value: Error }
  | { readonly tag: 'Hello'; readonly value: Hello }
  | { readonly tag: 'Auth'; readonly value: Auth }
  | { readonly tag: 'DontHave'; readonly value: DontHave }
  | { readonly tag: 'Peers'; readonly value: readonly PeerAddress[] }
  | { readonly tag: 'GetTxSet'; readonly value: Uint256 }
  | { readonly tag: 'TxSet'; readonly value: TransactionSet }
  | { readonly tag: 'GeneralizedTxSet'; readonly value: GeneralizedTransactionSet }
  | { readonly tag: 'Transaction'; readonly value: TransactionEnvelope }
  | { readonly tag: 'TimeSlicedSurveyRequest'; readonly value: SignedTimeSlicedSurveyRequestMessage }
  | { readonly tag: 'TimeSlicedSurveyResponse'; readonly value: SignedTimeSlicedSurveyResponseMessage }
  | { readonly tag: 'TimeSlicedSurveyStartCollecting'; readonly value: SignedTimeSlicedSurveyStartCollectingMessage }
  | { readonly tag: 'TimeSlicedSurveyStopCollecting'; readonly value: SignedTimeSlicedSurveyStopCollectingMessage }
  | { readonly tag: 'GetScpQuorumset'; readonly value: Uint256 }
  | { readonly tag: 'ScpQuorumset'; readonly value: SCPQuorumSet }
  | { readonly tag: 'ScpMessage'; readonly value: SCPEnvelope }
  | { readonly tag: 'GetScpState'; readonly value: Uint32 }
  | { readonly tag: 'SendMore'; readonly value: SendMore }
  | { readonly tag: 'SendMoreExtended'; readonly value: SendMoreExtended }
  | { readonly tag: 'FloodAdvert'; readonly value: FloodAdvert }
  | { readonly tag: 'FloodDemand'; readonly value: FloodDemand }
;

export const StellarMessage: XdrCodec<StellarMessage> = taggedUnion({
  switchOn: MessageType,
  arms: [
    { tags: ['ErrorMsg'], codec: Error },
    { tags: ['Hello'], codec: Hello },
    { tags: ['Auth'], codec: Auth },
    { tags: ['DontHave'], codec: DontHave },
    { tags: ['Peers'], codec: varArray(100, PeerAddress) },
    { tags: ['GetTxSet'], codec: Uint256 },
    { tags: ['TxSet'], codec: TransactionSet },
    { tags: ['GeneralizedTxSet'], codec: GeneralizedTransactionSet },
    { tags: ['Transaction'], codec: TransactionEnvelope },
    { tags: ['TimeSlicedSurveyRequest'], codec: SignedTimeSlicedSurveyRequestMessage },
    { tags: ['TimeSlicedSurveyResponse'], codec: SignedTimeSlicedSurveyResponseMessage },
    { tags: ['TimeSlicedSurveyStartCollecting'], codec: SignedTimeSlicedSurveyStartCollectingMessage },
    { tags: ['TimeSlicedSurveyStopCollecting'], codec: SignedTimeSlicedSurveyStopCollectingMessage },
    { tags: ['GetScpQuorumset'], codec: Uint256 },
    { tags: ['ScpQuorumset'], codec: lazy(() => SCPQuorumSet) },
    { tags: ['ScpMessage'], codec: SCPEnvelope },
    { tags: ['GetScpState'], codec: Uint32 },
    { tags: ['SendMore'], codec: SendMore },
    { tags: ['SendMoreExtended'], codec: SendMoreExtended },
    { tags: ['FloodAdvert'], codec: FloodAdvert },
    { tags: ['FloodDemand'], codec: FloodDemand },
  ],
}) as XdrCodec<StellarMessage>;

export interface HmacSha256Mac {
  readonly mac: Uint8Array;
}
export const HmacSha256Mac: XdrCodec<HmacSha256Mac> = xdrStruct<HmacSha256Mac>([
  ['mac', fixedOpaque(32)],
]);

export interface AuthenticatedMessageV0 {
  readonly sequence: Uint64;
  readonly message: StellarMessage;
  readonly mac: HmacSha256Mac;
}
export const AuthenticatedMessageV0: XdrCodec<AuthenticatedMessageV0> = xdrStruct<AuthenticatedMessageV0>([
  ['sequence', Uint64],
  ['message', StellarMessage],
  ['mac', HmacSha256Mac],
]);

export type AuthenticatedMessage =
  | { readonly tag: 0; readonly value: AuthenticatedMessageV0 }
;

export const AuthenticatedMessage: XdrCodec<AuthenticatedMessage> = taggedUnion({
  switchOn: Uint32,
  arms: [
    { tags: [0], codec: AuthenticatedMessageV0 },
  ],
}) as XdrCodec<AuthenticatedMessage>;

export const LIQUIDITY_POOL_FEE_V18 = 30;

export type SorobanAuthorizationEntries = readonly SorobanAuthorizationEntry[];
export const SorobanAuthorizationEntries: XdrCodec<SorobanAuthorizationEntries> = varArray(2147483647, SorobanAuthorizationEntry);

export interface HashIDPreimageOperationID {
  readonly sourceAccount: AccountID;
  readonly seqNum: SequenceNumber;
  readonly opNum: Uint32;
}
export const HashIDPreimageOperationID: XdrCodec<HashIDPreimageOperationID> = xdrStruct<HashIDPreimageOperationID>([
  ['sourceAccount', AccountID],
  ['seqNum', SequenceNumber],
  ['opNum', Uint32],
]);

export interface HashIDPreimageRevokeID {
  readonly sourceAccount: AccountID;
  readonly seqNum: SequenceNumber;
  readonly opNum: Uint32;
  readonly liquidityPoolID: PoolID;
  readonly asset: Asset;
}
export const HashIDPreimageRevokeID: XdrCodec<HashIDPreimageRevokeID> = xdrStruct<HashIDPreimageRevokeID>([
  ['sourceAccount', AccountID],
  ['seqNum', SequenceNumber],
  ['opNum', Uint32],
  ['liquidityPoolID', PoolID],
  ['asset', Asset],
]);

export interface HashIDPreimageContractID {
  readonly networkID: Hash;
  readonly contractIDPreimage: ContractIDPreimage;
}
export const HashIDPreimageContractID: XdrCodec<HashIDPreimageContractID> = xdrStruct<HashIDPreimageContractID>([
  ['networkID', Hash],
  ['contractIDPreimage', ContractIDPreimage],
]);

export interface HashIDPreimageSorobanAuthorization {
  readonly networkID: Hash;
  readonly nonce: Int64;
  readonly signatureExpirationLedger: Uint32;
  readonly invocation: SorobanAuthorizedInvocation;
}
export const HashIDPreimageSorobanAuthorization: XdrCodec<HashIDPreimageSorobanAuthorization> = xdrStruct<HashIDPreimageSorobanAuthorization>([
  ['networkID', Hash],
  ['nonce', Int64],
  ['signatureExpirationLedger', Uint32],
  ['invocation', lazy(() => SorobanAuthorizedInvocation)],
]);

export type HashIDPreimage =
  | { readonly tag: 'OpId'; readonly value: HashIDPreimageOperationID }
  | { readonly tag: 'PoolRevokeOpId'; readonly value: HashIDPreimageRevokeID }
  | { readonly tag: 'ContractId'; readonly value: HashIDPreimageContractID }
  | { readonly tag: 'SorobanAuthorization'; readonly value: HashIDPreimageSorobanAuthorization }
;

export const HashIDPreimage: XdrCodec<HashIDPreimage> = taggedUnion({
  switchOn: EnvelopeType,
  arms: [
    { tags: ['OpId'], codec: HashIDPreimageOperationID },
    { tags: ['PoolRevokeOpId'], codec: HashIDPreimageRevokeID },
    { tags: ['ContractId'], codec: HashIDPreimageContractID },
    { tags: ['SorobanAuthorization'], codec: HashIDPreimageSorobanAuthorization },
  ],
}) as XdrCodec<HashIDPreimage>;

export type TransactionSignaturePayloadTaggedTransaction =
  | { readonly tag: 'Tx'; readonly value: Transaction }
  | { readonly tag: 'TxFeeBump'; readonly value: FeeBumpTransaction }
;

export const TransactionSignaturePayloadTaggedTransaction: XdrCodec<TransactionSignaturePayloadTaggedTransaction> = taggedUnion({
  switchOn: EnvelopeType,
  arms: [
    { tags: ['Tx'], codec: Transaction },
    { tags: ['TxFeeBump'], codec: FeeBumpTransaction },
  ],
}) as XdrCodec<TransactionSignaturePayloadTaggedTransaction>;

export interface TransactionSignaturePayload {
  readonly networkId: Hash;
  readonly taggedTransaction: TransactionSignaturePayloadTaggedTransaction;
}
export const TransactionSignaturePayload: XdrCodec<TransactionSignaturePayload> = xdrStruct<TransactionSignaturePayload>([
  ['networkId', Hash],
  ['taggedTransaction', TransactionSignaturePayloadTaggedTransaction],
]);

export interface Curve25519Secret {
  readonly key: Uint8Array;
}
export const Curve25519Secret: XdrCodec<Curve25519Secret> = xdrStruct<Curve25519Secret>([
  ['key', fixedOpaque(32)],
]);

export interface HmacSha256Key {
  readonly key: Uint8Array;
}
export const HmacSha256Key: XdrCodec<HmacSha256Key> = xdrStruct<HmacSha256Key>([
  ['key', fixedOpaque(32)],
]);

export interface ShortHashSeed {
  readonly seed: Uint8Array;
}
export const ShortHashSeed: XdrCodec<ShortHashSeed> = xdrStruct<ShortHashSeed>([
  ['seed', fixedOpaque(16)],
]);

export type BinaryFuseFilterType = 'B8Bit' | 'B16Bit' | 'B32Bit';
export const BinaryFuseFilterType = xdrEnum({
  B8Bit: 0,
  B16Bit: 1,
  B32Bit: 2,
});

export interface SerializedBinaryFuseFilter {
  readonly type: BinaryFuseFilterType;
  readonly inputHashSeed: ShortHashSeed;
  readonly filterSeed: ShortHashSeed;
  readonly segmentLength: Uint32;
  readonly segementLengthMask: Uint32;
  readonly segmentCount: Uint32;
  readonly segmentCountLength: Uint32;
  readonly fingerprintLength: Uint32;
  readonly fingerprints: Uint8Array;
}
export const SerializedBinaryFuseFilter: XdrCodec<SerializedBinaryFuseFilter> = xdrStruct<SerializedBinaryFuseFilter>([
  ['type', BinaryFuseFilterType],
  ['inputHashSeed', ShortHashSeed],
  ['filterSeed', ShortHashSeed],
  ['segmentLength', Uint32],
  ['segementLengthMask', Uint32],
  ['segmentCount', Uint32],
  ['segmentCountLength', Uint32],
  ['fingerprintLength', Uint32],
  ['fingerprints', varOpaque(2147483647)],
]);

