// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

import * as modern from '@stellar/xdr';
import {
  createCompatStruct,
  createCompatEnum,
  createCompatUnion,
  createCompatTypedef,
  identity,
  hyperConverter,
  unsignedHyperConverter,
  optionConverter,
  arrayConverter,
  lazyConverter,
  type Converter,
  Hyper,
  UnsignedHyper,
} from '../xdr-compat/index.js';

const id = identity<any>();
const int64Conv = hyperConverter();
const uint64Conv = unsignedHyperConverter();

function structConverter(C: any): Converter<any, any> {
  return { toCompat: (m: any) => C._fromModern(m), toModern: (c: any) => c._toModern() };
}
function enumConverter(C: any): Converter<any, any> {
  return { toCompat: (m: any) => C._fromModern(m), toModern: (c: any) => c._toModern() };
}
function unionConverter(C: any): Converter<any, any> {
  return { toCompat: (m: any) => C._fromModern(m), toModern: (c: any) => c._toModern() };
}

export type Uint32 = number;
export const Uint32 = createCompatTypedef({ codec: modern.Uint32, convert: id });

export interface ConfigSettingContractExecutionLanesV0 {
  ledgerMaxTxCount(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingContractExecutionLanesV0 = createCompatStruct({
  codec: modern.ConfigSettingContractExecutionLanesV0,
  fields: [
    { name: 'ledgerMaxTxCount', modernName: 'ledgerMaxTxCount', convert: id },
  ],
});
export const ConfigSettingContractExecutionLanesV0 = _ConfigSettingContractExecutionLanesV0 as unknown as {
  new(attributes: { ledgerMaxTxCount: Uint32 }): ConfigSettingContractExecutionLanesV0;
  read(io: Buffer): ConfigSettingContractExecutionLanesV0;
  write(value: ConfigSettingContractExecutionLanesV0, io: Buffer): void;
  isValid(value: ConfigSettingContractExecutionLanesV0): boolean;
  toXDR(value: ConfigSettingContractExecutionLanesV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingContractExecutionLanesV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingContractExecutionLanesV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const Int64 = Hyper;
export type Int64 = Hyper;

export interface ConfigSettingContractComputeV0 {
  ledgerMaxInstructions(value?: Int64): Int64;
  txMaxInstructions(value?: Int64): Int64;
  feeRatePerInstructionsIncrement(value?: Int64): Int64;
  txMemoryLimit(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingContractComputeV0 = createCompatStruct({
  codec: modern.ConfigSettingContractComputeV0,
  fields: [
    { name: 'ledgerMaxInstructions', modernName: 'ledgerMaxInstructions', convert: int64Conv },
    { name: 'txMaxInstructions', modernName: 'txMaxInstructions', convert: int64Conv },
    { name: 'feeRatePerInstructionsIncrement', modernName: 'feeRatePerInstructionsIncrement', convert: int64Conv },
    { name: 'txMemoryLimit', modernName: 'txMemoryLimit', convert: id },
  ],
});
export const ConfigSettingContractComputeV0 = _ConfigSettingContractComputeV0 as unknown as {
  new(attributes: { ledgerMaxInstructions: Int64; txMaxInstructions: Int64; feeRatePerInstructionsIncrement: Int64; txMemoryLimit: Uint32 }): ConfigSettingContractComputeV0;
  read(io: Buffer): ConfigSettingContractComputeV0;
  write(value: ConfigSettingContractComputeV0, io: Buffer): void;
  isValid(value: ConfigSettingContractComputeV0): boolean;
  toXDR(value: ConfigSettingContractComputeV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingContractComputeV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingContractComputeV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ConfigSettingContractParallelComputeV0 {
  ledgerMaxDependentTxClusters(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingContractParallelComputeV0 = createCompatStruct({
  codec: modern.ConfigSettingContractParallelComputeV0,
  fields: [
    { name: 'ledgerMaxDependentTxClusters', modernName: 'ledgerMaxDependentTxClusters', convert: id },
  ],
});
export const ConfigSettingContractParallelComputeV0 = _ConfigSettingContractParallelComputeV0 as unknown as {
  new(attributes: { ledgerMaxDependentTxClusters: Uint32 }): ConfigSettingContractParallelComputeV0;
  read(io: Buffer): ConfigSettingContractParallelComputeV0;
  write(value: ConfigSettingContractParallelComputeV0, io: Buffer): void;
  isValid(value: ConfigSettingContractParallelComputeV0): boolean;
  toXDR(value: ConfigSettingContractParallelComputeV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingContractParallelComputeV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingContractParallelComputeV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ConfigSettingContractLedgerCostV0 {
  ledgerMaxDiskReadEntries(value?: Uint32): Uint32;
  ledgerMaxDiskReadBytes(value?: Uint32): Uint32;
  ledgerMaxWriteLedgerEntries(value?: Uint32): Uint32;
  ledgerMaxWriteBytes(value?: Uint32): Uint32;
  txMaxDiskReadEntries(value?: Uint32): Uint32;
  txMaxDiskReadBytes(value?: Uint32): Uint32;
  txMaxWriteLedgerEntries(value?: Uint32): Uint32;
  txMaxWriteBytes(value?: Uint32): Uint32;
  feeDiskReadLedgerEntry(value?: Int64): Int64;
  feeWriteLedgerEntry(value?: Int64): Int64;
  feeDiskRead1Kb(value?: Int64): Int64;
  sorobanStateTargetSizeBytes(value?: Int64): Int64;
  rentFee1KbSorobanStateSizeLow(value?: Int64): Int64;
  rentFee1KbSorobanStateSizeHigh(value?: Int64): Int64;
  sorobanStateRentFeeGrowthFactor(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingContractLedgerCostV0 = createCompatStruct({
  codec: modern.ConfigSettingContractLedgerCostV0,
  fields: [
    { name: 'ledgerMaxDiskReadEntries', modernName: 'ledgerMaxDiskReadEntries', convert: id },
    { name: 'ledgerMaxDiskReadBytes', modernName: 'ledgerMaxDiskReadBytes', convert: id },
    { name: 'ledgerMaxWriteLedgerEntries', modernName: 'ledgerMaxWriteLedgerEntries', convert: id },
    { name: 'ledgerMaxWriteBytes', modernName: 'ledgerMaxWriteBytes', convert: id },
    { name: 'txMaxDiskReadEntries', modernName: 'txMaxDiskReadEntries', convert: id },
    { name: 'txMaxDiskReadBytes', modernName: 'txMaxDiskReadBytes', convert: id },
    { name: 'txMaxWriteLedgerEntries', modernName: 'txMaxWriteLedgerEntries', convert: id },
    { name: 'txMaxWriteBytes', modernName: 'txMaxWriteBytes', convert: id },
    { name: 'feeDiskReadLedgerEntry', modernName: 'feeDiskReadLedgerEntry', convert: int64Conv },
    { name: 'feeWriteLedgerEntry', modernName: 'feeWriteLedgerEntry', convert: int64Conv },
    { name: 'feeDiskRead1Kb', modernName: 'feeDiskRead1KB', convert: int64Conv },
    { name: 'sorobanStateTargetSizeBytes', modernName: 'sorobanStateTargetSizeBytes', convert: int64Conv },
    { name: 'rentFee1KbSorobanStateSizeLow', modernName: 'rentFee1KBSorobanStateSizeLow', convert: int64Conv },
    { name: 'rentFee1KbSorobanStateSizeHigh', modernName: 'rentFee1KBSorobanStateSizeHigh', convert: int64Conv },
    { name: 'sorobanStateRentFeeGrowthFactor', modernName: 'sorobanStateRentFeeGrowthFactor', convert: id },
  ],
});
export const ConfigSettingContractLedgerCostV0 = _ConfigSettingContractLedgerCostV0 as unknown as {
  new(attributes: { ledgerMaxDiskReadEntries: Uint32; ledgerMaxDiskReadBytes: Uint32; ledgerMaxWriteLedgerEntries: Uint32; ledgerMaxWriteBytes: Uint32; txMaxDiskReadEntries: Uint32; txMaxDiskReadBytes: Uint32; txMaxWriteLedgerEntries: Uint32; txMaxWriteBytes: Uint32; feeDiskReadLedgerEntry: Int64; feeWriteLedgerEntry: Int64; feeDiskRead1Kb: Int64; sorobanStateTargetSizeBytes: Int64; rentFee1KbSorobanStateSizeLow: Int64; rentFee1KbSorobanStateSizeHigh: Int64; sorobanStateRentFeeGrowthFactor: Uint32 }): ConfigSettingContractLedgerCostV0;
  read(io: Buffer): ConfigSettingContractLedgerCostV0;
  write(value: ConfigSettingContractLedgerCostV0, io: Buffer): void;
  isValid(value: ConfigSettingContractLedgerCostV0): boolean;
  toXDR(value: ConfigSettingContractLedgerCostV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingContractLedgerCostV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingContractLedgerCostV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ConfigSettingContractLedgerCostExtV0 {
  txMaxFootprintEntries(value?: Uint32): Uint32;
  feeWrite1Kb(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingContractLedgerCostExtV0 = createCompatStruct({
  codec: modern.ConfigSettingContractLedgerCostExtV0,
  fields: [
    { name: 'txMaxFootprintEntries', modernName: 'txMaxFootprintEntries', convert: id },
    { name: 'feeWrite1Kb', modernName: 'feeWrite1KB', convert: int64Conv },
  ],
});
export const ConfigSettingContractLedgerCostExtV0 = _ConfigSettingContractLedgerCostExtV0 as unknown as {
  new(attributes: { txMaxFootprintEntries: Uint32; feeWrite1Kb: Int64 }): ConfigSettingContractLedgerCostExtV0;
  read(io: Buffer): ConfigSettingContractLedgerCostExtV0;
  write(value: ConfigSettingContractLedgerCostExtV0, io: Buffer): void;
  isValid(value: ConfigSettingContractLedgerCostExtV0): boolean;
  toXDR(value: ConfigSettingContractLedgerCostExtV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingContractLedgerCostExtV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingContractLedgerCostExtV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ConfigSettingContractHistoricalDataV0 {
  feeHistorical1Kb(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingContractHistoricalDataV0 = createCompatStruct({
  codec: modern.ConfigSettingContractHistoricalDataV0,
  fields: [
    { name: 'feeHistorical1Kb', modernName: 'feeHistorical1KB', convert: int64Conv },
  ],
});
export const ConfigSettingContractHistoricalDataV0 = _ConfigSettingContractHistoricalDataV0 as unknown as {
  new(attributes: { feeHistorical1Kb: Int64 }): ConfigSettingContractHistoricalDataV0;
  read(io: Buffer): ConfigSettingContractHistoricalDataV0;
  write(value: ConfigSettingContractHistoricalDataV0, io: Buffer): void;
  isValid(value: ConfigSettingContractHistoricalDataV0): boolean;
  toXDR(value: ConfigSettingContractHistoricalDataV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingContractHistoricalDataV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingContractHistoricalDataV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ConfigSettingContractEventsV0 {
  txMaxContractEventsSizeBytes(value?: Uint32): Uint32;
  feeContractEvents1Kb(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingContractEventsV0 = createCompatStruct({
  codec: modern.ConfigSettingContractEventsV0,
  fields: [
    { name: 'txMaxContractEventsSizeBytes', modernName: 'txMaxContractEventsSizeBytes', convert: id },
    { name: 'feeContractEvents1Kb', modernName: 'feeContractEvents1KB', convert: int64Conv },
  ],
});
export const ConfigSettingContractEventsV0 = _ConfigSettingContractEventsV0 as unknown as {
  new(attributes: { txMaxContractEventsSizeBytes: Uint32; feeContractEvents1Kb: Int64 }): ConfigSettingContractEventsV0;
  read(io: Buffer): ConfigSettingContractEventsV0;
  write(value: ConfigSettingContractEventsV0, io: Buffer): void;
  isValid(value: ConfigSettingContractEventsV0): boolean;
  toXDR(value: ConfigSettingContractEventsV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingContractEventsV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingContractEventsV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ConfigSettingContractBandwidthV0 {
  ledgerMaxTxsSizeBytes(value?: Uint32): Uint32;
  txMaxSizeBytes(value?: Uint32): Uint32;
  feeTxSize1Kb(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingContractBandwidthV0 = createCompatStruct({
  codec: modern.ConfigSettingContractBandwidthV0,
  fields: [
    { name: 'ledgerMaxTxsSizeBytes', modernName: 'ledgerMaxTxsSizeBytes', convert: id },
    { name: 'txMaxSizeBytes', modernName: 'txMaxSizeBytes', convert: id },
    { name: 'feeTxSize1Kb', modernName: 'feeTxSize1KB', convert: int64Conv },
  ],
});
export const ConfigSettingContractBandwidthV0 = _ConfigSettingContractBandwidthV0 as unknown as {
  new(attributes: { ledgerMaxTxsSizeBytes: Uint32; txMaxSizeBytes: Uint32; feeTxSize1Kb: Int64 }): ConfigSettingContractBandwidthV0;
  read(io: Buffer): ConfigSettingContractBandwidthV0;
  write(value: ConfigSettingContractBandwidthV0, io: Buffer): void;
  isValid(value: ConfigSettingContractBandwidthV0): boolean;
  toXDR(value: ConfigSettingContractBandwidthV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingContractBandwidthV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingContractBandwidthV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractCostType {
  readonly name: 'wasmInsnExec' | 'memAlloc' | 'memCpy' | 'memCmp' | 'dispatchHostFunction' | 'visitObject' | 'valSer' | 'valDeser' | 'computeSha256Hash' | 'computeEd25519PubKey' | 'verifyEd25519Sig' | 'vmInstantiation' | 'vmCachedInstantiation' | 'invokeVmFunction' | 'computeKeccak256Hash' | 'decodeEcdsaCurve256Sig' | 'recoverEcdsaSecp256k1Key' | 'int256AddSub' | 'int256Mul' | 'int256Div' | 'int256Pow' | 'int256Shift' | 'chaCha20DrawBytes' | 'parseWasmInstructions' | 'parseWasmFunctions' | 'parseWasmGlobals' | 'parseWasmTableEntries' | 'parseWasmTypes' | 'parseWasmDataSegments' | 'parseWasmElemSegments' | 'parseWasmImports' | 'parseWasmExports' | 'parseWasmDataSegmentBytes' | 'instantiateWasmInstructions' | 'instantiateWasmFunctions' | 'instantiateWasmGlobals' | 'instantiateWasmTableEntries' | 'instantiateWasmTypes' | 'instantiateWasmDataSegments' | 'instantiateWasmElemSegments' | 'instantiateWasmImports' | 'instantiateWasmExports' | 'instantiateWasmDataSegmentBytes' | 'sec1DecodePointUncompressed' | 'verifyEcdsaSecp256r1Sig' | 'bls12381EncodeFp' | 'bls12381DecodeFp' | 'bls12381G1CheckPointOnCurve' | 'bls12381G1CheckPointInSubgroup' | 'bls12381G2CheckPointOnCurve' | 'bls12381G2CheckPointInSubgroup' | 'bls12381G1ProjectiveToAffine' | 'bls12381G2ProjectiveToAffine' | 'bls12381G1Add' | 'bls12381G1Mul' | 'bls12381G1Msm' | 'bls12381MapFpToG1' | 'bls12381HashToG1' | 'bls12381G2Add' | 'bls12381G2Mul' | 'bls12381G2Msm' | 'bls12381MapFp2ToG2' | 'bls12381HashToG2' | 'bls12381Pairing' | 'bls12381FrFromU256' | 'bls12381FrToU256' | 'bls12381FrAddSub' | 'bls12381FrMul' | 'bls12381FrPow' | 'bls12381FrInv' | 'bn254EncodeFp' | 'bn254DecodeFp' | 'bn254G1CheckPointOnCurve' | 'bn254G2CheckPointOnCurve' | 'bn254G2CheckPointInSubgroup' | 'bn254G1ProjectiveToAffine' | 'bn254G1Add' | 'bn254G1Mul' | 'bn254Pairing' | 'bn254FrFromU256' | 'bn254FrToU256' | 'bn254FrAddSub' | 'bn254FrMul' | 'bn254FrPow' | 'bn254FrInv';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84;
}
const _ContractCostType = createCompatEnum({
  codec: modern.ContractCostType,
  members: [
    { compat: 'wasmInsnExec', modern: 'WasmInsnExec', value: 0 },
    { compat: 'memAlloc', modern: 'MemAlloc', value: 1 },
    { compat: 'memCpy', modern: 'MemCpy', value: 2 },
    { compat: 'memCmp', modern: 'MemCmp', value: 3 },
    { compat: 'dispatchHostFunction', modern: 'DispatchHostFunction', value: 4 },
    { compat: 'visitObject', modern: 'VisitObject', value: 5 },
    { compat: 'valSer', modern: 'ValSer', value: 6 },
    { compat: 'valDeser', modern: 'ValDeser', value: 7 },
    { compat: 'computeSha256Hash', modern: 'ComputeSha256Hash', value: 8 },
    { compat: 'computeEd25519PubKey', modern: 'ComputeEd25519PubKey', value: 9 },
    { compat: 'verifyEd25519Sig', modern: 'VerifyEd25519Sig', value: 10 },
    { compat: 'vmInstantiation', modern: 'VmInstantiation', value: 11 },
    { compat: 'vmCachedInstantiation', modern: 'VmCachedInstantiation', value: 12 },
    { compat: 'invokeVmFunction', modern: 'InvokeVmFunction', value: 13 },
    { compat: 'computeKeccak256Hash', modern: 'ComputeKeccak256Hash', value: 14 },
    { compat: 'decodeEcdsaCurve256Sig', modern: 'DecodeEcdsaCurve256Sig', value: 15 },
    { compat: 'recoverEcdsaSecp256k1Key', modern: 'RecoverEcdsaSecp256k1Key', value: 16 },
    { compat: 'int256AddSub', modern: 'Int256AddSub', value: 17 },
    { compat: 'int256Mul', modern: 'Int256Mul', value: 18 },
    { compat: 'int256Div', modern: 'Int256Div', value: 19 },
    { compat: 'int256Pow', modern: 'Int256Pow', value: 20 },
    { compat: 'int256Shift', modern: 'Int256Shift', value: 21 },
    { compat: 'chaCha20DrawBytes', modern: 'ChaCha20DrawBytes', value: 22 },
    { compat: 'parseWasmInstructions', modern: 'ParseWasmInstructions', value: 23 },
    { compat: 'parseWasmFunctions', modern: 'ParseWasmFunctions', value: 24 },
    { compat: 'parseWasmGlobals', modern: 'ParseWasmGlobals', value: 25 },
    { compat: 'parseWasmTableEntries', modern: 'ParseWasmTableEntries', value: 26 },
    { compat: 'parseWasmTypes', modern: 'ParseWasmTypes', value: 27 },
    { compat: 'parseWasmDataSegments', modern: 'ParseWasmDataSegments', value: 28 },
    { compat: 'parseWasmElemSegments', modern: 'ParseWasmElemSegments', value: 29 },
    { compat: 'parseWasmImports', modern: 'ParseWasmImports', value: 30 },
    { compat: 'parseWasmExports', modern: 'ParseWasmExports', value: 31 },
    { compat: 'parseWasmDataSegmentBytes', modern: 'ParseWasmDataSegmentBytes', value: 32 },
    { compat: 'instantiateWasmInstructions', modern: 'InstantiateWasmInstructions', value: 33 },
    { compat: 'instantiateWasmFunctions', modern: 'InstantiateWasmFunctions', value: 34 },
    { compat: 'instantiateWasmGlobals', modern: 'InstantiateWasmGlobals', value: 35 },
    { compat: 'instantiateWasmTableEntries', modern: 'InstantiateWasmTableEntries', value: 36 },
    { compat: 'instantiateWasmTypes', modern: 'InstantiateWasmTypes', value: 37 },
    { compat: 'instantiateWasmDataSegments', modern: 'InstantiateWasmDataSegments', value: 38 },
    { compat: 'instantiateWasmElemSegments', modern: 'InstantiateWasmElemSegments', value: 39 },
    { compat: 'instantiateWasmImports', modern: 'InstantiateWasmImports', value: 40 },
    { compat: 'instantiateWasmExports', modern: 'InstantiateWasmExports', value: 41 },
    { compat: 'instantiateWasmDataSegmentBytes', modern: 'InstantiateWasmDataSegmentBytes', value: 42 },
    { compat: 'sec1DecodePointUncompressed', modern: 'Sec1DecodePointUncompressed', value: 43 },
    { compat: 'verifyEcdsaSecp256r1Sig', modern: 'VerifyEcdsaSecp256r1Sig', value: 44 },
    { compat: 'bls12381EncodeFp', modern: 'Bls12381EncodeFp', value: 45 },
    { compat: 'bls12381DecodeFp', modern: 'Bls12381DecodeFp', value: 46 },
    { compat: 'bls12381G1CheckPointOnCurve', modern: 'Bls12381G1CheckPointOnCurve', value: 47 },
    { compat: 'bls12381G1CheckPointInSubgroup', modern: 'Bls12381G1CheckPointInSubgroup', value: 48 },
    { compat: 'bls12381G2CheckPointOnCurve', modern: 'Bls12381G2CheckPointOnCurve', value: 49 },
    { compat: 'bls12381G2CheckPointInSubgroup', modern: 'Bls12381G2CheckPointInSubgroup', value: 50 },
    { compat: 'bls12381G1ProjectiveToAffine', modern: 'Bls12381G1ProjectiveToAffine', value: 51 },
    { compat: 'bls12381G2ProjectiveToAffine', modern: 'Bls12381G2ProjectiveToAffine', value: 52 },
    { compat: 'bls12381G1Add', modern: 'Bls12381G1Add', value: 53 },
    { compat: 'bls12381G1Mul', modern: 'Bls12381G1Mul', value: 54 },
    { compat: 'bls12381G1Msm', modern: 'Bls12381G1Msm', value: 55 },
    { compat: 'bls12381MapFpToG1', modern: 'Bls12381MapFpToG1', value: 56 },
    { compat: 'bls12381HashToG1', modern: 'Bls12381HashToG1', value: 57 },
    { compat: 'bls12381G2Add', modern: 'Bls12381G2Add', value: 58 },
    { compat: 'bls12381G2Mul', modern: 'Bls12381G2Mul', value: 59 },
    { compat: 'bls12381G2Msm', modern: 'Bls12381G2Msm', value: 60 },
    { compat: 'bls12381MapFp2ToG2', modern: 'Bls12381MapFp2ToG2', value: 61 },
    { compat: 'bls12381HashToG2', modern: 'Bls12381HashToG2', value: 62 },
    { compat: 'bls12381Pairing', modern: 'Bls12381Pairing', value: 63 },
    { compat: 'bls12381FrFromU256', modern: 'Bls12381FrFromU256', value: 64 },
    { compat: 'bls12381FrToU256', modern: 'Bls12381FrToU256', value: 65 },
    { compat: 'bls12381FrAddSub', modern: 'Bls12381FrAddSub', value: 66 },
    { compat: 'bls12381FrMul', modern: 'Bls12381FrMul', value: 67 },
    { compat: 'bls12381FrPow', modern: 'Bls12381FrPow', value: 68 },
    { compat: 'bls12381FrInv', modern: 'Bls12381FrInv', value: 69 },
    { compat: 'bn254EncodeFp', modern: 'Bn254EncodeFp', value: 70 },
    { compat: 'bn254DecodeFp', modern: 'Bn254DecodeFp', value: 71 },
    { compat: 'bn254G1CheckPointOnCurve', modern: 'Bn254G1CheckPointOnCurve', value: 72 },
    { compat: 'bn254G2CheckPointOnCurve', modern: 'Bn254G2CheckPointOnCurve', value: 73 },
    { compat: 'bn254G2CheckPointInSubgroup', modern: 'Bn254G2CheckPointInSubgroup', value: 74 },
    { compat: 'bn254G1ProjectiveToAffine', modern: 'Bn254G1ProjectiveToAffine', value: 75 },
    { compat: 'bn254G1Add', modern: 'Bn254G1Add', value: 76 },
    { compat: 'bn254G1Mul', modern: 'Bn254G1Mul', value: 77 },
    { compat: 'bn254Pairing', modern: 'Bn254Pairing', value: 78 },
    { compat: 'bn254FrFromU256', modern: 'Bn254FrFromU256', value: 79 },
    { compat: 'bn254FrToU256', modern: 'Bn254FrToU256', value: 80 },
    { compat: 'bn254FrAddSub', modern: 'Bn254FrAddSub', value: 81 },
    { compat: 'bn254FrMul', modern: 'Bn254FrMul', value: 82 },
    { compat: 'bn254FrPow', modern: 'Bn254FrPow', value: 83 },
    { compat: 'bn254FrInv', modern: 'Bn254FrInv', value: 84 },
  ],
});
export const ContractCostType = _ContractCostType as unknown as {
  wasmInsnExec(): ContractCostType;
  memAlloc(): ContractCostType;
  memCpy(): ContractCostType;
  memCmp(): ContractCostType;
  dispatchHostFunction(): ContractCostType;
  visitObject(): ContractCostType;
  valSer(): ContractCostType;
  valDeser(): ContractCostType;
  computeSha256Hash(): ContractCostType;
  computeEd25519PubKey(): ContractCostType;
  verifyEd25519Sig(): ContractCostType;
  vmInstantiation(): ContractCostType;
  vmCachedInstantiation(): ContractCostType;
  invokeVmFunction(): ContractCostType;
  computeKeccak256Hash(): ContractCostType;
  decodeEcdsaCurve256Sig(): ContractCostType;
  recoverEcdsaSecp256k1Key(): ContractCostType;
  int256AddSub(): ContractCostType;
  int256Mul(): ContractCostType;
  int256Div(): ContractCostType;
  int256Pow(): ContractCostType;
  int256Shift(): ContractCostType;
  chaCha20DrawBytes(): ContractCostType;
  parseWasmInstructions(): ContractCostType;
  parseWasmFunctions(): ContractCostType;
  parseWasmGlobals(): ContractCostType;
  parseWasmTableEntries(): ContractCostType;
  parseWasmTypes(): ContractCostType;
  parseWasmDataSegments(): ContractCostType;
  parseWasmElemSegments(): ContractCostType;
  parseWasmImports(): ContractCostType;
  parseWasmExports(): ContractCostType;
  parseWasmDataSegmentBytes(): ContractCostType;
  instantiateWasmInstructions(): ContractCostType;
  instantiateWasmFunctions(): ContractCostType;
  instantiateWasmGlobals(): ContractCostType;
  instantiateWasmTableEntries(): ContractCostType;
  instantiateWasmTypes(): ContractCostType;
  instantiateWasmDataSegments(): ContractCostType;
  instantiateWasmElemSegments(): ContractCostType;
  instantiateWasmImports(): ContractCostType;
  instantiateWasmExports(): ContractCostType;
  instantiateWasmDataSegmentBytes(): ContractCostType;
  sec1DecodePointUncompressed(): ContractCostType;
  verifyEcdsaSecp256r1Sig(): ContractCostType;
  bls12381EncodeFp(): ContractCostType;
  bls12381DecodeFp(): ContractCostType;
  bls12381G1CheckPointOnCurve(): ContractCostType;
  bls12381G1CheckPointInSubgroup(): ContractCostType;
  bls12381G2CheckPointOnCurve(): ContractCostType;
  bls12381G2CheckPointInSubgroup(): ContractCostType;
  bls12381G1ProjectiveToAffine(): ContractCostType;
  bls12381G2ProjectiveToAffine(): ContractCostType;
  bls12381G1Add(): ContractCostType;
  bls12381G1Mul(): ContractCostType;
  bls12381G1Msm(): ContractCostType;
  bls12381MapFpToG1(): ContractCostType;
  bls12381HashToG1(): ContractCostType;
  bls12381G2Add(): ContractCostType;
  bls12381G2Mul(): ContractCostType;
  bls12381G2Msm(): ContractCostType;
  bls12381MapFp2ToG2(): ContractCostType;
  bls12381HashToG2(): ContractCostType;
  bls12381Pairing(): ContractCostType;
  bls12381FrFromU256(): ContractCostType;
  bls12381FrToU256(): ContractCostType;
  bls12381FrAddSub(): ContractCostType;
  bls12381FrMul(): ContractCostType;
  bls12381FrPow(): ContractCostType;
  bls12381FrInv(): ContractCostType;
  bn254EncodeFp(): ContractCostType;
  bn254DecodeFp(): ContractCostType;
  bn254G1CheckPointOnCurve(): ContractCostType;
  bn254G2CheckPointOnCurve(): ContractCostType;
  bn254G2CheckPointInSubgroup(): ContractCostType;
  bn254G1ProjectiveToAffine(): ContractCostType;
  bn254G1Add(): ContractCostType;
  bn254G1Mul(): ContractCostType;
  bn254Pairing(): ContractCostType;
  bn254FrFromU256(): ContractCostType;
  bn254FrToU256(): ContractCostType;
  bn254FrAddSub(): ContractCostType;
  bn254FrMul(): ContractCostType;
  bn254FrPow(): ContractCostType;
  bn254FrInv(): ContractCostType;
};

export interface ExtensionPoint {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ExtensionPoint = createCompatUnion({
  codec: modern.ExtensionPoint,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const ExtensionPoint = _ExtensionPoint as unknown as {
  0(): ExtensionPoint;
  read(io: Buffer): ExtensionPoint;
  write(value: ExtensionPoint, io: Buffer): void;
  isValid(value: ExtensionPoint): boolean;
  toXDR(value: ExtensionPoint): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ExtensionPoint;
  fromXDR(input: string, format: 'hex' | 'base64'): ExtensionPoint;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractCostParamEntry {
  ext(value?: ExtensionPoint): ExtensionPoint;
  constTerm(value?: Int64): Int64;
  linearTerm(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractCostParamEntry = createCompatStruct({
  codec: modern.ContractCostParamEntry,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'constTerm', modernName: 'constTerm', convert: int64Conv },
    { name: 'linearTerm', modernName: 'linearTerm', convert: int64Conv },
  ],
});
export const ContractCostParamEntry = _ContractCostParamEntry as unknown as {
  new(attributes: { ext: ExtensionPoint; constTerm: Int64; linearTerm: Int64 }): ContractCostParamEntry;
  read(io: Buffer): ContractCostParamEntry;
  write(value: ContractCostParamEntry, io: Buffer): void;
  isValid(value: ContractCostParamEntry): boolean;
  toXDR(value: ContractCostParamEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractCostParamEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractCostParamEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface StateArchivalSettings {
  maxEntryTtl(value?: Uint32): Uint32;
  minTemporaryTtl(value?: Uint32): Uint32;
  minPersistentTtl(value?: Uint32): Uint32;
  persistentRentRateDenominator(value?: Int64): Int64;
  tempRentRateDenominator(value?: Int64): Int64;
  maxEntriesToArchive(value?: Uint32): Uint32;
  liveSorobanStateSizeWindowSampleSize(value?: Uint32): Uint32;
  liveSorobanStateSizeWindowSamplePeriod(value?: Uint32): Uint32;
  evictionScanSize(value?: Uint32): Uint32;
  startingEvictionScanLevel(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _StateArchivalSettings = createCompatStruct({
  codec: modern.StateArchivalSettings,
  fields: [
    { name: 'maxEntryTtl', modernName: 'maxEntryTTL', convert: id },
    { name: 'minTemporaryTtl', modernName: 'minTemporaryTTL', convert: id },
    { name: 'minPersistentTtl', modernName: 'minPersistentTTL', convert: id },
    { name: 'persistentRentRateDenominator', modernName: 'persistentRentRateDenominator', convert: int64Conv },
    { name: 'tempRentRateDenominator', modernName: 'tempRentRateDenominator', convert: int64Conv },
    { name: 'maxEntriesToArchive', modernName: 'maxEntriesToArchive', convert: id },
    { name: 'liveSorobanStateSizeWindowSampleSize', modernName: 'liveSorobanStateSizeWindowSampleSize', convert: id },
    { name: 'liveSorobanStateSizeWindowSamplePeriod', modernName: 'liveSorobanStateSizeWindowSamplePeriod', convert: id },
    { name: 'evictionScanSize', modernName: 'evictionScanSize', convert: id },
    { name: 'startingEvictionScanLevel', modernName: 'startingEvictionScanLevel', convert: id },
  ],
});
export const StateArchivalSettings = _StateArchivalSettings as unknown as {
  new(attributes: { maxEntryTtl: Uint32; minTemporaryTtl: Uint32; minPersistentTtl: Uint32; persistentRentRateDenominator: Int64; tempRentRateDenominator: Int64; maxEntriesToArchive: Uint32; liveSorobanStateSizeWindowSampleSize: Uint32; liveSorobanStateSizeWindowSamplePeriod: Uint32; evictionScanSize: Uint32; startingEvictionScanLevel: Uint32 }): StateArchivalSettings;
  read(io: Buffer): StateArchivalSettings;
  write(value: StateArchivalSettings, io: Buffer): void;
  isValid(value: StateArchivalSettings): boolean;
  toXDR(value: StateArchivalSettings): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): StateArchivalSettings;
  fromXDR(input: string, format: 'hex' | 'base64'): StateArchivalSettings;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const Uint64 = UnsignedHyper;
export type Uint64 = UnsignedHyper;

export interface EvictionIterator {
  bucketListLevel(value?: Uint32): Uint32;
  isCurrBucket(value?: boolean): boolean;
  bucketFileOffset(value?: Uint64): Uint64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _EvictionIterator = createCompatStruct({
  codec: modern.EvictionIterator,
  fields: [
    { name: 'bucketListLevel', modernName: 'bucketListLevel', convert: id },
    { name: 'isCurrBucket', modernName: 'isCurrBucket', convert: id },
    { name: 'bucketFileOffset', modernName: 'bucketFileOffset', convert: uint64Conv },
  ],
});
export const EvictionIterator = _EvictionIterator as unknown as {
  new(attributes: { bucketListLevel: Uint32; isCurrBucket: boolean; bucketFileOffset: Uint64 }): EvictionIterator;
  read(io: Buffer): EvictionIterator;
  write(value: EvictionIterator, io: Buffer): void;
  isValid(value: EvictionIterator): boolean;
  toXDR(value: EvictionIterator): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): EvictionIterator;
  fromXDR(input: string, format: 'hex' | 'base64'): EvictionIterator;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ConfigSettingScpTiming {
  ledgerTargetCloseTimeMilliseconds(value?: Uint32): Uint32;
  nominationTimeoutInitialMilliseconds(value?: Uint32): Uint32;
  nominationTimeoutIncrementMilliseconds(value?: Uint32): Uint32;
  ballotTimeoutInitialMilliseconds(value?: Uint32): Uint32;
  ballotTimeoutIncrementMilliseconds(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingScpTiming = createCompatStruct({
  codec: modern.ConfigSettingSCPTiming,
  fields: [
    { name: 'ledgerTargetCloseTimeMilliseconds', modernName: 'ledgerTargetCloseTimeMilliseconds', convert: id },
    { name: 'nominationTimeoutInitialMilliseconds', modernName: 'nominationTimeoutInitialMilliseconds', convert: id },
    { name: 'nominationTimeoutIncrementMilliseconds', modernName: 'nominationTimeoutIncrementMilliseconds', convert: id },
    { name: 'ballotTimeoutInitialMilliseconds', modernName: 'ballotTimeoutInitialMilliseconds', convert: id },
    { name: 'ballotTimeoutIncrementMilliseconds', modernName: 'ballotTimeoutIncrementMilliseconds', convert: id },
  ],
});
export const ConfigSettingScpTiming = _ConfigSettingScpTiming as unknown as {
  new(attributes: { ledgerTargetCloseTimeMilliseconds: Uint32; nominationTimeoutInitialMilliseconds: Uint32; nominationTimeoutIncrementMilliseconds: Uint32; ballotTimeoutInitialMilliseconds: Uint32; ballotTimeoutIncrementMilliseconds: Uint32 }): ConfigSettingScpTiming;
  read(io: Buffer): ConfigSettingScpTiming;
  write(value: ConfigSettingScpTiming, io: Buffer): void;
  isValid(value: ConfigSettingScpTiming): boolean;
  toXDR(value: ConfigSettingScpTiming): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingScpTiming;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingScpTiming;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const CONTRACT_COST_COUNT_LIMIT = 1024;

export type ContractCostParams = ContractCostParamEntry[];
export const ContractCostParams = createCompatTypedef({ codec: modern.ContractCostParams, convert: arrayConverter(structConverter(_ContractCostParamEntry)) });

export interface ConfigSettingId {
  readonly name: 'configSettingContractMaxSizeBytes' | 'configSettingContractComputeV0' | 'configSettingContractLedgerCostV0' | 'configSettingContractHistoricalDataV0' | 'configSettingContractEventsV0' | 'configSettingContractBandwidthV0' | 'configSettingContractCostParamsCpuInstructions' | 'configSettingContractCostParamsMemoryBytes' | 'configSettingContractDataKeySizeBytes' | 'configSettingContractDataEntrySizeBytes' | 'configSettingStateArchival' | 'configSettingContractExecutionLanes' | 'configSettingLiveSorobanStateSizeWindow' | 'configSettingEvictionIterator' | 'configSettingContractParallelComputeV0' | 'configSettingContractLedgerCostExtV0' | 'configSettingScpTiming';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16;
}
const _ConfigSettingId = createCompatEnum({
  codec: modern.ConfigSettingID,
  members: [
    { compat: 'configSettingContractMaxSizeBytes', modern: 'ContractMaxSizeBytes', value: 0 },
    { compat: 'configSettingContractComputeV0', modern: 'ContractComputeV0', value: 1 },
    { compat: 'configSettingContractLedgerCostV0', modern: 'ContractLedgerCostV0', value: 2 },
    { compat: 'configSettingContractHistoricalDataV0', modern: 'ContractHistoricalDataV0', value: 3 },
    { compat: 'configSettingContractEventsV0', modern: 'ContractEventsV0', value: 4 },
    { compat: 'configSettingContractBandwidthV0', modern: 'ContractBandwidthV0', value: 5 },
    { compat: 'configSettingContractCostParamsCpuInstructions', modern: 'ContractCostParamsCpuInstructions', value: 6 },
    { compat: 'configSettingContractCostParamsMemoryBytes', modern: 'ContractCostParamsMemoryBytes', value: 7 },
    { compat: 'configSettingContractDataKeySizeBytes', modern: 'ContractDataKeySizeBytes', value: 8 },
    { compat: 'configSettingContractDataEntrySizeBytes', modern: 'ContractDataEntrySizeBytes', value: 9 },
    { compat: 'configSettingStateArchival', modern: 'StateArchival', value: 10 },
    { compat: 'configSettingContractExecutionLanes', modern: 'ContractExecutionLanes', value: 11 },
    { compat: 'configSettingLiveSorobanStateSizeWindow', modern: 'LiveSorobanStateSizeWindow', value: 12 },
    { compat: 'configSettingEvictionIterator', modern: 'EvictionIterator', value: 13 },
    { compat: 'configSettingContractParallelComputeV0', modern: 'ContractParallelComputeV0', value: 14 },
    { compat: 'configSettingContractLedgerCostExtV0', modern: 'ContractLedgerCostExtV0', value: 15 },
    { compat: 'configSettingScpTiming', modern: 'ScpTiming', value: 16 },
  ],
});
export const ConfigSettingId = _ConfigSettingId as unknown as {
  configSettingContractMaxSizeBytes(): ConfigSettingId;
  configSettingContractComputeV0(): ConfigSettingId;
  configSettingContractLedgerCostV0(): ConfigSettingId;
  configSettingContractHistoricalDataV0(): ConfigSettingId;
  configSettingContractEventsV0(): ConfigSettingId;
  configSettingContractBandwidthV0(): ConfigSettingId;
  configSettingContractCostParamsCpuInstructions(): ConfigSettingId;
  configSettingContractCostParamsMemoryBytes(): ConfigSettingId;
  configSettingContractDataKeySizeBytes(): ConfigSettingId;
  configSettingContractDataEntrySizeBytes(): ConfigSettingId;
  configSettingStateArchival(): ConfigSettingId;
  configSettingContractExecutionLanes(): ConfigSettingId;
  configSettingLiveSorobanStateSizeWindow(): ConfigSettingId;
  configSettingEvictionIterator(): ConfigSettingId;
  configSettingContractParallelComputeV0(): ConfigSettingId;
  configSettingContractLedgerCostExtV0(): ConfigSettingId;
  configSettingScpTiming(): ConfigSettingId;
};

export interface ConfigSettingEntry {
  switch(): ConfigSettingId;
  contractMaxSizeBytes(value?: Uint32): Uint32;
  contractCompute(value?: ConfigSettingContractComputeV0): ConfigSettingContractComputeV0;
  contractLedgerCost(value?: ConfigSettingContractLedgerCostV0): ConfigSettingContractLedgerCostV0;
  contractHistoricalData(value?: ConfigSettingContractHistoricalDataV0): ConfigSettingContractHistoricalDataV0;
  contractEvents(value?: ConfigSettingContractEventsV0): ConfigSettingContractEventsV0;
  contractBandwidth(value?: ConfigSettingContractBandwidthV0): ConfigSettingContractBandwidthV0;
  contractCostParamsCpuInsns(value?: ContractCostParams): ContractCostParams;
  contractCostParamsMemBytes(value?: ContractCostParams): ContractCostParams;
  contractDataKeySizeBytes(value?: Uint32): Uint32;
  contractDataEntrySizeBytes(value?: Uint32): Uint32;
  stateArchivalSettings(value?: StateArchivalSettings): StateArchivalSettings;
  contractExecutionLanes(value?: ConfigSettingContractExecutionLanesV0): ConfigSettingContractExecutionLanesV0;
  liveSorobanStateSizeWindow(value?: Uint64[]): Uint64[];
  evictionIterator(value?: EvictionIterator): EvictionIterator;
  contractParallelCompute(value?: ConfigSettingContractParallelComputeV0): ConfigSettingContractParallelComputeV0;
  contractLedgerCostExt(value?: ConfigSettingContractLedgerCostExtV0): ConfigSettingContractLedgerCostExtV0;
  contractScpTiming(value?: ConfigSettingScpTiming): ConfigSettingScpTiming;
  value(): Uint32 | ConfigSettingContractComputeV0 | ConfigSettingContractLedgerCostV0 | ConfigSettingContractHistoricalDataV0 | ConfigSettingContractEventsV0 | ConfigSettingContractBandwidthV0 | ContractCostParams | ContractCostParams | Uint32 | Uint32 | StateArchivalSettings | ConfigSettingContractExecutionLanesV0 | Uint64[] | EvictionIterator | ConfigSettingContractParallelComputeV0 | ConfigSettingContractLedgerCostExtV0 | ConfigSettingScpTiming;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigSettingEntry = createCompatUnion({
  codec: modern.ConfigSettingEntry,
  switchEnum: _ConfigSettingId,
  arms: [
    { switchValues: ['configSettingContractMaxSizeBytes'], modern: 'ContractMaxSizeBytes', arm: 'contractMaxSizeBytes', convert: id },
    { switchValues: ['configSettingContractComputeV0'], modern: 'ContractComputeV0', arm: 'contractCompute', convert: structConverter(_ConfigSettingContractComputeV0) },
    { switchValues: ['configSettingContractLedgerCostV0'], modern: 'ContractLedgerCostV0', arm: 'contractLedgerCost', convert: structConverter(_ConfigSettingContractLedgerCostV0) },
    { switchValues: ['configSettingContractHistoricalDataV0'], modern: 'ContractHistoricalDataV0', arm: 'contractHistoricalData', convert: structConverter(_ConfigSettingContractHistoricalDataV0) },
    { switchValues: ['configSettingContractEventsV0'], modern: 'ContractEventsV0', arm: 'contractEvents', convert: structConverter(_ConfigSettingContractEventsV0) },
    { switchValues: ['configSettingContractBandwidthV0'], modern: 'ContractBandwidthV0', arm: 'contractBandwidth', convert: structConverter(_ConfigSettingContractBandwidthV0) },
    { switchValues: ['configSettingContractCostParamsCpuInstructions'], modern: 'ContractCostParamsCpuInstructions', arm: 'contractCostParamsCpuInsns', convert: arrayConverter(structConverter(_ContractCostParamEntry)) },
    { switchValues: ['configSettingContractCostParamsMemoryBytes'], modern: 'ContractCostParamsMemoryBytes', arm: 'contractCostParamsMemBytes', convert: arrayConverter(structConverter(_ContractCostParamEntry)) },
    { switchValues: ['configSettingContractDataKeySizeBytes'], modern: 'ContractDataKeySizeBytes', arm: 'contractDataKeySizeBytes', convert: id },
    { switchValues: ['configSettingContractDataEntrySizeBytes'], modern: 'ContractDataEntrySizeBytes', arm: 'contractDataEntrySizeBytes', convert: id },
    { switchValues: ['configSettingStateArchival'], modern: 'StateArchival', arm: 'stateArchivalSettings', convert: structConverter(_StateArchivalSettings) },
    { switchValues: ['configSettingContractExecutionLanes'], modern: 'ContractExecutionLanes', arm: 'contractExecutionLanes', convert: structConverter(_ConfigSettingContractExecutionLanesV0) },
    { switchValues: ['configSettingLiveSorobanStateSizeWindow'], modern: 'LiveSorobanStateSizeWindow', arm: 'liveSorobanStateSizeWindow', convert: arrayConverter(uint64Conv) },
    { switchValues: ['configSettingEvictionIterator'], modern: 'EvictionIterator', arm: 'evictionIterator', convert: structConverter(_EvictionIterator) },
    { switchValues: ['configSettingContractParallelComputeV0'], modern: 'ContractParallelComputeV0', arm: 'contractParallelCompute', convert: structConverter(_ConfigSettingContractParallelComputeV0) },
    { switchValues: ['configSettingContractLedgerCostExtV0'], modern: 'ContractLedgerCostExtV0', arm: 'contractLedgerCostExt', convert: structConverter(_ConfigSettingContractLedgerCostExtV0) },
    { switchValues: ['configSettingScpTiming'], modern: 'ScpTiming', arm: 'contractScpTiming', convert: structConverter(_ConfigSettingScpTiming) },
  ],
});
export const ConfigSettingEntry = _ConfigSettingEntry as unknown as {
  configSettingContractMaxSizeBytes(value: Uint32): ConfigSettingEntry;
  configSettingContractComputeV0(value: ConfigSettingContractComputeV0): ConfigSettingEntry;
  configSettingContractLedgerCostV0(value: ConfigSettingContractLedgerCostV0): ConfigSettingEntry;
  configSettingContractHistoricalDataV0(value: ConfigSettingContractHistoricalDataV0): ConfigSettingEntry;
  configSettingContractEventsV0(value: ConfigSettingContractEventsV0): ConfigSettingEntry;
  configSettingContractBandwidthV0(value: ConfigSettingContractBandwidthV0): ConfigSettingEntry;
  configSettingContractCostParamsCpuInstructions(value: ContractCostParams): ConfigSettingEntry;
  configSettingContractCostParamsMemoryBytes(value: ContractCostParams): ConfigSettingEntry;
  configSettingContractDataKeySizeBytes(value: Uint32): ConfigSettingEntry;
  configSettingContractDataEntrySizeBytes(value: Uint32): ConfigSettingEntry;
  configSettingStateArchival(value: StateArchivalSettings): ConfigSettingEntry;
  configSettingContractExecutionLanes(value: ConfigSettingContractExecutionLanesV0): ConfigSettingEntry;
  configSettingLiveSorobanStateSizeWindow(value: Uint64[]): ConfigSettingEntry;
  configSettingEvictionIterator(value: EvictionIterator): ConfigSettingEntry;
  configSettingContractParallelComputeV0(value: ConfigSettingContractParallelComputeV0): ConfigSettingEntry;
  configSettingContractLedgerCostExtV0(value: ConfigSettingContractLedgerCostExtV0): ConfigSettingEntry;
  configSettingScpTiming(value: ConfigSettingScpTiming): ConfigSettingEntry;
  read(io: Buffer): ConfigSettingEntry;
  write(value: ConfigSettingEntry, io: Buffer): void;
  isValid(value: ConfigSettingEntry): boolean;
  toXDR(value: ConfigSettingEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigSettingEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigSettingEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScEnvMetaKind {
  readonly name: 'scEnvMetaKindInterfaceVersion';
  readonly value: 0;
}
const _ScEnvMetaKind = createCompatEnum({
  codec: modern.SCEnvMetaKind,
  members: [
    { compat: 'scEnvMetaKindInterfaceVersion', modern: 'ScEnvMetaKindInterfaceVersion', value: 0 },
  ],
});
export const ScEnvMetaKind = _ScEnvMetaKind as unknown as {
  scEnvMetaKindInterfaceVersion(): ScEnvMetaKind;
};

export interface ScEnvMetaEntryInterfaceVersion {
  protocol(value?: Uint32): Uint32;
  preRelease(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScEnvMetaEntryInterfaceVersion = createCompatStruct({
  codec: modern.SCEnvMetaEntryInterfaceVersion,
  fields: [
    { name: 'protocol', modernName: 'protocol', convert: id },
    { name: 'preRelease', modernName: 'preRelease', convert: id },
  ],
});
export const ScEnvMetaEntryInterfaceVersion = _ScEnvMetaEntryInterfaceVersion as unknown as {
  new(attributes: { protocol: Uint32; preRelease: Uint32 }): ScEnvMetaEntryInterfaceVersion;
  read(io: Buffer): ScEnvMetaEntryInterfaceVersion;
  write(value: ScEnvMetaEntryInterfaceVersion, io: Buffer): void;
  isValid(value: ScEnvMetaEntryInterfaceVersion): boolean;
  toXDR(value: ScEnvMetaEntryInterfaceVersion): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScEnvMetaEntryInterfaceVersion;
  fromXDR(input: string, format: 'hex' | 'base64'): ScEnvMetaEntryInterfaceVersion;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScEnvMetaEntry {
  switch(): ScEnvMetaKind;
  interfaceVersion(value?: ScEnvMetaEntryInterfaceVersion): ScEnvMetaEntryInterfaceVersion;
  value(): ScEnvMetaEntryInterfaceVersion;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScEnvMetaEntry = createCompatUnion({
  codec: modern.SCEnvMetaEntry,
  switchEnum: _ScEnvMetaKind,
  arms: [
    { switchValues: ['scEnvMetaKindInterfaceVersion'], modern: 'ScEnvMetaKindInterfaceVersion', arm: 'interfaceVersion', convert: id },
  ],
});
export const ScEnvMetaEntry = _ScEnvMetaEntry as unknown as {
  scEnvMetaKindInterfaceVersion(value: ScEnvMetaEntryInterfaceVersion): ScEnvMetaEntry;
  read(io: Buffer): ScEnvMetaEntry;
  write(value: ScEnvMetaEntry, io: Buffer): void;
  isValid(value: ScEnvMetaEntry): boolean;
  toXDR(value: ScEnvMetaEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScEnvMetaEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ScEnvMetaEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScMetaV0 {
  key(value?: string | Buffer): string | Buffer;
  val(value?: string | Buffer): string | Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScMetaV0 = createCompatStruct({
  codec: modern.SCMetaV0,
  fields: [
    { name: 'key', modernName: 'key', convert: id },
    { name: 'val', modernName: 'val', convert: id },
  ],
});
export const ScMetaV0 = _ScMetaV0 as unknown as {
  new(attributes: { key: string | Buffer; val: string | Buffer }): ScMetaV0;
  read(io: Buffer): ScMetaV0;
  write(value: ScMetaV0, io: Buffer): void;
  isValid(value: ScMetaV0): boolean;
  toXDR(value: ScMetaV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScMetaV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScMetaV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScMetaKind {
  readonly name: 'scMetaV0';
  readonly value: 0;
}
const _ScMetaKind = createCompatEnum({
  codec: modern.SCMetaKind,
  members: [
    { compat: 'scMetaV0', modern: 'ScMetaV0', value: 0 },
  ],
});
export const ScMetaKind = _ScMetaKind as unknown as {
  scMetaV0(): ScMetaKind;
};

export interface ScMetaEntry {
  switch(): ScMetaKind;
  v0(value?: ScMetaV0): ScMetaV0;
  value(): ScMetaV0;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScMetaEntry = createCompatUnion({
  codec: modern.SCMetaEntry,
  switchEnum: _ScMetaKind,
  arms: [
    { switchValues: ['scMetaV0'], modern: 'ScMetaV0', arm: 'v0', convert: structConverter(_ScMetaV0) },
  ],
});
export const ScMetaEntry = _ScMetaEntry as unknown as {
  scMetaV0(value: ScMetaV0): ScMetaEntry;
  read(io: Buffer): ScMetaEntry;
  write(value: ScMetaEntry, io: Buffer): void;
  isValid(value: ScMetaEntry): boolean;
  toXDR(value: ScMetaEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScMetaEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ScMetaEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const SC_SPEC_DOC_LIMIT = 1024;

export interface ScSpecType {
  readonly name: 'scSpecTypeVal' | 'scSpecTypeBool' | 'scSpecTypeVoid' | 'scSpecTypeError' | 'scSpecTypeU32' | 'scSpecTypeI32' | 'scSpecTypeU64' | 'scSpecTypeI64' | 'scSpecTypeTimepoint' | 'scSpecTypeDuration' | 'scSpecTypeU128' | 'scSpecTypeI128' | 'scSpecTypeU256' | 'scSpecTypeI256' | 'scSpecTypeBytes' | 'scSpecTypeString' | 'scSpecTypeSymbol' | 'scSpecTypeAddress' | 'scSpecTypeMuxedAddress' | 'scSpecTypeOption' | 'scSpecTypeResult' | 'scSpecTypeVec' | 'scSpecTypeMap' | 'scSpecTypeTuple' | 'scSpecTypeBytesN' | 'scSpecTypeUdt';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 16 | 17 | 19 | 20 | 1000 | 1001 | 1002 | 1004 | 1005 | 1006 | 2000;
}
const _ScSpecType = createCompatEnum({
  codec: modern.SCSpecType,
  members: [
    { compat: 'scSpecTypeVal', modern: 'Val', value: 0 },
    { compat: 'scSpecTypeBool', modern: 'Bool', value: 1 },
    { compat: 'scSpecTypeVoid', modern: 'Void', value: 2 },
    { compat: 'scSpecTypeError', modern: 'Error', value: 3 },
    { compat: 'scSpecTypeU32', modern: 'U32', value: 4 },
    { compat: 'scSpecTypeI32', modern: 'I32', value: 5 },
    { compat: 'scSpecTypeU64', modern: 'U64', value: 6 },
    { compat: 'scSpecTypeI64', modern: 'I64', value: 7 },
    { compat: 'scSpecTypeTimepoint', modern: 'Timepoint', value: 8 },
    { compat: 'scSpecTypeDuration', modern: 'Duration', value: 9 },
    { compat: 'scSpecTypeU128', modern: 'U128', value: 10 },
    { compat: 'scSpecTypeI128', modern: 'I128', value: 11 },
    { compat: 'scSpecTypeU256', modern: 'U256', value: 12 },
    { compat: 'scSpecTypeI256', modern: 'I256', value: 13 },
    { compat: 'scSpecTypeBytes', modern: 'Bytes', value: 14 },
    { compat: 'scSpecTypeString', modern: 'String', value: 16 },
    { compat: 'scSpecTypeSymbol', modern: 'Symbol', value: 17 },
    { compat: 'scSpecTypeAddress', modern: 'Address', value: 19 },
    { compat: 'scSpecTypeMuxedAddress', modern: 'MuxedAddress', value: 20 },
    { compat: 'scSpecTypeOption', modern: 'Option', value: 1000 },
    { compat: 'scSpecTypeResult', modern: 'Result', value: 1001 },
    { compat: 'scSpecTypeVec', modern: 'Vec', value: 1002 },
    { compat: 'scSpecTypeMap', modern: 'Map', value: 1004 },
    { compat: 'scSpecTypeTuple', modern: 'Tuple', value: 1005 },
    { compat: 'scSpecTypeBytesN', modern: 'BytesN', value: 1006 },
    { compat: 'scSpecTypeUdt', modern: 'Udt', value: 2000 },
  ],
});
export const ScSpecType = _ScSpecType as unknown as {
  scSpecTypeVal(): ScSpecType;
  scSpecTypeBool(): ScSpecType;
  scSpecTypeVoid(): ScSpecType;
  scSpecTypeError(): ScSpecType;
  scSpecTypeU32(): ScSpecType;
  scSpecTypeI32(): ScSpecType;
  scSpecTypeU64(): ScSpecType;
  scSpecTypeI64(): ScSpecType;
  scSpecTypeTimepoint(): ScSpecType;
  scSpecTypeDuration(): ScSpecType;
  scSpecTypeU128(): ScSpecType;
  scSpecTypeI128(): ScSpecType;
  scSpecTypeU256(): ScSpecType;
  scSpecTypeI256(): ScSpecType;
  scSpecTypeBytes(): ScSpecType;
  scSpecTypeString(): ScSpecType;
  scSpecTypeSymbol(): ScSpecType;
  scSpecTypeAddress(): ScSpecType;
  scSpecTypeMuxedAddress(): ScSpecType;
  scSpecTypeOption(): ScSpecType;
  scSpecTypeResult(): ScSpecType;
  scSpecTypeVec(): ScSpecType;
  scSpecTypeMap(): ScSpecType;
  scSpecTypeTuple(): ScSpecType;
  scSpecTypeBytesN(): ScSpecType;
  scSpecTypeUdt(): ScSpecType;
};

export interface ScSpecTypeResult {
  okType(value?: ScSpecTypeDef): ScSpecTypeDef;
  errorType(value?: ScSpecTypeDef): ScSpecTypeDef;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecTypeResult = createCompatStruct({
  codec: modern.SCSpecTypeResult,
  fields: [
    { name: 'okType', modernName: 'okType', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
    { name: 'errorType', modernName: 'errorType', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
  ],
});
export const ScSpecTypeResult = _ScSpecTypeResult as unknown as {
  new(attributes: { okType: ScSpecTypeDef; errorType: ScSpecTypeDef }): ScSpecTypeResult;
  read(io: Buffer): ScSpecTypeResult;
  write(value: ScSpecTypeResult, io: Buffer): void;
  isValid(value: ScSpecTypeResult): boolean;
  toXDR(value: ScSpecTypeResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecTypeResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecTypeResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecTypeVec {
  elementType(value?: ScSpecTypeDef): ScSpecTypeDef;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecTypeVec = createCompatStruct({
  codec: modern.SCSpecTypeVec,
  fields: [
    { name: 'elementType', modernName: 'elementType', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
  ],
});
export const ScSpecTypeVec = _ScSpecTypeVec as unknown as {
  new(attributes: { elementType: ScSpecTypeDef }): ScSpecTypeVec;
  read(io: Buffer): ScSpecTypeVec;
  write(value: ScSpecTypeVec, io: Buffer): void;
  isValid(value: ScSpecTypeVec): boolean;
  toXDR(value: ScSpecTypeVec): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecTypeVec;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecTypeVec;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecTypeMap {
  keyType(value?: ScSpecTypeDef): ScSpecTypeDef;
  valueType(value?: ScSpecTypeDef): ScSpecTypeDef;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecTypeMap = createCompatStruct({
  codec: modern.SCSpecTypeMap,
  fields: [
    { name: 'keyType', modernName: 'keyType', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
    { name: 'valueType', modernName: 'valueType', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
  ],
});
export const ScSpecTypeMap = _ScSpecTypeMap as unknown as {
  new(attributes: { keyType: ScSpecTypeDef; valueType: ScSpecTypeDef }): ScSpecTypeMap;
  read(io: Buffer): ScSpecTypeMap;
  write(value: ScSpecTypeMap, io: Buffer): void;
  isValid(value: ScSpecTypeMap): boolean;
  toXDR(value: ScSpecTypeMap): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecTypeMap;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecTypeMap;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecTypeTuple {
  valueTypes(value?: ScSpecTypeDef[]): ScSpecTypeDef[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecTypeTuple = createCompatStruct({
  codec: modern.SCSpecTypeTuple,
  fields: [
    { name: 'valueTypes', modernName: 'valueTypes', convert: arrayConverter(lazyConverter(() => unionConverter(_ScSpecTypeDef))) },
  ],
});
export const ScSpecTypeTuple = _ScSpecTypeTuple as unknown as {
  new(attributes: { valueTypes: ScSpecTypeDef[] }): ScSpecTypeTuple;
  read(io: Buffer): ScSpecTypeTuple;
  write(value: ScSpecTypeTuple, io: Buffer): void;
  isValid(value: ScSpecTypeTuple): boolean;
  toXDR(value: ScSpecTypeTuple): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecTypeTuple;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecTypeTuple;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecTypeBytesN {
  n(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecTypeBytesN = createCompatStruct({
  codec: modern.SCSpecTypeBytesN,
  fields: [
    { name: 'n', modernName: 'n', convert: id },
  ],
});
export const ScSpecTypeBytesN = _ScSpecTypeBytesN as unknown as {
  new(attributes: { n: Uint32 }): ScSpecTypeBytesN;
  read(io: Buffer): ScSpecTypeBytesN;
  write(value: ScSpecTypeBytesN, io: Buffer): void;
  isValid(value: ScSpecTypeBytesN): boolean;
  toXDR(value: ScSpecTypeBytesN): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecTypeBytesN;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecTypeBytesN;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecTypeUdt {
  name(value?: string | Buffer): string | Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecTypeUdt = createCompatStruct({
  codec: modern.SCSpecTypeUDT,
  fields: [
    { name: 'name', modernName: 'name', convert: id },
  ],
});
export const ScSpecTypeUdt = _ScSpecTypeUdt as unknown as {
  new(attributes: { name: string | Buffer }): ScSpecTypeUdt;
  read(io: Buffer): ScSpecTypeUdt;
  write(value: ScSpecTypeUdt, io: Buffer): void;
  isValid(value: ScSpecTypeUdt): boolean;
  toXDR(value: ScSpecTypeUdt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecTypeUdt;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecTypeUdt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecTypeDef {
  switch(): ScSpecType;
  option(value?: ScSpecTypeOption): ScSpecTypeOption;
  result(value?: ScSpecTypeResult): ScSpecTypeResult;
  vec(value?: ScSpecTypeVec): ScSpecTypeVec;
  map(value?: ScSpecTypeMap): ScSpecTypeMap;
  tuple(value?: ScSpecTypeTuple): ScSpecTypeTuple;
  bytesN(value?: ScSpecTypeBytesN): ScSpecTypeBytesN;
  udt(value?: ScSpecTypeUdt): ScSpecTypeUdt;
  value(): ScSpecTypeOption | ScSpecTypeResult | ScSpecTypeVec | ScSpecTypeMap | ScSpecTypeTuple | ScSpecTypeBytesN | ScSpecTypeUdt | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecTypeDef = createCompatUnion({
  codec: modern.SCSpecTypeDef,
  switchEnum: _ScSpecType,
  arms: [
    { switchValues: ['scSpecTypeVal', 'scSpecTypeBool', 'scSpecTypeVoid', 'scSpecTypeError', 'scSpecTypeU32', 'scSpecTypeI32', 'scSpecTypeU64', 'scSpecTypeI64', 'scSpecTypeTimepoint', 'scSpecTypeDuration', 'scSpecTypeU128', 'scSpecTypeI128', 'scSpecTypeU256', 'scSpecTypeI256', 'scSpecTypeBytes', 'scSpecTypeString', 'scSpecTypeSymbol', 'scSpecTypeAddress', 'scSpecTypeMuxedAddress'], modern: 'Val' },
    { switchValues: ['scSpecTypeOption'], modern: 'Option', arm: 'option', convert: lazyConverter(() => structConverter(_ScSpecTypeOption)) },
    { switchValues: ['scSpecTypeResult'], modern: 'Result', arm: 'result', convert: structConverter(_ScSpecTypeResult) },
    { switchValues: ['scSpecTypeVec'], modern: 'Vec', arm: 'vec', convert: structConverter(_ScSpecTypeVec) },
    { switchValues: ['scSpecTypeMap'], modern: 'Map', arm: 'map', convert: structConverter(_ScSpecTypeMap) },
    { switchValues: ['scSpecTypeTuple'], modern: 'Tuple', arm: 'tuple', convert: structConverter(_ScSpecTypeTuple) },
    { switchValues: ['scSpecTypeBytesN'], modern: 'BytesN', arm: 'bytesN', convert: structConverter(_ScSpecTypeBytesN) },
    { switchValues: ['scSpecTypeUdt'], modern: 'Udt', arm: 'udt', convert: structConverter(_ScSpecTypeUdt) },
  ],
});
export const ScSpecTypeDef = _ScSpecTypeDef as unknown as {
  scSpecTypeVal(): ScSpecTypeDef;
  scSpecTypeBool(): ScSpecTypeDef;
  scSpecTypeVoid(): ScSpecTypeDef;
  scSpecTypeError(): ScSpecTypeDef;
  scSpecTypeU32(): ScSpecTypeDef;
  scSpecTypeI32(): ScSpecTypeDef;
  scSpecTypeU64(): ScSpecTypeDef;
  scSpecTypeI64(): ScSpecTypeDef;
  scSpecTypeTimepoint(): ScSpecTypeDef;
  scSpecTypeDuration(): ScSpecTypeDef;
  scSpecTypeU128(): ScSpecTypeDef;
  scSpecTypeI128(): ScSpecTypeDef;
  scSpecTypeU256(): ScSpecTypeDef;
  scSpecTypeI256(): ScSpecTypeDef;
  scSpecTypeBytes(): ScSpecTypeDef;
  scSpecTypeString(): ScSpecTypeDef;
  scSpecTypeSymbol(): ScSpecTypeDef;
  scSpecTypeAddress(): ScSpecTypeDef;
  scSpecTypeMuxedAddress(): ScSpecTypeDef;
  scSpecTypeOption(value: ScSpecTypeOption): ScSpecTypeDef;
  scSpecTypeResult(value: ScSpecTypeResult): ScSpecTypeDef;
  scSpecTypeVec(value: ScSpecTypeVec): ScSpecTypeDef;
  scSpecTypeMap(value: ScSpecTypeMap): ScSpecTypeDef;
  scSpecTypeTuple(value: ScSpecTypeTuple): ScSpecTypeDef;
  scSpecTypeBytesN(value: ScSpecTypeBytesN): ScSpecTypeDef;
  scSpecTypeUdt(value: ScSpecTypeUdt): ScSpecTypeDef;
  read(io: Buffer): ScSpecTypeDef;
  write(value: ScSpecTypeDef, io: Buffer): void;
  isValid(value: ScSpecTypeDef): boolean;
  toXDR(value: ScSpecTypeDef): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecTypeDef;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecTypeDef;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecTypeOption {
  valueType(value?: ScSpecTypeDef): ScSpecTypeDef;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecTypeOption = createCompatStruct({
  codec: modern.SCSpecTypeOption,
  fields: [
    { name: 'valueType', modernName: 'valueType', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
  ],
});
export const ScSpecTypeOption = _ScSpecTypeOption as unknown as {
  new(attributes: { valueType: ScSpecTypeDef }): ScSpecTypeOption;
  read(io: Buffer): ScSpecTypeOption;
  write(value: ScSpecTypeOption, io: Buffer): void;
  isValid(value: ScSpecTypeOption): boolean;
  toXDR(value: ScSpecTypeOption): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecTypeOption;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecTypeOption;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtStructFieldV0 {
  doc(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  type(value?: ScSpecTypeDef): ScSpecTypeDef;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtStructFieldV0 = createCompatStruct({
  codec: modern.SCSpecUDTStructFieldV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'type', modernName: 'type', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
  ],
});
export const ScSpecUdtStructFieldV0 = _ScSpecUdtStructFieldV0 as unknown as {
  new(attributes: { doc: string | Buffer; name: string | Buffer; type: ScSpecTypeDef }): ScSpecUdtStructFieldV0;
  read(io: Buffer): ScSpecUdtStructFieldV0;
  write(value: ScSpecUdtStructFieldV0, io: Buffer): void;
  isValid(value: ScSpecUdtStructFieldV0): boolean;
  toXDR(value: ScSpecUdtStructFieldV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtStructFieldV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtStructFieldV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtStructV0 {
  doc(value?: string | Buffer): string | Buffer;
  lib(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  fields(value?: ScSpecUdtStructFieldV0[]): ScSpecUdtStructFieldV0[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtStructV0 = createCompatStruct({
  codec: modern.SCSpecUDTStructV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'lib', modernName: 'lib', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'fields', modernName: 'fields', convert: arrayConverter(structConverter(_ScSpecUdtStructFieldV0)) },
  ],
});
export const ScSpecUdtStructV0 = _ScSpecUdtStructV0 as unknown as {
  new(attributes: { doc: string | Buffer; lib: string | Buffer; name: string | Buffer; fields: ScSpecUdtStructFieldV0[] }): ScSpecUdtStructV0;
  read(io: Buffer): ScSpecUdtStructV0;
  write(value: ScSpecUdtStructV0, io: Buffer): void;
  isValid(value: ScSpecUdtStructV0): boolean;
  toXDR(value: ScSpecUdtStructV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtStructV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtStructV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtUnionCaseVoidV0 {
  doc(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtUnionCaseVoidV0 = createCompatStruct({
  codec: modern.SCSpecUDTUnionCaseVoidV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'name', modernName: 'name', convert: id },
  ],
});
export const ScSpecUdtUnionCaseVoidV0 = _ScSpecUdtUnionCaseVoidV0 as unknown as {
  new(attributes: { doc: string | Buffer; name: string | Buffer }): ScSpecUdtUnionCaseVoidV0;
  read(io: Buffer): ScSpecUdtUnionCaseVoidV0;
  write(value: ScSpecUdtUnionCaseVoidV0, io: Buffer): void;
  isValid(value: ScSpecUdtUnionCaseVoidV0): boolean;
  toXDR(value: ScSpecUdtUnionCaseVoidV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtUnionCaseVoidV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtUnionCaseVoidV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtUnionCaseTupleV0 {
  doc(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  type(value?: ScSpecTypeDef[]): ScSpecTypeDef[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtUnionCaseTupleV0 = createCompatStruct({
  codec: modern.SCSpecUDTUnionCaseTupleV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'type', modernName: 'type', convert: arrayConverter(lazyConverter(() => unionConverter(_ScSpecTypeDef))) },
  ],
});
export const ScSpecUdtUnionCaseTupleV0 = _ScSpecUdtUnionCaseTupleV0 as unknown as {
  new(attributes: { doc: string | Buffer; name: string | Buffer; type: ScSpecTypeDef[] }): ScSpecUdtUnionCaseTupleV0;
  read(io: Buffer): ScSpecUdtUnionCaseTupleV0;
  write(value: ScSpecUdtUnionCaseTupleV0, io: Buffer): void;
  isValid(value: ScSpecUdtUnionCaseTupleV0): boolean;
  toXDR(value: ScSpecUdtUnionCaseTupleV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtUnionCaseTupleV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtUnionCaseTupleV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtUnionCaseV0Kind {
  readonly name: 'scSpecUdtUnionCaseVoidV0' | 'scSpecUdtUnionCaseTupleV0';
  readonly value: 0 | 1;
}
const _ScSpecUdtUnionCaseV0Kind = createCompatEnum({
  codec: modern.SCSpecUDTUnionCaseV0Kind,
  members: [
    { compat: 'scSpecUdtUnionCaseVoidV0', modern: 'VoidV0', value: 0 },
    { compat: 'scSpecUdtUnionCaseTupleV0', modern: 'TupleV0', value: 1 },
  ],
});
export const ScSpecUdtUnionCaseV0Kind = _ScSpecUdtUnionCaseV0Kind as unknown as {
  scSpecUdtUnionCaseVoidV0(): ScSpecUdtUnionCaseV0Kind;
  scSpecUdtUnionCaseTupleV0(): ScSpecUdtUnionCaseV0Kind;
};

export interface ScSpecUdtUnionCaseV0 {
  switch(): ScSpecUdtUnionCaseV0Kind;
  voidCase(value?: ScSpecUdtUnionCaseVoidV0): ScSpecUdtUnionCaseVoidV0;
  tupleCase(value?: ScSpecUdtUnionCaseTupleV0): ScSpecUdtUnionCaseTupleV0;
  value(): ScSpecUdtUnionCaseVoidV0 | ScSpecUdtUnionCaseTupleV0;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtUnionCaseV0 = createCompatUnion({
  codec: modern.SCSpecUDTUnionCaseV0,
  switchEnum: _ScSpecUdtUnionCaseV0Kind,
  arms: [
    { switchValues: ['scSpecUdtUnionCaseVoidV0'], modern: 'VoidV0', arm: 'voidCase', convert: structConverter(_ScSpecUdtUnionCaseVoidV0) },
    { switchValues: ['scSpecUdtUnionCaseTupleV0'], modern: 'TupleV0', arm: 'tupleCase', convert: structConverter(_ScSpecUdtUnionCaseTupleV0) },
  ],
});
export const ScSpecUdtUnionCaseV0 = _ScSpecUdtUnionCaseV0 as unknown as {
  scSpecUdtUnionCaseVoidV0(value: ScSpecUdtUnionCaseVoidV0): ScSpecUdtUnionCaseV0;
  scSpecUdtUnionCaseTupleV0(value: ScSpecUdtUnionCaseTupleV0): ScSpecUdtUnionCaseV0;
  read(io: Buffer): ScSpecUdtUnionCaseV0;
  write(value: ScSpecUdtUnionCaseV0, io: Buffer): void;
  isValid(value: ScSpecUdtUnionCaseV0): boolean;
  toXDR(value: ScSpecUdtUnionCaseV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtUnionCaseV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtUnionCaseV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtUnionV0 {
  doc(value?: string | Buffer): string | Buffer;
  lib(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  cases(value?: ScSpecUdtUnionCaseV0[]): ScSpecUdtUnionCaseV0[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtUnionV0 = createCompatStruct({
  codec: modern.SCSpecUDTUnionV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'lib', modernName: 'lib', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'cases', modernName: 'cases', convert: arrayConverter(unionConverter(_ScSpecUdtUnionCaseV0)) },
  ],
});
export const ScSpecUdtUnionV0 = _ScSpecUdtUnionV0 as unknown as {
  new(attributes: { doc: string | Buffer; lib: string | Buffer; name: string | Buffer; cases: ScSpecUdtUnionCaseV0[] }): ScSpecUdtUnionV0;
  read(io: Buffer): ScSpecUdtUnionV0;
  write(value: ScSpecUdtUnionV0, io: Buffer): void;
  isValid(value: ScSpecUdtUnionV0): boolean;
  toXDR(value: ScSpecUdtUnionV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtUnionV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtUnionV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtEnumCaseV0 {
  doc(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  value(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtEnumCaseV0 = createCompatStruct({
  codec: modern.SCSpecUDTEnumCaseV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'value', modernName: 'value', convert: id },
  ],
});
export const ScSpecUdtEnumCaseV0 = _ScSpecUdtEnumCaseV0 as unknown as {
  new(attributes: { doc: string | Buffer; name: string | Buffer; value: Uint32 }): ScSpecUdtEnumCaseV0;
  read(io: Buffer): ScSpecUdtEnumCaseV0;
  write(value: ScSpecUdtEnumCaseV0, io: Buffer): void;
  isValid(value: ScSpecUdtEnumCaseV0): boolean;
  toXDR(value: ScSpecUdtEnumCaseV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtEnumCaseV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtEnumCaseV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtEnumV0 {
  doc(value?: string | Buffer): string | Buffer;
  lib(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  cases(value?: ScSpecUdtEnumCaseV0[]): ScSpecUdtEnumCaseV0[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtEnumV0 = createCompatStruct({
  codec: modern.SCSpecUDTEnumV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'lib', modernName: 'lib', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'cases', modernName: 'cases', convert: arrayConverter(structConverter(_ScSpecUdtEnumCaseV0)) },
  ],
});
export const ScSpecUdtEnumV0 = _ScSpecUdtEnumV0 as unknown as {
  new(attributes: { doc: string | Buffer; lib: string | Buffer; name: string | Buffer; cases: ScSpecUdtEnumCaseV0[] }): ScSpecUdtEnumV0;
  read(io: Buffer): ScSpecUdtEnumV0;
  write(value: ScSpecUdtEnumV0, io: Buffer): void;
  isValid(value: ScSpecUdtEnumV0): boolean;
  toXDR(value: ScSpecUdtEnumV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtEnumV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtEnumV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtErrorEnumCaseV0 {
  doc(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  value(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtErrorEnumCaseV0 = createCompatStruct({
  codec: modern.SCSpecUDTErrorEnumCaseV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'value', modernName: 'value', convert: id },
  ],
});
export const ScSpecUdtErrorEnumCaseV0 = _ScSpecUdtErrorEnumCaseV0 as unknown as {
  new(attributes: { doc: string | Buffer; name: string | Buffer; value: Uint32 }): ScSpecUdtErrorEnumCaseV0;
  read(io: Buffer): ScSpecUdtErrorEnumCaseV0;
  write(value: ScSpecUdtErrorEnumCaseV0, io: Buffer): void;
  isValid(value: ScSpecUdtErrorEnumCaseV0): boolean;
  toXDR(value: ScSpecUdtErrorEnumCaseV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtErrorEnumCaseV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtErrorEnumCaseV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecUdtErrorEnumV0 {
  doc(value?: string | Buffer): string | Buffer;
  lib(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  cases(value?: ScSpecUdtErrorEnumCaseV0[]): ScSpecUdtErrorEnumCaseV0[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecUdtErrorEnumV0 = createCompatStruct({
  codec: modern.SCSpecUDTErrorEnumV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'lib', modernName: 'lib', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'cases', modernName: 'cases', convert: arrayConverter(structConverter(_ScSpecUdtErrorEnumCaseV0)) },
  ],
});
export const ScSpecUdtErrorEnumV0 = _ScSpecUdtErrorEnumV0 as unknown as {
  new(attributes: { doc: string | Buffer; lib: string | Buffer; name: string | Buffer; cases: ScSpecUdtErrorEnumCaseV0[] }): ScSpecUdtErrorEnumV0;
  read(io: Buffer): ScSpecUdtErrorEnumV0;
  write(value: ScSpecUdtErrorEnumV0, io: Buffer): void;
  isValid(value: ScSpecUdtErrorEnumV0): boolean;
  toXDR(value: ScSpecUdtErrorEnumV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecUdtErrorEnumV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecUdtErrorEnumV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecFunctionInputV0 {
  doc(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  type(value?: ScSpecTypeDef): ScSpecTypeDef;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecFunctionInputV0 = createCompatStruct({
  codec: modern.SCSpecFunctionInputV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'type', modernName: 'type', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
  ],
});
export const ScSpecFunctionInputV0 = _ScSpecFunctionInputV0 as unknown as {
  new(attributes: { doc: string | Buffer; name: string | Buffer; type: ScSpecTypeDef }): ScSpecFunctionInputV0;
  read(io: Buffer): ScSpecFunctionInputV0;
  write(value: ScSpecFunctionInputV0, io: Buffer): void;
  isValid(value: ScSpecFunctionInputV0): boolean;
  toXDR(value: ScSpecFunctionInputV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecFunctionInputV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecFunctionInputV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const SCSYMBOL_LIMIT = 32;

export type ScSymbol = string | Buffer;
export const ScSymbol = createCompatTypedef({ codec: modern.SCSymbol, convert: id });

export interface ScSpecFunctionV0 {
  doc(value?: string | Buffer): string | Buffer;
  name(value?: ScSymbol): ScSymbol;
  inputs(value?: ScSpecFunctionInputV0[]): ScSpecFunctionInputV0[];
  outputs(value?: ScSpecTypeDef[]): ScSpecTypeDef[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecFunctionV0 = createCompatStruct({
  codec: modern.SCSpecFunctionV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'inputs', modernName: 'inputs', convert: arrayConverter(structConverter(_ScSpecFunctionInputV0)) },
    { name: 'outputs', modernName: 'outputs', convert: arrayConverter(lazyConverter(() => unionConverter(_ScSpecTypeDef))) },
  ],
});
export const ScSpecFunctionV0 = _ScSpecFunctionV0 as unknown as {
  new(attributes: { doc: string | Buffer; name: ScSymbol; inputs: ScSpecFunctionInputV0[]; outputs: ScSpecTypeDef[] }): ScSpecFunctionV0;
  read(io: Buffer): ScSpecFunctionV0;
  write(value: ScSpecFunctionV0, io: Buffer): void;
  isValid(value: ScSpecFunctionV0): boolean;
  toXDR(value: ScSpecFunctionV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecFunctionV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecFunctionV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecEventParamLocationV0 {
  readonly name: 'scSpecEventParamLocationData' | 'scSpecEventParamLocationTopicList';
  readonly value: 0 | 1;
}
const _ScSpecEventParamLocationV0 = createCompatEnum({
  codec: modern.SCSpecEventParamLocationV0,
  members: [
    { compat: 'scSpecEventParamLocationData', modern: 'Data', value: 0 },
    { compat: 'scSpecEventParamLocationTopicList', modern: 'TopicList', value: 1 },
  ],
});
export const ScSpecEventParamLocationV0 = _ScSpecEventParamLocationV0 as unknown as {
  scSpecEventParamLocationData(): ScSpecEventParamLocationV0;
  scSpecEventParamLocationTopicList(): ScSpecEventParamLocationV0;
};

export interface ScSpecEventParamV0 {
  doc(value?: string | Buffer): string | Buffer;
  name(value?: string | Buffer): string | Buffer;
  type(value?: ScSpecTypeDef): ScSpecTypeDef;
  location(value?: ScSpecEventParamLocationV0): ScSpecEventParamLocationV0;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecEventParamV0 = createCompatStruct({
  codec: modern.SCSpecEventParamV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'type', modernName: 'type', convert: lazyConverter(() => unionConverter(_ScSpecTypeDef)) },
    { name: 'location', modernName: 'location', convert: enumConverter(_ScSpecEventParamLocationV0) },
  ],
});
export const ScSpecEventParamV0 = _ScSpecEventParamV0 as unknown as {
  new(attributes: { doc: string | Buffer; name: string | Buffer; type: ScSpecTypeDef; location: ScSpecEventParamLocationV0 }): ScSpecEventParamV0;
  read(io: Buffer): ScSpecEventParamV0;
  write(value: ScSpecEventParamV0, io: Buffer): void;
  isValid(value: ScSpecEventParamV0): boolean;
  toXDR(value: ScSpecEventParamV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecEventParamV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecEventParamV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecEventDataFormat {
  readonly name: 'scSpecEventDataFormatSingleValue' | 'scSpecEventDataFormatVec' | 'scSpecEventDataFormatMap';
  readonly value: 0 | 1 | 2;
}
const _ScSpecEventDataFormat = createCompatEnum({
  codec: modern.SCSpecEventDataFormat,
  members: [
    { compat: 'scSpecEventDataFormatSingleValue', modern: 'SingleValue', value: 0 },
    { compat: 'scSpecEventDataFormatVec', modern: 'Vec', value: 1 },
    { compat: 'scSpecEventDataFormatMap', modern: 'Map', value: 2 },
  ],
});
export const ScSpecEventDataFormat = _ScSpecEventDataFormat as unknown as {
  scSpecEventDataFormatSingleValue(): ScSpecEventDataFormat;
  scSpecEventDataFormatVec(): ScSpecEventDataFormat;
  scSpecEventDataFormatMap(): ScSpecEventDataFormat;
};

export interface ScSpecEventV0 {
  doc(value?: string | Buffer): string | Buffer;
  lib(value?: string | Buffer): string | Buffer;
  name(value?: ScSymbol): ScSymbol;
  prefixTopics(value?: ScSymbol[]): ScSymbol[];
  params(value?: ScSpecEventParamV0[]): ScSpecEventParamV0[];
  dataFormat(value?: ScSpecEventDataFormat): ScSpecEventDataFormat;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecEventV0 = createCompatStruct({
  codec: modern.SCSpecEventV0,
  fields: [
    { name: 'doc', modernName: 'doc', convert: id },
    { name: 'lib', modernName: 'lib', convert: id },
    { name: 'name', modernName: 'name', convert: id },
    { name: 'prefixTopics', modernName: 'prefixTopics', convert: arrayConverter(id) },
    { name: 'params', modernName: 'params', convert: arrayConverter(structConverter(_ScSpecEventParamV0)) },
    { name: 'dataFormat', modernName: 'dataFormat', convert: enumConverter(_ScSpecEventDataFormat) },
  ],
});
export const ScSpecEventV0 = _ScSpecEventV0 as unknown as {
  new(attributes: { doc: string | Buffer; lib: string | Buffer; name: ScSymbol; prefixTopics: ScSymbol[]; params: ScSpecEventParamV0[]; dataFormat: ScSpecEventDataFormat }): ScSpecEventV0;
  read(io: Buffer): ScSpecEventV0;
  write(value: ScSpecEventV0, io: Buffer): void;
  isValid(value: ScSpecEventV0): boolean;
  toXDR(value: ScSpecEventV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecEventV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecEventV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScSpecEntryKind {
  readonly name: 'scSpecEntryFunctionV0' | 'scSpecEntryUdtStructV0' | 'scSpecEntryUdtUnionV0' | 'scSpecEntryUdtEnumV0' | 'scSpecEntryUdtErrorEnumV0' | 'scSpecEntryEventV0';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5;
}
const _ScSpecEntryKind = createCompatEnum({
  codec: modern.SCSpecEntryKind,
  members: [
    { compat: 'scSpecEntryFunctionV0', modern: 'FunctionV0', value: 0 },
    { compat: 'scSpecEntryUdtStructV0', modern: 'UdtStructV0', value: 1 },
    { compat: 'scSpecEntryUdtUnionV0', modern: 'UdtUnionV0', value: 2 },
    { compat: 'scSpecEntryUdtEnumV0', modern: 'UdtEnumV0', value: 3 },
    { compat: 'scSpecEntryUdtErrorEnumV0', modern: 'UdtErrorEnumV0', value: 4 },
    { compat: 'scSpecEntryEventV0', modern: 'EventV0', value: 5 },
  ],
});
export const ScSpecEntryKind = _ScSpecEntryKind as unknown as {
  scSpecEntryFunctionV0(): ScSpecEntryKind;
  scSpecEntryUdtStructV0(): ScSpecEntryKind;
  scSpecEntryUdtUnionV0(): ScSpecEntryKind;
  scSpecEntryUdtEnumV0(): ScSpecEntryKind;
  scSpecEntryUdtErrorEnumV0(): ScSpecEntryKind;
  scSpecEntryEventV0(): ScSpecEntryKind;
};

export interface ScSpecEntry {
  switch(): ScSpecEntryKind;
  functionV0(value?: ScSpecFunctionV0): ScSpecFunctionV0;
  udtStructV0(value?: ScSpecUdtStructV0): ScSpecUdtStructV0;
  udtUnionV0(value?: ScSpecUdtUnionV0): ScSpecUdtUnionV0;
  udtEnumV0(value?: ScSpecUdtEnumV0): ScSpecUdtEnumV0;
  udtErrorEnumV0(value?: ScSpecUdtErrorEnumV0): ScSpecUdtErrorEnumV0;
  eventV0(value?: ScSpecEventV0): ScSpecEventV0;
  value(): ScSpecFunctionV0 | ScSpecUdtStructV0 | ScSpecUdtUnionV0 | ScSpecUdtEnumV0 | ScSpecUdtErrorEnumV0 | ScSpecEventV0;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScSpecEntry = createCompatUnion({
  codec: modern.SCSpecEntry,
  switchEnum: _ScSpecEntryKind,
  arms: [
    { switchValues: ['scSpecEntryFunctionV0'], modern: 'FunctionV0', arm: 'functionV0', convert: structConverter(_ScSpecFunctionV0) },
    { switchValues: ['scSpecEntryUdtStructV0'], modern: 'UdtStructV0', arm: 'udtStructV0', convert: structConverter(_ScSpecUdtStructV0) },
    { switchValues: ['scSpecEntryUdtUnionV0'], modern: 'UdtUnionV0', arm: 'udtUnionV0', convert: structConverter(_ScSpecUdtUnionV0) },
    { switchValues: ['scSpecEntryUdtEnumV0'], modern: 'UdtEnumV0', arm: 'udtEnumV0', convert: structConverter(_ScSpecUdtEnumV0) },
    { switchValues: ['scSpecEntryUdtErrorEnumV0'], modern: 'UdtErrorEnumV0', arm: 'udtErrorEnumV0', convert: structConverter(_ScSpecUdtErrorEnumV0) },
    { switchValues: ['scSpecEntryEventV0'], modern: 'EventV0', arm: 'eventV0', convert: structConverter(_ScSpecEventV0) },
  ],
});
export const ScSpecEntry = _ScSpecEntry as unknown as {
  scSpecEntryFunctionV0(value: ScSpecFunctionV0): ScSpecEntry;
  scSpecEntryUdtStructV0(value: ScSpecUdtStructV0): ScSpecEntry;
  scSpecEntryUdtUnionV0(value: ScSpecUdtUnionV0): ScSpecEntry;
  scSpecEntryUdtEnumV0(value: ScSpecUdtEnumV0): ScSpecEntry;
  scSpecEntryUdtErrorEnumV0(value: ScSpecUdtErrorEnumV0): ScSpecEntry;
  scSpecEntryEventV0(value: ScSpecEventV0): ScSpecEntry;
  read(io: Buffer): ScSpecEntry;
  write(value: ScSpecEntry, io: Buffer): void;
  isValid(value: ScSpecEntry): boolean;
  toXDR(value: ScSpecEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScSpecEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ScSpecEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScValType {
  readonly name: 'scvBool' | 'scvVoid' | 'scvError' | 'scvU32' | 'scvI32' | 'scvU64' | 'scvI64' | 'scvTimepoint' | 'scvDuration' | 'scvU128' | 'scvI128' | 'scvU256' | 'scvI256' | 'scvBytes' | 'scvString' | 'scvSymbol' | 'scvVec' | 'scvMap' | 'scvAddress' | 'scvContractInstance' | 'scvLedgerKeyContractInstance' | 'scvLedgerKeyNonce';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21;
}
const _ScValType = createCompatEnum({
  codec: modern.SCValType,
  members: [
    { compat: 'scvBool', modern: 'Bool', value: 0 },
    { compat: 'scvVoid', modern: 'Void', value: 1 },
    { compat: 'scvError', modern: 'Error', value: 2 },
    { compat: 'scvU32', modern: 'U32', value: 3 },
    { compat: 'scvI32', modern: 'I32', value: 4 },
    { compat: 'scvU64', modern: 'U64', value: 5 },
    { compat: 'scvI64', modern: 'I64', value: 6 },
    { compat: 'scvTimepoint', modern: 'Timepoint', value: 7 },
    { compat: 'scvDuration', modern: 'Duration', value: 8 },
    { compat: 'scvU128', modern: 'U128', value: 9 },
    { compat: 'scvI128', modern: 'I128', value: 10 },
    { compat: 'scvU256', modern: 'U256', value: 11 },
    { compat: 'scvI256', modern: 'I256', value: 12 },
    { compat: 'scvBytes', modern: 'Bytes', value: 13 },
    { compat: 'scvString', modern: 'String', value: 14 },
    { compat: 'scvSymbol', modern: 'Symbol', value: 15 },
    { compat: 'scvVec', modern: 'Vec', value: 16 },
    { compat: 'scvMap', modern: 'Map', value: 17 },
    { compat: 'scvAddress', modern: 'Address', value: 18 },
    { compat: 'scvContractInstance', modern: 'ContractInstance', value: 19 },
    { compat: 'scvLedgerKeyContractInstance', modern: 'LedgerKeyContractInstance', value: 20 },
    { compat: 'scvLedgerKeyNonce', modern: 'LedgerKeyNonce', value: 21 },
  ],
});
export const ScValType = _ScValType as unknown as {
  scvBool(): ScValType;
  scvVoid(): ScValType;
  scvError(): ScValType;
  scvU32(): ScValType;
  scvI32(): ScValType;
  scvU64(): ScValType;
  scvI64(): ScValType;
  scvTimepoint(): ScValType;
  scvDuration(): ScValType;
  scvU128(): ScValType;
  scvI128(): ScValType;
  scvU256(): ScValType;
  scvI256(): ScValType;
  scvBytes(): ScValType;
  scvString(): ScValType;
  scvSymbol(): ScValType;
  scvVec(): ScValType;
  scvMap(): ScValType;
  scvAddress(): ScValType;
  scvContractInstance(): ScValType;
  scvLedgerKeyContractInstance(): ScValType;
  scvLedgerKeyNonce(): ScValType;
};

export interface ScErrorType {
  readonly name: 'sceContract' | 'sceWasmVm' | 'sceContext' | 'sceStorage' | 'sceObject' | 'sceCrypto' | 'sceEvents' | 'sceBudget' | 'sceValue' | 'sceAuth';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
}
const _ScErrorType = createCompatEnum({
  codec: modern.SCErrorType,
  members: [
    { compat: 'sceContract', modern: 'Contract', value: 0 },
    { compat: 'sceWasmVm', modern: 'WasmVm', value: 1 },
    { compat: 'sceContext', modern: 'Context', value: 2 },
    { compat: 'sceStorage', modern: 'Storage', value: 3 },
    { compat: 'sceObject', modern: 'Object', value: 4 },
    { compat: 'sceCrypto', modern: 'Crypto', value: 5 },
    { compat: 'sceEvents', modern: 'Events', value: 6 },
    { compat: 'sceBudget', modern: 'Budget', value: 7 },
    { compat: 'sceValue', modern: 'Value', value: 8 },
    { compat: 'sceAuth', modern: 'Auth', value: 9 },
  ],
});
export const ScErrorType = _ScErrorType as unknown as {
  sceContract(): ScErrorType;
  sceWasmVm(): ScErrorType;
  sceContext(): ScErrorType;
  sceStorage(): ScErrorType;
  sceObject(): ScErrorType;
  sceCrypto(): ScErrorType;
  sceEvents(): ScErrorType;
  sceBudget(): ScErrorType;
  sceValue(): ScErrorType;
  sceAuth(): ScErrorType;
};

export interface ScErrorCode {
  readonly name: 'scecArithDomain' | 'scecIndexBounds' | 'scecInvalidInput' | 'scecMissingValue' | 'scecExistingValue' | 'scecExceededLimit' | 'scecInvalidAction' | 'scecInternalError' | 'scecUnexpectedType' | 'scecUnexpectedSize';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
}
const _ScErrorCode = createCompatEnum({
  codec: modern.SCErrorCode,
  members: [
    { compat: 'scecArithDomain', modern: 'ArithDomain', value: 0 },
    { compat: 'scecIndexBounds', modern: 'IndexBounds', value: 1 },
    { compat: 'scecInvalidInput', modern: 'InvalidInput', value: 2 },
    { compat: 'scecMissingValue', modern: 'MissingValue', value: 3 },
    { compat: 'scecExistingValue', modern: 'ExistingValue', value: 4 },
    { compat: 'scecExceededLimit', modern: 'ExceededLimit', value: 5 },
    { compat: 'scecInvalidAction', modern: 'InvalidAction', value: 6 },
    { compat: 'scecInternalError', modern: 'InternalError', value: 7 },
    { compat: 'scecUnexpectedType', modern: 'UnexpectedType', value: 8 },
    { compat: 'scecUnexpectedSize', modern: 'UnexpectedSize', value: 9 },
  ],
});
export const ScErrorCode = _ScErrorCode as unknown as {
  scecArithDomain(): ScErrorCode;
  scecIndexBounds(): ScErrorCode;
  scecInvalidInput(): ScErrorCode;
  scecMissingValue(): ScErrorCode;
  scecExistingValue(): ScErrorCode;
  scecExceededLimit(): ScErrorCode;
  scecInvalidAction(): ScErrorCode;
  scecInternalError(): ScErrorCode;
  scecUnexpectedType(): ScErrorCode;
  scecUnexpectedSize(): ScErrorCode;
};

export interface ScError {
  switch(): ScErrorType;
  contractCode(value?: Uint32): Uint32;
  code(value?: ScErrorCode): ScErrorCode;
  value(): Uint32 | ScErrorCode;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScError = createCompatUnion({
  codec: modern.SCError,
  switchEnum: _ScErrorType,
  arms: [
    { switchValues: ['sceContract'], modern: 'Contract', arm: 'contractCode', convert: id },
    { switchValues: ['sceWasmVm', 'sceContext', 'sceStorage', 'sceObject', 'sceCrypto', 'sceEvents', 'sceBudget', 'sceValue', 'sceAuth'], modern: 'WasmVm', arm: 'code', convert: enumConverter(_ScErrorCode) },
  ],
});
export const ScError = _ScError as unknown as {
  sceContract(value: Uint32): ScError;
  sceWasmVm(value: ScErrorCode): ScError;
  sceContext(value: ScErrorCode): ScError;
  sceStorage(value: ScErrorCode): ScError;
  sceObject(value: ScErrorCode): ScError;
  sceCrypto(value: ScErrorCode): ScError;
  sceEvents(value: ScErrorCode): ScError;
  sceBudget(value: ScErrorCode): ScError;
  sceValue(value: ScErrorCode): ScError;
  sceAuth(value: ScErrorCode): ScError;
  read(io: Buffer): ScError;
  write(value: ScError, io: Buffer): void;
  isValid(value: ScError): boolean;
  toXDR(value: ScError): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScError;
  fromXDR(input: string, format: 'hex' | 'base64'): ScError;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface UInt128Parts {
  hi(value?: Uint64): Uint64;
  lo(value?: Uint64): Uint64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _UInt128Parts = createCompatStruct({
  codec: modern.UInt128Parts,
  fields: [
    { name: 'hi', modernName: 'hi', convert: uint64Conv },
    { name: 'lo', modernName: 'lo', convert: uint64Conv },
  ],
});
export const UInt128Parts = _UInt128Parts as unknown as {
  new(attributes: { hi: Uint64; lo: Uint64 }): UInt128Parts;
  read(io: Buffer): UInt128Parts;
  write(value: UInt128Parts, io: Buffer): void;
  isValid(value: UInt128Parts): boolean;
  toXDR(value: UInt128Parts): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): UInt128Parts;
  fromXDR(input: string, format: 'hex' | 'base64'): UInt128Parts;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Int128Parts {
  hi(value?: Int64): Int64;
  lo(value?: Uint64): Uint64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Int128Parts = createCompatStruct({
  codec: modern.Int128Parts,
  fields: [
    { name: 'hi', modernName: 'hi', convert: int64Conv },
    { name: 'lo', modernName: 'lo', convert: uint64Conv },
  ],
});
export const Int128Parts = _Int128Parts as unknown as {
  new(attributes: { hi: Int64; lo: Uint64 }): Int128Parts;
  read(io: Buffer): Int128Parts;
  write(value: Int128Parts, io: Buffer): void;
  isValid(value: Int128Parts): boolean;
  toXDR(value: Int128Parts): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Int128Parts;
  fromXDR(input: string, format: 'hex' | 'base64'): Int128Parts;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface UInt256Parts {
  hiHi(value?: Uint64): Uint64;
  hiLo(value?: Uint64): Uint64;
  loHi(value?: Uint64): Uint64;
  loLo(value?: Uint64): Uint64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _UInt256Parts = createCompatStruct({
  codec: modern.UInt256Parts,
  fields: [
    { name: 'hiHi', modernName: 'hiHi', convert: uint64Conv },
    { name: 'hiLo', modernName: 'hiLo', convert: uint64Conv },
    { name: 'loHi', modernName: 'loHi', convert: uint64Conv },
    { name: 'loLo', modernName: 'loLo', convert: uint64Conv },
  ],
});
export const UInt256Parts = _UInt256Parts as unknown as {
  new(attributes: { hiHi: Uint64; hiLo: Uint64; loHi: Uint64; loLo: Uint64 }): UInt256Parts;
  read(io: Buffer): UInt256Parts;
  write(value: UInt256Parts, io: Buffer): void;
  isValid(value: UInt256Parts): boolean;
  toXDR(value: UInt256Parts): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): UInt256Parts;
  fromXDR(input: string, format: 'hex' | 'base64'): UInt256Parts;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Int256Parts {
  hiHi(value?: Int64): Int64;
  hiLo(value?: Uint64): Uint64;
  loHi(value?: Uint64): Uint64;
  loLo(value?: Uint64): Uint64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Int256Parts = createCompatStruct({
  codec: modern.Int256Parts,
  fields: [
    { name: 'hiHi', modernName: 'hiHi', convert: int64Conv },
    { name: 'hiLo', modernName: 'hiLo', convert: uint64Conv },
    { name: 'loHi', modernName: 'loHi', convert: uint64Conv },
    { name: 'loLo', modernName: 'loLo', convert: uint64Conv },
  ],
});
export const Int256Parts = _Int256Parts as unknown as {
  new(attributes: { hiHi: Int64; hiLo: Uint64; loHi: Uint64; loLo: Uint64 }): Int256Parts;
  read(io: Buffer): Int256Parts;
  write(value: Int256Parts, io: Buffer): void;
  isValid(value: Int256Parts): boolean;
  toXDR(value: Int256Parts): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Int256Parts;
  fromXDR(input: string, format: 'hex' | 'base64'): Int256Parts;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractExecutableType {
  readonly name: 'contractExecutableWasm' | 'contractExecutableStellarAsset';
  readonly value: 0 | 1;
}
const _ContractExecutableType = createCompatEnum({
  codec: modern.ContractExecutableType,
  members: [
    { compat: 'contractExecutableWasm', modern: 'Wasm', value: 0 },
    { compat: 'contractExecutableStellarAsset', modern: 'StellarAsset', value: 1 },
  ],
});
export const ContractExecutableType = _ContractExecutableType as unknown as {
  contractExecutableWasm(): ContractExecutableType;
  contractExecutableStellarAsset(): ContractExecutableType;
};

export type Hash = Buffer;
export const Hash = createCompatTypedef({ codec: modern.Hash, convert: id });

export interface ContractExecutable {
  switch(): ContractExecutableType;
  wasmHash(value?: Hash): Hash;
  value(): Hash | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractExecutable = createCompatUnion({
  codec: modern.ContractExecutable,
  switchEnum: _ContractExecutableType,
  arms: [
    { switchValues: ['contractExecutableWasm'], modern: 'Wasm', arm: 'wasmHash', convert: id },
    { switchValues: ['contractExecutableStellarAsset'], modern: 'StellarAsset' },
  ],
});
export const ContractExecutable = _ContractExecutable as unknown as {
  contractExecutableWasm(value: Hash): ContractExecutable;
  contractExecutableStellarAsset(): ContractExecutable;
  read(io: Buffer): ContractExecutable;
  write(value: ContractExecutable, io: Buffer): void;
  isValid(value: ContractExecutable): boolean;
  toXDR(value: ContractExecutable): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractExecutable;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractExecutable;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScAddressType {
  readonly name: 'scAddressTypeAccount' | 'scAddressTypeContract' | 'scAddressTypeMuxedAccount' | 'scAddressTypeClaimableBalance' | 'scAddressTypeLiquidityPool';
  readonly value: 0 | 1 | 2 | 3 | 4;
}
const _ScAddressType = createCompatEnum({
  codec: modern.SCAddressType,
  members: [
    { compat: 'scAddressTypeAccount', modern: 'Account', value: 0 },
    { compat: 'scAddressTypeContract', modern: 'Contract', value: 1 },
    { compat: 'scAddressTypeMuxedAccount', modern: 'MuxedAccount', value: 2 },
    { compat: 'scAddressTypeClaimableBalance', modern: 'ClaimableBalance', value: 3 },
    { compat: 'scAddressTypeLiquidityPool', modern: 'LiquidityPool', value: 4 },
  ],
});
export const ScAddressType = _ScAddressType as unknown as {
  scAddressTypeAccount(): ScAddressType;
  scAddressTypeContract(): ScAddressType;
  scAddressTypeMuxedAccount(): ScAddressType;
  scAddressTypeClaimableBalance(): ScAddressType;
  scAddressTypeLiquidityPool(): ScAddressType;
};

export type Uint256 = Buffer;
export const Uint256 = createCompatTypedef({ codec: modern.Uint256, convert: id });

export interface MuxedEd25519Account {
  id(value?: Uint64): Uint64;
  ed25519(value?: Uint256): Uint256;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _MuxedEd25519Account = createCompatStruct({
  codec: modern.MuxedEd25519Account,
  fields: [
    { name: 'id', modernName: 'id', convert: uint64Conv },
    { name: 'ed25519', modernName: 'ed25519', convert: id },
  ],
});
export const MuxedEd25519Account = _MuxedEd25519Account as unknown as {
  new(attributes: { id: Uint64; ed25519: Uint256 }): MuxedEd25519Account;
  read(io: Buffer): MuxedEd25519Account;
  write(value: MuxedEd25519Account, io: Buffer): void;
  isValid(value: MuxedEd25519Account): boolean;
  toXDR(value: MuxedEd25519Account): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): MuxedEd25519Account;
  fromXDR(input: string, format: 'hex' | 'base64'): MuxedEd25519Account;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PublicKeyType {
  readonly name: 'publicKeyTypeEd25519';
  readonly value: 0;
}
const _PublicKeyType = createCompatEnum({
  codec: modern.PublicKeyType,
  members: [
    { compat: 'publicKeyTypeEd25519', modern: 'PublicKeyTypeEd25519', value: 0 },
  ],
});
export const PublicKeyType = _PublicKeyType as unknown as {
  publicKeyTypeEd25519(): PublicKeyType;
};

export interface PublicKey {
  switch(): PublicKeyType;
  ed25519(value?: Uint256): Uint256;
  value(): Uint256;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PublicKey = createCompatUnion({
  codec: modern.PublicKey,
  switchEnum: _PublicKeyType,
  arms: [
    { switchValues: ['publicKeyTypeEd25519'], modern: 'PublicKeyTypeEd25519', arm: 'ed25519', convert: id },
  ],
});
export const PublicKey = _PublicKey as unknown as {
  publicKeyTypeEd25519(value: Uint256): PublicKey;
  read(io: Buffer): PublicKey;
  write(value: PublicKey, io: Buffer): void;
  isValid(value: PublicKey): boolean;
  toXDR(value: PublicKey): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PublicKey;
  fromXDR(input: string, format: 'hex' | 'base64'): PublicKey;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type AccountId = PublicKey;

export type ContractId = Hash;

export interface ClaimableBalanceIdType {
  readonly name: 'claimableBalanceIdTypeV0';
  readonly value: 0;
}
const _ClaimableBalanceIdType = createCompatEnum({
  codec: modern.ClaimableBalanceIDType,
  members: [
    { compat: 'claimableBalanceIdTypeV0', modern: 'ClaimableBalanceIdTypeV0', value: 0 },
  ],
});
export const ClaimableBalanceIdType = _ClaimableBalanceIdType as unknown as {
  claimableBalanceIdTypeV0(): ClaimableBalanceIdType;
};

export interface ClaimableBalanceId {
  switch(): ClaimableBalanceIdType;
  v0(value?: Hash): Hash;
  value(): Hash;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimableBalanceId = createCompatUnion({
  codec: modern.ClaimableBalanceID,
  switchEnum: _ClaimableBalanceIdType,
  arms: [
    { switchValues: ['claimableBalanceIdTypeV0'], modern: 'ClaimableBalanceIdTypeV0', arm: 'v0', convert: id },
  ],
});
export const ClaimableBalanceId = _ClaimableBalanceId as unknown as {
  claimableBalanceIdTypeV0(value: Hash): ClaimableBalanceId;
  read(io: Buffer): ClaimableBalanceId;
  write(value: ClaimableBalanceId, io: Buffer): void;
  isValid(value: ClaimableBalanceId): boolean;
  toXDR(value: ClaimableBalanceId): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimableBalanceId;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimableBalanceId;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type PoolId = Hash;

export interface ScAddress {
  switch(): ScAddressType;
  accountId(value?: AccountId): AccountId;
  contractId(value?: ContractId): ContractId;
  muxedAccount(value?: MuxedEd25519Account): MuxedEd25519Account;
  claimableBalanceId(value?: ClaimableBalanceId): ClaimableBalanceId;
  liquidityPoolId(value?: PoolId): PoolId;
  value(): AccountId | ContractId | MuxedEd25519Account | ClaimableBalanceId | PoolId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScAddress = createCompatUnion({
  codec: modern.SCAddress,
  switchEnum: _ScAddressType,
  arms: [
    { switchValues: ['scAddressTypeAccount'], modern: 'Account', arm: 'accountId', convert: unionConverter(_PublicKey) },
    { switchValues: ['scAddressTypeContract'], modern: 'Contract', arm: 'contractId', convert: id },
    { switchValues: ['scAddressTypeMuxedAccount'], modern: 'MuxedAccount', arm: 'muxedAccount', convert: structConverter(_MuxedEd25519Account) },
    { switchValues: ['scAddressTypeClaimableBalance'], modern: 'ClaimableBalance', arm: 'claimableBalanceId', convert: unionConverter(_ClaimableBalanceId) },
    { switchValues: ['scAddressTypeLiquidityPool'], modern: 'LiquidityPool', arm: 'liquidityPoolId', convert: id },
  ],
});
export const ScAddress = _ScAddress as unknown as {
  scAddressTypeAccount(value: AccountId): ScAddress;
  scAddressTypeContract(value: ContractId): ScAddress;
  scAddressTypeMuxedAccount(value: MuxedEd25519Account): ScAddress;
  scAddressTypeClaimableBalance(value: ClaimableBalanceId): ScAddress;
  scAddressTypeLiquidityPool(value: PoolId): ScAddress;
  read(io: Buffer): ScAddress;
  write(value: ScAddress, io: Buffer): void;
  isValid(value: ScAddress): boolean;
  toXDR(value: ScAddress): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScAddress;
  fromXDR(input: string, format: 'hex' | 'base64'): ScAddress;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type Int32 = number;
export const Int32 = createCompatTypedef({ codec: modern.Int32, convert: id });

export type TimePoint = Uint64;

export type Duration = Uint64;

export type ScBytes = Buffer;
export const ScBytes = createCompatTypedef({ codec: modern.SCBytes, convert: id });

export type ScString = string | Buffer;
export const ScString = createCompatTypedef({ codec: modern.SCString, convert: id });

export interface ScMapEntry {
  key(value?: ScVal): ScVal;
  val(value?: ScVal): ScVal;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScMapEntry = createCompatStruct({
  codec: modern.SCMapEntry,
  fields: [
    { name: 'key', modernName: 'key', convert: lazyConverter(() => unionConverter(_ScVal)) },
    { name: 'val', modernName: 'val', convert: lazyConverter(() => unionConverter(_ScVal)) },
  ],
});
export const ScMapEntry = _ScMapEntry as unknown as {
  new(attributes: { key: ScVal; val: ScVal }): ScMapEntry;
  read(io: Buffer): ScMapEntry;
  write(value: ScMapEntry, io: Buffer): void;
  isValid(value: ScMapEntry): boolean;
  toXDR(value: ScMapEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScMapEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ScMapEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type ScMap = ScMapEntry[];
export const ScMap = createCompatTypedef({ codec: modern.SCMap, convert: arrayConverter(structConverter(_ScMapEntry)) });

export interface ScContractInstance {
  executable(value?: ContractExecutable): ContractExecutable;
  storage(value?: null | ScMap): null | ScMap;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScContractInstance = createCompatStruct({
  codec: modern.SCContractInstance,
  fields: [
    { name: 'executable', modernName: 'executable', convert: unionConverter(_ContractExecutable) },
    { name: 'storage', modernName: 'storage', convert: optionConverter(arrayConverter(structConverter(_ScMapEntry))) },
  ],
});
export const ScContractInstance = _ScContractInstance as unknown as {
  new(attributes: { executable: ContractExecutable; storage: null | ScMap }): ScContractInstance;
  read(io: Buffer): ScContractInstance;
  write(value: ScContractInstance, io: Buffer): void;
  isValid(value: ScContractInstance): boolean;
  toXDR(value: ScContractInstance): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScContractInstance;
  fromXDR(input: string, format: 'hex' | 'base64'): ScContractInstance;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScNonceKey {
  nonce(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScNonceKey = createCompatStruct({
  codec: modern.SCNonceKey,
  fields: [
    { name: 'nonce', modernName: 'nonce', convert: int64Conv },
  ],
});
export const ScNonceKey = _ScNonceKey as unknown as {
  new(attributes: { nonce: Int64 }): ScNonceKey;
  read(io: Buffer): ScNonceKey;
  write(value: ScNonceKey, io: Buffer): void;
  isValid(value: ScNonceKey): boolean;
  toXDR(value: ScNonceKey): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScNonceKey;
  fromXDR(input: string, format: 'hex' | 'base64'): ScNonceKey;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScVal {
  switch(): ScValType;
  b(value?: boolean): boolean;
  error(value?: ScError): ScError;
  u32(value?: Uint32): Uint32;
  i32(value?: Int32): Int32;
  u64(value?: Uint64): Uint64;
  i64(value?: Int64): Int64;
  timepoint(value?: TimePoint): TimePoint;
  duration(value?: Duration): Duration;
  u128(value?: UInt128Parts): UInt128Parts;
  i128(value?: Int128Parts): Int128Parts;
  u256(value?: UInt256Parts): UInt256Parts;
  i256(value?: Int256Parts): Int256Parts;
  bytes(value?: ScBytes): ScBytes;
  str(value?: ScString): ScString;
  sym(value?: ScSymbol): ScSymbol;
  vec(value?: null | ScVec): null | ScVec;
  map(value?: null | ScMap): null | ScMap;
  address(value?: ScAddress): ScAddress;
  instance(value?: ScContractInstance): ScContractInstance;
  nonceKey(value?: ScNonceKey): ScNonceKey;
  value(): boolean | ScError | Uint32 | Int32 | Uint64 | Int64 | TimePoint | Duration | UInt128Parts | Int128Parts | UInt256Parts | Int256Parts | ScBytes | ScString | ScSymbol | null | ScVec | null | ScMap | ScAddress | ScContractInstance | ScNonceKey | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScVal = createCompatUnion({
  codec: modern.SCVal,
  switchEnum: _ScValType,
  arms: [
    { switchValues: ['scvBool'], modern: 'Bool', arm: 'b', convert: id },
    { switchValues: ['scvVoid'], modern: 'Void' },
    { switchValues: ['scvError'], modern: 'Error', arm: 'error', convert: unionConverter(_ScError) },
    { switchValues: ['scvU32'], modern: 'U32', arm: 'u32', convert: id },
    { switchValues: ['scvI32'], modern: 'I32', arm: 'i32', convert: id },
    { switchValues: ['scvU64'], modern: 'U64', arm: 'u64', convert: uint64Conv },
    { switchValues: ['scvI64'], modern: 'I64', arm: 'i64', convert: int64Conv },
    { switchValues: ['scvTimepoint'], modern: 'Timepoint', arm: 'timepoint', convert: uint64Conv },
    { switchValues: ['scvDuration'], modern: 'Duration', arm: 'duration', convert: uint64Conv },
    { switchValues: ['scvU128'], modern: 'U128', arm: 'u128', convert: structConverter(_UInt128Parts) },
    { switchValues: ['scvI128'], modern: 'I128', arm: 'i128', convert: structConverter(_Int128Parts) },
    { switchValues: ['scvU256'], modern: 'U256', arm: 'u256', convert: structConverter(_UInt256Parts) },
    { switchValues: ['scvI256'], modern: 'I256', arm: 'i256', convert: structConverter(_Int256Parts) },
    { switchValues: ['scvBytes'], modern: 'Bytes', arm: 'bytes', convert: id },
    { switchValues: ['scvString'], modern: 'String', arm: 'str', convert: id },
    { switchValues: ['scvSymbol'], modern: 'Symbol', arm: 'sym', convert: id },
    { switchValues: ['scvVec'], modern: 'Vec', arm: 'vec', convert: optionConverter(arrayConverter(lazyConverter(() => unionConverter(_ScVal)))) },
    { switchValues: ['scvMap'], modern: 'Map', arm: 'map', convert: optionConverter(arrayConverter(structConverter(_ScMapEntry))) },
    { switchValues: ['scvAddress'], modern: 'Address', arm: 'address', convert: unionConverter(_ScAddress) },
    { switchValues: ['scvContractInstance'], modern: 'ContractInstance', arm: 'instance', convert: structConverter(_ScContractInstance) },
    { switchValues: ['scvLedgerKeyContractInstance'], modern: 'LedgerKeyContractInstance' },
    { switchValues: ['scvLedgerKeyNonce'], modern: 'LedgerKeyNonce', arm: 'nonceKey', convert: structConverter(_ScNonceKey) },
  ],
});
export const ScVal = _ScVal as unknown as {
  scvBool(value: boolean): ScVal;
  scvVoid(): ScVal;
  scvError(value: ScError): ScVal;
  scvU32(value: Uint32): ScVal;
  scvI32(value: Int32): ScVal;
  scvU64(value: Uint64): ScVal;
  scvI64(value: Int64): ScVal;
  scvTimepoint(value: TimePoint): ScVal;
  scvDuration(value: Duration): ScVal;
  scvU128(value: UInt128Parts): ScVal;
  scvI128(value: Int128Parts): ScVal;
  scvU256(value: UInt256Parts): ScVal;
  scvI256(value: Int256Parts): ScVal;
  scvBytes(value: ScBytes): ScVal;
  scvString(value: ScString): ScVal;
  scvSymbol(value: ScSymbol): ScVal;
  scvVec(value: null | ScVec): ScVal;
  scvMap(value: null | ScMap): ScVal;
  scvAddress(value: ScAddress): ScVal;
  scvContractInstance(value: ScContractInstance): ScVal;
  scvLedgerKeyContractInstance(): ScVal;
  scvLedgerKeyNonce(value: ScNonceKey): ScVal;
  read(io: Buffer): ScVal;
  write(value: ScVal, io: Buffer): void;
  isValid(value: ScVal): boolean;
  toXDR(value: ScVal): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScVal;
  fromXDR(input: string, format: 'hex' | 'base64'): ScVal;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type ScVec = ScVal[];
export const ScVec = createCompatTypedef({ codec: modern.SCVec, convert: arrayConverter(lazyConverter(() => unionConverter(_ScVal))) });

export type UpgradeType = Buffer;
export const UpgradeType = createCompatTypedef({ codec: modern.UpgradeType, convert: id });

export interface StellarValueType {
  readonly name: 'stellarValueBasic' | 'stellarValueSigned';
  readonly value: 0 | 1;
}
const _StellarValueType = createCompatEnum({
  codec: modern.StellarValueType,
  members: [
    { compat: 'stellarValueBasic', modern: 'Basic', value: 0 },
    { compat: 'stellarValueSigned', modern: 'Signed', value: 1 },
  ],
});
export const StellarValueType = _StellarValueType as unknown as {
  stellarValueBasic(): StellarValueType;
  stellarValueSigned(): StellarValueType;
};

export type NodeId = PublicKey;

export type Signature = Buffer;
export const Signature = createCompatTypedef({ codec: modern.Signature, convert: id });

export interface LedgerCloseValueSignature {
  nodeId(value?: NodeId): NodeId;
  signature(value?: Signature): Signature;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerCloseValueSignature = createCompatStruct({
  codec: modern.LedgerCloseValueSignature,
  fields: [
    { name: 'nodeId', modernName: 'nodeID', convert: unionConverter(_PublicKey) },
    { name: 'signature', modernName: 'signature', convert: id },
  ],
});
export const LedgerCloseValueSignature = _LedgerCloseValueSignature as unknown as {
  new(attributes: { nodeId: NodeId; signature: Signature }): LedgerCloseValueSignature;
  read(io: Buffer): LedgerCloseValueSignature;
  write(value: LedgerCloseValueSignature, io: Buffer): void;
  isValid(value: LedgerCloseValueSignature): boolean;
  toXDR(value: LedgerCloseValueSignature): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerCloseValueSignature;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerCloseValueSignature;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface StellarValueExt {
  switch(): StellarValueType;
  lcValueSignature(value?: LedgerCloseValueSignature): LedgerCloseValueSignature;
  value(): LedgerCloseValueSignature | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _StellarValueExt = createCompatUnion({
  codec: modern.StellarValueExt,
  switchEnum: _StellarValueType,
  arms: [
    { switchValues: ['stellarValueBasic'], modern: 'Basic' },
    { switchValues: ['stellarValueSigned'], modern: 'Signed', arm: 'lcValueSignature', convert: structConverter(_LedgerCloseValueSignature) },
  ],
});
export const StellarValueExt = _StellarValueExt as unknown as {
  stellarValueBasic(): StellarValueExt;
  stellarValueSigned(value: LedgerCloseValueSignature): StellarValueExt;
  read(io: Buffer): StellarValueExt;
  write(value: StellarValueExt, io: Buffer): void;
  isValid(value: StellarValueExt): boolean;
  toXDR(value: StellarValueExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): StellarValueExt;
  fromXDR(input: string, format: 'hex' | 'base64'): StellarValueExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface StellarValue {
  txSetHash(value?: Hash): Hash;
  closeTime(value?: TimePoint): TimePoint;
  upgrades(value?: UpgradeType[]): UpgradeType[];
  ext(value?: StellarValueExt): StellarValueExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _StellarValue = createCompatStruct({
  codec: modern.StellarValue,
  fields: [
    { name: 'txSetHash', modernName: 'txSetHash', convert: id },
    { name: 'closeTime', modernName: 'closeTime', convert: uint64Conv },
    { name: 'upgrades', modernName: 'upgrades', convert: arrayConverter(id) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const StellarValue = _StellarValue as unknown as {
  new(attributes: { txSetHash: Hash; closeTime: TimePoint; upgrades: UpgradeType[]; ext: StellarValueExt }): StellarValue;
  read(io: Buffer): StellarValue;
  write(value: StellarValue, io: Buffer): void;
  isValid(value: StellarValue): boolean;
  toXDR(value: StellarValue): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): StellarValue;
  fromXDR(input: string, format: 'hex' | 'base64'): StellarValue;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerHeaderExtensionV1Ext {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerHeaderExtensionV1Ext = createCompatUnion({
  codec: modern.LedgerHeaderExtensionV1Ext,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const LedgerHeaderExtensionV1Ext = _LedgerHeaderExtensionV1Ext as unknown as {
  0(): LedgerHeaderExtensionV1Ext;
  read(io: Buffer): LedgerHeaderExtensionV1Ext;
  write(value: LedgerHeaderExtensionV1Ext, io: Buffer): void;
  isValid(value: LedgerHeaderExtensionV1Ext): boolean;
  toXDR(value: LedgerHeaderExtensionV1Ext): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerHeaderExtensionV1Ext;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerHeaderExtensionV1Ext;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerHeaderExtensionV1 {
  flags(value?: Uint32): Uint32;
  ext(value?: LedgerHeaderExtensionV1Ext): LedgerHeaderExtensionV1Ext;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerHeaderExtensionV1 = createCompatStruct({
  codec: modern.LedgerHeaderExtensionV1,
  fields: [
    { name: 'flags', modernName: 'flags', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const LedgerHeaderExtensionV1 = _LedgerHeaderExtensionV1 as unknown as {
  new(attributes: { flags: Uint32; ext: LedgerHeaderExtensionV1Ext }): LedgerHeaderExtensionV1;
  read(io: Buffer): LedgerHeaderExtensionV1;
  write(value: LedgerHeaderExtensionV1, io: Buffer): void;
  isValid(value: LedgerHeaderExtensionV1): boolean;
  toXDR(value: LedgerHeaderExtensionV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerHeaderExtensionV1;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerHeaderExtensionV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerHeaderExt {
  switch(): number;
  v1(value?: LedgerHeaderExtensionV1): LedgerHeaderExtensionV1;
  value(): LedgerHeaderExtensionV1 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerHeaderExt = createCompatUnion({
  codec: modern.LedgerHeaderExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_LedgerHeaderExtensionV1) },
  ],
});
export const LedgerHeaderExt = _LedgerHeaderExt as unknown as {
  0(): LedgerHeaderExt;
  1(value: LedgerHeaderExtensionV1): LedgerHeaderExt;
  read(io: Buffer): LedgerHeaderExt;
  write(value: LedgerHeaderExt, io: Buffer): void;
  isValid(value: LedgerHeaderExt): boolean;
  toXDR(value: LedgerHeaderExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerHeaderExt;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerHeaderExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerHeader {
  ledgerVersion(value?: Uint32): Uint32;
  previousLedgerHash(value?: Hash): Hash;
  scpValue(value?: StellarValue): StellarValue;
  txSetResultHash(value?: Hash): Hash;
  bucketListHash(value?: Hash): Hash;
  ledgerSeq(value?: Uint32): Uint32;
  totalCoins(value?: Int64): Int64;
  feePool(value?: Int64): Int64;
  inflationSeq(value?: Uint32): Uint32;
  idPool(value?: Uint64): Uint64;
  baseFee(value?: Uint32): Uint32;
  baseReserve(value?: Uint32): Uint32;
  maxTxSetSize(value?: Uint32): Uint32;
  skipList(value?: Hash[]): Hash[];
  ext(value?: LedgerHeaderExt): LedgerHeaderExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerHeader = createCompatStruct({
  codec: modern.LedgerHeader,
  fields: [
    { name: 'ledgerVersion', modernName: 'ledgerVersion', convert: id },
    { name: 'previousLedgerHash', modernName: 'previousLedgerHash', convert: id },
    { name: 'scpValue', modernName: 'scpValue', convert: structConverter(_StellarValue) },
    { name: 'txSetResultHash', modernName: 'txSetResultHash', convert: id },
    { name: 'bucketListHash', modernName: 'bucketListHash', convert: id },
    { name: 'ledgerSeq', modernName: 'ledgerSeq', convert: id },
    { name: 'totalCoins', modernName: 'totalCoins', convert: int64Conv },
    { name: 'feePool', modernName: 'feePool', convert: int64Conv },
    { name: 'inflationSeq', modernName: 'inflationSeq', convert: id },
    { name: 'idPool', modernName: 'idPool', convert: uint64Conv },
    { name: 'baseFee', modernName: 'baseFee', convert: id },
    { name: 'baseReserve', modernName: 'baseReserve', convert: id },
    { name: 'maxTxSetSize', modernName: 'maxTxSetSize', convert: id },
    { name: 'skipList', modernName: 'skipList', convert: arrayConverter(id) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const LedgerHeader = _LedgerHeader as unknown as {
  new(attributes: { ledgerVersion: Uint32; previousLedgerHash: Hash; scpValue: StellarValue; txSetResultHash: Hash; bucketListHash: Hash; ledgerSeq: Uint32; totalCoins: Int64; feePool: Int64; inflationSeq: Uint32; idPool: Uint64; baseFee: Uint32; baseReserve: Uint32; maxTxSetSize: Uint32; skipList: Hash[]; ext: LedgerHeaderExt }): LedgerHeader;
  read(io: Buffer): LedgerHeader;
  write(value: LedgerHeader, io: Buffer): void;
  isValid(value: LedgerHeader): boolean;
  toXDR(value: LedgerHeader): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerHeader;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerHeader;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerHeaderHistoryEntryExt {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerHeaderHistoryEntryExt = createCompatUnion({
  codec: modern.LedgerHeaderHistoryEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const LedgerHeaderHistoryEntryExt = _LedgerHeaderHistoryEntryExt as unknown as {
  0(): LedgerHeaderHistoryEntryExt;
  read(io: Buffer): LedgerHeaderHistoryEntryExt;
  write(value: LedgerHeaderHistoryEntryExt, io: Buffer): void;
  isValid(value: LedgerHeaderHistoryEntryExt): boolean;
  toXDR(value: LedgerHeaderHistoryEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerHeaderHistoryEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerHeaderHistoryEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerHeaderHistoryEntry {
  hash(value?: Hash): Hash;
  header(value?: LedgerHeader): LedgerHeader;
  ext(value?: LedgerHeaderHistoryEntryExt): LedgerHeaderHistoryEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerHeaderHistoryEntry = createCompatStruct({
  codec: modern.LedgerHeaderHistoryEntry,
  fields: [
    { name: 'hash', modernName: 'hash', convert: id },
    { name: 'header', modernName: 'header', convert: structConverter(_LedgerHeader) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const LedgerHeaderHistoryEntry = _LedgerHeaderHistoryEntry as unknown as {
  new(attributes: { hash: Hash; header: LedgerHeader; ext: LedgerHeaderHistoryEntryExt }): LedgerHeaderHistoryEntry;
  read(io: Buffer): LedgerHeaderHistoryEntry;
  write(value: LedgerHeaderHistoryEntry, io: Buffer): void;
  isValid(value: LedgerHeaderHistoryEntry): boolean;
  toXDR(value: LedgerHeaderHistoryEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerHeaderHistoryEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerHeaderHistoryEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface EnvelopeType {
  readonly name: 'envelopeTypeTxV0' | 'envelopeTypeScp' | 'envelopeTypeTx' | 'envelopeTypeAuth' | 'envelopeTypeScpvalue' | 'envelopeTypeTxFeeBump' | 'envelopeTypeOpId' | 'envelopeTypePoolRevokeOpId' | 'envelopeTypeContractId' | 'envelopeTypeSorobanAuthorization';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
}
const _EnvelopeType = createCompatEnum({
  codec: modern.EnvelopeType,
  members: [
    { compat: 'envelopeTypeTxV0', modern: 'TxV0', value: 0 },
    { compat: 'envelopeTypeScp', modern: 'Scp', value: 1 },
    { compat: 'envelopeTypeTx', modern: 'Tx', value: 2 },
    { compat: 'envelopeTypeAuth', modern: 'Auth', value: 3 },
    { compat: 'envelopeTypeScpvalue', modern: 'Scpvalue', value: 4 },
    { compat: 'envelopeTypeTxFeeBump', modern: 'TxFeeBump', value: 5 },
    { compat: 'envelopeTypeOpId', modern: 'OpId', value: 6 },
    { compat: 'envelopeTypePoolRevokeOpId', modern: 'PoolRevokeOpId', value: 7 },
    { compat: 'envelopeTypeContractId', modern: 'ContractId', value: 8 },
    { compat: 'envelopeTypeSorobanAuthorization', modern: 'SorobanAuthorization', value: 9 },
  ],
});
export const EnvelopeType = _EnvelopeType as unknown as {
  envelopeTypeTxV0(): EnvelopeType;
  envelopeTypeScp(): EnvelopeType;
  envelopeTypeTx(): EnvelopeType;
  envelopeTypeAuth(): EnvelopeType;
  envelopeTypeScpvalue(): EnvelopeType;
  envelopeTypeTxFeeBump(): EnvelopeType;
  envelopeTypeOpId(): EnvelopeType;
  envelopeTypePoolRevokeOpId(): EnvelopeType;
  envelopeTypeContractId(): EnvelopeType;
  envelopeTypeSorobanAuthorization(): EnvelopeType;
};

export type SequenceNumber = Int64;

export interface TimeBounds {
  minTime(value?: TimePoint): TimePoint;
  maxTime(value?: TimePoint): TimePoint;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TimeBounds = createCompatStruct({
  codec: modern.TimeBounds,
  fields: [
    { name: 'minTime', modernName: 'minTime', convert: uint64Conv },
    { name: 'maxTime', modernName: 'maxTime', convert: uint64Conv },
  ],
});
export const TimeBounds = _TimeBounds as unknown as {
  new(attributes: { minTime: TimePoint; maxTime: TimePoint }): TimeBounds;
  read(io: Buffer): TimeBounds;
  write(value: TimeBounds, io: Buffer): void;
  isValid(value: TimeBounds): boolean;
  toXDR(value: TimeBounds): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TimeBounds;
  fromXDR(input: string, format: 'hex' | 'base64'): TimeBounds;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface MemoType {
  readonly name: 'memoNone' | 'memoText' | 'memoId' | 'memoHash' | 'memoReturn';
  readonly value: 0 | 1 | 2 | 3 | 4;
}
const _MemoType = createCompatEnum({
  codec: modern.MemoType,
  members: [
    { compat: 'memoNone', modern: 'None', value: 0 },
    { compat: 'memoText', modern: 'Text', value: 1 },
    { compat: 'memoId', modern: 'Id', value: 2 },
    { compat: 'memoHash', modern: 'Hash', value: 3 },
    { compat: 'memoReturn', modern: 'Return', value: 4 },
  ],
});
export const MemoType = _MemoType as unknown as {
  memoNone(): MemoType;
  memoText(): MemoType;
  memoId(): MemoType;
  memoHash(): MemoType;
  memoReturn(): MemoType;
};

export interface Memo {
  switch(): MemoType;
  text(value?: string | Buffer): string | Buffer;
  id(value?: Uint64): Uint64;
  hash(value?: Hash): Hash;
  retHash(value?: Hash): Hash;
  value(): string | Buffer | Uint64 | Hash | Hash | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Memo = createCompatUnion({
  codec: modern.Memo,
  switchEnum: _MemoType,
  arms: [
    { switchValues: ['memoNone'], modern: 'None' },
    { switchValues: ['memoText'], modern: 'Text', arm: 'text', convert: id },
    { switchValues: ['memoId'], modern: 'Id', arm: 'id', convert: uint64Conv },
    { switchValues: ['memoHash'], modern: 'Hash', arm: 'hash', convert: id },
    { switchValues: ['memoReturn'], modern: 'Return', arm: 'retHash', convert: id },
  ],
});
export const Memo = _Memo as unknown as {
  memoNone(): Memo;
  memoText(value: string | Buffer): Memo;
  memoId(value: Uint64): Memo;
  memoHash(value: Hash): Memo;
  memoReturn(value: Hash): Memo;
  read(io: Buffer): Memo;
  write(value: Memo, io: Buffer): void;
  isValid(value: Memo): boolean;
  toXDR(value: Memo): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Memo;
  fromXDR(input: string, format: 'hex' | 'base64'): Memo;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface CryptoKeyType {
  readonly name: 'keyTypeEd25519' | 'keyTypePreAuthTx' | 'keyTypeHashX' | 'keyTypeEd25519SignedPayload' | 'keyTypeMuxedEd25519';
  readonly value: 0 | 1 | 2 | 3 | 256;
}
const _CryptoKeyType = createCompatEnum({
  codec: modern.CryptoKeyType,
  members: [
    { compat: 'keyTypeEd25519', modern: 'Ed25519', value: 0 },
    { compat: 'keyTypePreAuthTx', modern: 'PreAuthTx', value: 1 },
    { compat: 'keyTypeHashX', modern: 'HashX', value: 2 },
    { compat: 'keyTypeEd25519SignedPayload', modern: 'Ed25519SignedPayload', value: 3 },
    { compat: 'keyTypeMuxedEd25519', modern: 'MuxedEd25519', value: 256 },
  ],
});
export const CryptoKeyType = _CryptoKeyType as unknown as {
  keyTypeEd25519(): CryptoKeyType;
  keyTypePreAuthTx(): CryptoKeyType;
  keyTypeHashX(): CryptoKeyType;
  keyTypeEd25519SignedPayload(): CryptoKeyType;
  keyTypeMuxedEd25519(): CryptoKeyType;
};

export interface MuxedAccountMed25519 {
  id(value?: Uint64): Uint64;
  ed25519(value?: Uint256): Uint256;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _MuxedAccountMed25519 = createCompatStruct({
  codec: modern.MuxedAccountMed25519,
  fields: [
    { name: 'id', modernName: 'id', convert: uint64Conv },
    { name: 'ed25519', modernName: 'ed25519', convert: id },
  ],
});
export const MuxedAccountMed25519 = _MuxedAccountMed25519 as unknown as {
  new(attributes: { id: Uint64; ed25519: Uint256 }): MuxedAccountMed25519;
  read(io: Buffer): MuxedAccountMed25519;
  write(value: MuxedAccountMed25519, io: Buffer): void;
  isValid(value: MuxedAccountMed25519): boolean;
  toXDR(value: MuxedAccountMed25519): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): MuxedAccountMed25519;
  fromXDR(input: string, format: 'hex' | 'base64'): MuxedAccountMed25519;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface MuxedAccount {
  switch(): CryptoKeyType;
  ed25519(value?: Uint256): Uint256;
  med25519(value?: MuxedAccountMed25519): MuxedAccountMed25519;
  value(): Uint256 | MuxedAccountMed25519;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _MuxedAccount = createCompatUnion({
  codec: modern.MuxedAccount,
  switchEnum: _CryptoKeyType,
  arms: [
    { switchValues: ['keyTypeEd25519'], modern: 'Ed25519', arm: 'ed25519', convert: id },
    { switchValues: ['keyTypeMuxedEd25519'], modern: 'MuxedEd25519', arm: 'med25519', convert: id },
  ],
});
export const MuxedAccount = _MuxedAccount as unknown as {
  keyTypeEd25519(value: Uint256): MuxedAccount;
  keyTypeMuxedEd25519(value: MuxedAccountMed25519): MuxedAccount;
  read(io: Buffer): MuxedAccount;
  write(value: MuxedAccount, io: Buffer): void;
  isValid(value: MuxedAccount): boolean;
  toXDR(value: MuxedAccount): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): MuxedAccount;
  fromXDR(input: string, format: 'hex' | 'base64'): MuxedAccount;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface OperationType {
  readonly name: 'createAccount' | 'payment' | 'pathPaymentStrictReceive' | 'manageSellOffer' | 'createPassiveSellOffer' | 'setOptions' | 'changeTrust' | 'allowTrust' | 'accountMerge' | 'inflation' | 'manageData' | 'bumpSequence' | 'manageBuyOffer' | 'pathPaymentStrictSend' | 'createClaimableBalance' | 'claimClaimableBalance' | 'beginSponsoringFutureReserves' | 'endSponsoringFutureReserves' | 'revokeSponsorship' | 'clawback' | 'clawbackClaimableBalance' | 'setTrustLineFlags' | 'liquidityPoolDeposit' | 'liquidityPoolWithdraw' | 'invokeHostFunction' | 'extendFootprintTtl' | 'restoreFootprint';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26;
}
const _OperationType = createCompatEnum({
  codec: modern.OperationType,
  members: [
    { compat: 'createAccount', modern: 'CreateAccount', value: 0 },
    { compat: 'payment', modern: 'Payment', value: 1 },
    { compat: 'pathPaymentStrictReceive', modern: 'PathPaymentStrictReceive', value: 2 },
    { compat: 'manageSellOffer', modern: 'ManageSellOffer', value: 3 },
    { compat: 'createPassiveSellOffer', modern: 'CreatePassiveSellOffer', value: 4 },
    { compat: 'setOptions', modern: 'SetOptions', value: 5 },
    { compat: 'changeTrust', modern: 'ChangeTrust', value: 6 },
    { compat: 'allowTrust', modern: 'AllowTrust', value: 7 },
    { compat: 'accountMerge', modern: 'AccountMerge', value: 8 },
    { compat: 'inflation', modern: 'Inflation', value: 9 },
    { compat: 'manageData', modern: 'ManageData', value: 10 },
    { compat: 'bumpSequence', modern: 'BumpSequence', value: 11 },
    { compat: 'manageBuyOffer', modern: 'ManageBuyOffer', value: 12 },
    { compat: 'pathPaymentStrictSend', modern: 'PathPaymentStrictSend', value: 13 },
    { compat: 'createClaimableBalance', modern: 'CreateClaimableBalance', value: 14 },
    { compat: 'claimClaimableBalance', modern: 'ClaimClaimableBalance', value: 15 },
    { compat: 'beginSponsoringFutureReserves', modern: 'BeginSponsoringFutureReserves', value: 16 },
    { compat: 'endSponsoringFutureReserves', modern: 'EndSponsoringFutureReserves', value: 17 },
    { compat: 'revokeSponsorship', modern: 'RevokeSponsorship', value: 18 },
    { compat: 'clawback', modern: 'Clawback', value: 19 },
    { compat: 'clawbackClaimableBalance', modern: 'ClawbackClaimableBalance', value: 20 },
    { compat: 'setTrustLineFlags', modern: 'SetTrustLineFlags', value: 21 },
    { compat: 'liquidityPoolDeposit', modern: 'LiquidityPoolDeposit', value: 22 },
    { compat: 'liquidityPoolWithdraw', modern: 'LiquidityPoolWithdraw', value: 23 },
    { compat: 'invokeHostFunction', modern: 'InvokeHostFunction', value: 24 },
    { compat: 'extendFootprintTtl', modern: 'ExtendFootprintTtl', value: 25 },
    { compat: 'restoreFootprint', modern: 'RestoreFootprint', value: 26 },
  ],
});
export const OperationType = _OperationType as unknown as {
  createAccount(): OperationType;
  payment(): OperationType;
  pathPaymentStrictReceive(): OperationType;
  manageSellOffer(): OperationType;
  createPassiveSellOffer(): OperationType;
  setOptions(): OperationType;
  changeTrust(): OperationType;
  allowTrust(): OperationType;
  accountMerge(): OperationType;
  inflation(): OperationType;
  manageData(): OperationType;
  bumpSequence(): OperationType;
  manageBuyOffer(): OperationType;
  pathPaymentStrictSend(): OperationType;
  createClaimableBalance(): OperationType;
  claimClaimableBalance(): OperationType;
  beginSponsoringFutureReserves(): OperationType;
  endSponsoringFutureReserves(): OperationType;
  revokeSponsorship(): OperationType;
  clawback(): OperationType;
  clawbackClaimableBalance(): OperationType;
  setTrustLineFlags(): OperationType;
  liquidityPoolDeposit(): OperationType;
  liquidityPoolWithdraw(): OperationType;
  invokeHostFunction(): OperationType;
  extendFootprintTtl(): OperationType;
  restoreFootprint(): OperationType;
};

export interface CreateAccountOp {
  destination(value?: AccountId): AccountId;
  startingBalance(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _CreateAccountOp = createCompatStruct({
  codec: modern.CreateAccountOp,
  fields: [
    { name: 'destination', modernName: 'destination', convert: unionConverter(_PublicKey) },
    { name: 'startingBalance', modernName: 'startingBalance', convert: int64Conv },
  ],
});
export const CreateAccountOp = _CreateAccountOp as unknown as {
  new(attributes: { destination: AccountId; startingBalance: Int64 }): CreateAccountOp;
  read(io: Buffer): CreateAccountOp;
  write(value: CreateAccountOp, io: Buffer): void;
  isValid(value: CreateAccountOp): boolean;
  toXDR(value: CreateAccountOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): CreateAccountOp;
  fromXDR(input: string, format: 'hex' | 'base64'): CreateAccountOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AssetType {
  readonly name: 'assetTypeNative' | 'assetTypeCreditAlphanum4' | 'assetTypeCreditAlphanum12' | 'assetTypePoolShare';
  readonly value: 0 | 1 | 2 | 3;
}
const _AssetType = createCompatEnum({
  codec: modern.AssetType,
  members: [
    { compat: 'assetTypeNative', modern: 'Native', value: 0 },
    { compat: 'assetTypeCreditAlphanum4', modern: 'CreditAlphanum4', value: 1 },
    { compat: 'assetTypeCreditAlphanum12', modern: 'CreditAlphanum12', value: 2 },
    { compat: 'assetTypePoolShare', modern: 'PoolShare', value: 3 },
  ],
});
export const AssetType = _AssetType as unknown as {
  assetTypeNative(): AssetType;
  assetTypeCreditAlphanum4(): AssetType;
  assetTypeCreditAlphanum12(): AssetType;
  assetTypePoolShare(): AssetType;
};

export type AssetCode4 = Buffer;
export const AssetCode4 = createCompatTypedef({ codec: modern.AssetCode4, convert: id });

export interface AlphaNum4 {
  assetCode(value?: AssetCode4): AssetCode4;
  issuer(value?: AccountId): AccountId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AlphaNum4 = createCompatStruct({
  codec: modern.AlphaNum4,
  fields: [
    { name: 'assetCode', modernName: 'assetCode', convert: id },
    { name: 'issuer', modernName: 'issuer', convert: unionConverter(_PublicKey) },
  ],
});
export const AlphaNum4 = _AlphaNum4 as unknown as {
  new(attributes: { assetCode: AssetCode4; issuer: AccountId }): AlphaNum4;
  read(io: Buffer): AlphaNum4;
  write(value: AlphaNum4, io: Buffer): void;
  isValid(value: AlphaNum4): boolean;
  toXDR(value: AlphaNum4): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AlphaNum4;
  fromXDR(input: string, format: 'hex' | 'base64'): AlphaNum4;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type AssetCode12 = Buffer;
export const AssetCode12 = createCompatTypedef({ codec: modern.AssetCode12, convert: id });

export interface AlphaNum12 {
  assetCode(value?: AssetCode12): AssetCode12;
  issuer(value?: AccountId): AccountId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AlphaNum12 = createCompatStruct({
  codec: modern.AlphaNum12,
  fields: [
    { name: 'assetCode', modernName: 'assetCode', convert: id },
    { name: 'issuer', modernName: 'issuer', convert: unionConverter(_PublicKey) },
  ],
});
export const AlphaNum12 = _AlphaNum12 as unknown as {
  new(attributes: { assetCode: AssetCode12; issuer: AccountId }): AlphaNum12;
  read(io: Buffer): AlphaNum12;
  write(value: AlphaNum12, io: Buffer): void;
  isValid(value: AlphaNum12): boolean;
  toXDR(value: AlphaNum12): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AlphaNum12;
  fromXDR(input: string, format: 'hex' | 'base64'): AlphaNum12;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Asset {
  switch(): AssetType;
  alphaNum4(value?: AlphaNum4): AlphaNum4;
  alphaNum12(value?: AlphaNum12): AlphaNum12;
  value(): AlphaNum4 | AlphaNum12 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Asset = createCompatUnion({
  codec: modern.Asset,
  switchEnum: _AssetType,
  arms: [
    { switchValues: ['assetTypeNative'], modern: 'Native' },
    { switchValues: ['assetTypeCreditAlphanum4'], modern: 'CreditAlphanum4', arm: 'alphaNum4', convert: structConverter(_AlphaNum4) },
    { switchValues: ['assetTypeCreditAlphanum12'], modern: 'CreditAlphanum12', arm: 'alphaNum12', convert: structConverter(_AlphaNum12) },
  ],
});
export const Asset = _Asset as unknown as {
  assetTypeNative(): Asset;
  assetTypeCreditAlphanum4(value: AlphaNum4): Asset;
  assetTypeCreditAlphanum12(value: AlphaNum12): Asset;
  read(io: Buffer): Asset;
  write(value: Asset, io: Buffer): void;
  isValid(value: Asset): boolean;
  toXDR(value: Asset): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Asset;
  fromXDR(input: string, format: 'hex' | 'base64'): Asset;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PaymentOp {
  destination(value?: MuxedAccount): MuxedAccount;
  asset(value?: Asset): Asset;
  amount(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PaymentOp = createCompatStruct({
  codec: modern.PaymentOp,
  fields: [
    { name: 'destination', modernName: 'destination', convert: unionConverter(_MuxedAccount) },
    { name: 'asset', modernName: 'asset', convert: unionConverter(_Asset) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
  ],
});
export const PaymentOp = _PaymentOp as unknown as {
  new(attributes: { destination: MuxedAccount; asset: Asset; amount: Int64 }): PaymentOp;
  read(io: Buffer): PaymentOp;
  write(value: PaymentOp, io: Buffer): void;
  isValid(value: PaymentOp): boolean;
  toXDR(value: PaymentOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PaymentOp;
  fromXDR(input: string, format: 'hex' | 'base64'): PaymentOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PathPaymentStrictReceiveOp {
  sendAsset(value?: Asset): Asset;
  sendMax(value?: Int64): Int64;
  destination(value?: MuxedAccount): MuxedAccount;
  destAsset(value?: Asset): Asset;
  destAmount(value?: Int64): Int64;
  path(value?: Asset[]): Asset[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PathPaymentStrictReceiveOp = createCompatStruct({
  codec: modern.PathPaymentStrictReceiveOp,
  fields: [
    { name: 'sendAsset', modernName: 'sendAsset', convert: unionConverter(_Asset) },
    { name: 'sendMax', modernName: 'sendMax', convert: int64Conv },
    { name: 'destination', modernName: 'destination', convert: unionConverter(_MuxedAccount) },
    { name: 'destAsset', modernName: 'destAsset', convert: unionConverter(_Asset) },
    { name: 'destAmount', modernName: 'destAmount', convert: int64Conv },
    { name: 'path', modernName: 'path', convert: arrayConverter(unionConverter(_Asset)) },
  ],
});
export const PathPaymentStrictReceiveOp = _PathPaymentStrictReceiveOp as unknown as {
  new(attributes: { sendAsset: Asset; sendMax: Int64; destination: MuxedAccount; destAsset: Asset; destAmount: Int64; path: Asset[] }): PathPaymentStrictReceiveOp;
  read(io: Buffer): PathPaymentStrictReceiveOp;
  write(value: PathPaymentStrictReceiveOp, io: Buffer): void;
  isValid(value: PathPaymentStrictReceiveOp): boolean;
  toXDR(value: PathPaymentStrictReceiveOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PathPaymentStrictReceiveOp;
  fromXDR(input: string, format: 'hex' | 'base64'): PathPaymentStrictReceiveOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Price {
  n(value?: Int32): Int32;
  d(value?: Int32): Int32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Price = createCompatStruct({
  codec: modern.Price,
  fields: [
    { name: 'n', modernName: 'n', convert: id },
    { name: 'd', modernName: 'd', convert: id },
  ],
});
export const Price = _Price as unknown as {
  new(attributes: { n: Int32; d: Int32 }): Price;
  read(io: Buffer): Price;
  write(value: Price, io: Buffer): void;
  isValid(value: Price): boolean;
  toXDR(value: Price): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Price;
  fromXDR(input: string, format: 'hex' | 'base64'): Price;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ManageSellOfferOp {
  selling(value?: Asset): Asset;
  buying(value?: Asset): Asset;
  amount(value?: Int64): Int64;
  price(value?: Price): Price;
  offerId(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ManageSellOfferOp = createCompatStruct({
  codec: modern.ManageSellOfferOp,
  fields: [
    { name: 'selling', modernName: 'selling', convert: unionConverter(_Asset) },
    { name: 'buying', modernName: 'buying', convert: unionConverter(_Asset) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
    { name: 'price', modernName: 'price', convert: structConverter(_Price) },
    { name: 'offerId', modernName: 'offerID', convert: int64Conv },
  ],
});
export const ManageSellOfferOp = _ManageSellOfferOp as unknown as {
  new(attributes: { selling: Asset; buying: Asset; amount: Int64; price: Price; offerId: Int64 }): ManageSellOfferOp;
  read(io: Buffer): ManageSellOfferOp;
  write(value: ManageSellOfferOp, io: Buffer): void;
  isValid(value: ManageSellOfferOp): boolean;
  toXDR(value: ManageSellOfferOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ManageSellOfferOp;
  fromXDR(input: string, format: 'hex' | 'base64'): ManageSellOfferOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface CreatePassiveSellOfferOp {
  selling(value?: Asset): Asset;
  buying(value?: Asset): Asset;
  amount(value?: Int64): Int64;
  price(value?: Price): Price;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _CreatePassiveSellOfferOp = createCompatStruct({
  codec: modern.CreatePassiveSellOfferOp,
  fields: [
    { name: 'selling', modernName: 'selling', convert: unionConverter(_Asset) },
    { name: 'buying', modernName: 'buying', convert: unionConverter(_Asset) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
    { name: 'price', modernName: 'price', convert: structConverter(_Price) },
  ],
});
export const CreatePassiveSellOfferOp = _CreatePassiveSellOfferOp as unknown as {
  new(attributes: { selling: Asset; buying: Asset; amount: Int64; price: Price }): CreatePassiveSellOfferOp;
  read(io: Buffer): CreatePassiveSellOfferOp;
  write(value: CreatePassiveSellOfferOp, io: Buffer): void;
  isValid(value: CreatePassiveSellOfferOp): boolean;
  toXDR(value: CreatePassiveSellOfferOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): CreatePassiveSellOfferOp;
  fromXDR(input: string, format: 'hex' | 'base64'): CreatePassiveSellOfferOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type String32 = string | Buffer;
export const String32 = createCompatTypedef({ codec: modern.String32, convert: id });

export interface SignerKeyType {
  readonly name: 'signerKeyTypeEd25519' | 'signerKeyTypePreAuthTx' | 'signerKeyTypeHashX' | 'signerKeyTypeEd25519SignedPayload';
  readonly value: 0 | 1 | 2 | 3;
}
const _SignerKeyType = createCompatEnum({
  codec: modern.SignerKeyType,
  members: [
    { compat: 'signerKeyTypeEd25519', modern: 'Ed25519', value: 0 },
    { compat: 'signerKeyTypePreAuthTx', modern: 'PreAuthTx', value: 1 },
    { compat: 'signerKeyTypeHashX', modern: 'HashX', value: 2 },
    { compat: 'signerKeyTypeEd25519SignedPayload', modern: 'Ed25519SignedPayload', value: 3 },
  ],
});
export const SignerKeyType = _SignerKeyType as unknown as {
  signerKeyTypeEd25519(): SignerKeyType;
  signerKeyTypePreAuthTx(): SignerKeyType;
  signerKeyTypeHashX(): SignerKeyType;
  signerKeyTypeEd25519SignedPayload(): SignerKeyType;
};

export interface SignerKeyEd25519SignedPayload {
  ed25519(value?: Uint256): Uint256;
  payload(value?: Buffer): Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SignerKeyEd25519SignedPayload = createCompatStruct({
  codec: modern.SignerKeyEd25519SignedPayload,
  fields: [
    { name: 'ed25519', modernName: 'ed25519', convert: id },
    { name: 'payload', modernName: 'payload', convert: id },
  ],
});
export const SignerKeyEd25519SignedPayload = _SignerKeyEd25519SignedPayload as unknown as {
  new(attributes: { ed25519: Uint256; payload: Buffer }): SignerKeyEd25519SignedPayload;
  read(io: Buffer): SignerKeyEd25519SignedPayload;
  write(value: SignerKeyEd25519SignedPayload, io: Buffer): void;
  isValid(value: SignerKeyEd25519SignedPayload): boolean;
  toXDR(value: SignerKeyEd25519SignedPayload): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SignerKeyEd25519SignedPayload;
  fromXDR(input: string, format: 'hex' | 'base64'): SignerKeyEd25519SignedPayload;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SignerKey {
  switch(): SignerKeyType;
  ed25519(value?: Uint256): Uint256;
  preAuthTx(value?: Uint256): Uint256;
  hashX(value?: Uint256): Uint256;
  ed25519SignedPayload(value?: SignerKeyEd25519SignedPayload): SignerKeyEd25519SignedPayload;
  value(): Uint256 | Uint256 | Uint256 | SignerKeyEd25519SignedPayload;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SignerKey = createCompatUnion({
  codec: modern.SignerKey,
  switchEnum: _SignerKeyType,
  arms: [
    { switchValues: ['signerKeyTypeEd25519'], modern: 'Ed25519', arm: 'ed25519', convert: id },
    { switchValues: ['signerKeyTypePreAuthTx'], modern: 'PreAuthTx', arm: 'preAuthTx', convert: id },
    { switchValues: ['signerKeyTypeHashX'], modern: 'HashX', arm: 'hashX', convert: id },
    { switchValues: ['signerKeyTypeEd25519SignedPayload'], modern: 'Ed25519SignedPayload', arm: 'ed25519SignedPayload', convert: id },
  ],
});
export const SignerKey = _SignerKey as unknown as {
  signerKeyTypeEd25519(value: Uint256): SignerKey;
  signerKeyTypePreAuthTx(value: Uint256): SignerKey;
  signerKeyTypeHashX(value: Uint256): SignerKey;
  signerKeyTypeEd25519SignedPayload(value: SignerKeyEd25519SignedPayload): SignerKey;
  read(io: Buffer): SignerKey;
  write(value: SignerKey, io: Buffer): void;
  isValid(value: SignerKey): boolean;
  toXDR(value: SignerKey): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SignerKey;
  fromXDR(input: string, format: 'hex' | 'base64'): SignerKey;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Signer {
  key(value?: SignerKey): SignerKey;
  weight(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Signer = createCompatStruct({
  codec: modern.Signer,
  fields: [
    { name: 'key', modernName: 'key', convert: unionConverter(_SignerKey) },
    { name: 'weight', modernName: 'weight', convert: id },
  ],
});
export const Signer = _Signer as unknown as {
  new(attributes: { key: SignerKey; weight: Uint32 }): Signer;
  read(io: Buffer): Signer;
  write(value: Signer, io: Buffer): void;
  isValid(value: Signer): boolean;
  toXDR(value: Signer): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Signer;
  fromXDR(input: string, format: 'hex' | 'base64'): Signer;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SetOptionsOp {
  inflationDest(value?: null | AccountId): null | AccountId;
  clearFlags(value?: null | Uint32): null | Uint32;
  setFlags(value?: null | Uint32): null | Uint32;
  masterWeight(value?: null | Uint32): null | Uint32;
  lowThreshold(value?: null | Uint32): null | Uint32;
  medThreshold(value?: null | Uint32): null | Uint32;
  highThreshold(value?: null | Uint32): null | Uint32;
  homeDomain(value?: null | String32): null | String32;
  signer(value?: null | Signer): null | Signer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SetOptionsOp = createCompatStruct({
  codec: modern.SetOptionsOp,
  fields: [
    { name: 'inflationDest', modernName: 'inflationDest', convert: optionConverter(unionConverter(_PublicKey)) },
    { name: 'clearFlags', modernName: 'clearFlags', convert: optionConverter(id) },
    { name: 'setFlags', modernName: 'setFlags', convert: optionConverter(id) },
    { name: 'masterWeight', modernName: 'masterWeight', convert: optionConverter(id) },
    { name: 'lowThreshold', modernName: 'lowThreshold', convert: optionConverter(id) },
    { name: 'medThreshold', modernName: 'medThreshold', convert: optionConverter(id) },
    { name: 'highThreshold', modernName: 'highThreshold', convert: optionConverter(id) },
    { name: 'homeDomain', modernName: 'homeDomain', convert: optionConverter(id) },
    { name: 'signer', modernName: 'signer', convert: optionConverter(structConverter(_Signer)) },
  ],
});
export const SetOptionsOp = _SetOptionsOp as unknown as {
  new(attributes: { inflationDest: null | AccountId; clearFlags: null | Uint32; setFlags: null | Uint32; masterWeight: null | Uint32; lowThreshold: null | Uint32; medThreshold: null | Uint32; highThreshold: null | Uint32; homeDomain: null | String32; signer: null | Signer }): SetOptionsOp;
  read(io: Buffer): SetOptionsOp;
  write(value: SetOptionsOp, io: Buffer): void;
  isValid(value: SetOptionsOp): boolean;
  toXDR(value: SetOptionsOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SetOptionsOp;
  fromXDR(input: string, format: 'hex' | 'base64'): SetOptionsOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolType {
  readonly name: 'liquidityPoolConstantProduct';
  readonly value: 0;
}
const _LiquidityPoolType = createCompatEnum({
  codec: modern.LiquidityPoolType,
  members: [
    { compat: 'liquidityPoolConstantProduct', modern: 'LiquidityPoolConstantProduct', value: 0 },
  ],
});
export const LiquidityPoolType = _LiquidityPoolType as unknown as {
  liquidityPoolConstantProduct(): LiquidityPoolType;
};

export interface LiquidityPoolConstantProductParameters {
  assetA(value?: Asset): Asset;
  assetB(value?: Asset): Asset;
  fee(value?: Int32): Int32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolConstantProductParameters = createCompatStruct({
  codec: modern.LiquidityPoolConstantProductParameters,
  fields: [
    { name: 'assetA', modernName: 'assetA', convert: unionConverter(_Asset) },
    { name: 'assetB', modernName: 'assetB', convert: unionConverter(_Asset) },
    { name: 'fee', modernName: 'fee', convert: id },
  ],
});
export const LiquidityPoolConstantProductParameters = _LiquidityPoolConstantProductParameters as unknown as {
  new(attributes: { assetA: Asset; assetB: Asset; fee: Int32 }): LiquidityPoolConstantProductParameters;
  read(io: Buffer): LiquidityPoolConstantProductParameters;
  write(value: LiquidityPoolConstantProductParameters, io: Buffer): void;
  isValid(value: LiquidityPoolConstantProductParameters): boolean;
  toXDR(value: LiquidityPoolConstantProductParameters): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolConstantProductParameters;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolConstantProductParameters;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolParameters {
  switch(): LiquidityPoolType;
  constantProduct(value?: LiquidityPoolConstantProductParameters): LiquidityPoolConstantProductParameters;
  value(): LiquidityPoolConstantProductParameters;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolParameters = createCompatUnion({
  codec: modern.LiquidityPoolParameters,
  switchEnum: _LiquidityPoolType,
  arms: [
    { switchValues: ['liquidityPoolConstantProduct'], modern: 'LiquidityPoolConstantProduct', arm: 'constantProduct', convert: structConverter(_LiquidityPoolConstantProductParameters) },
  ],
});
export const LiquidityPoolParameters = _LiquidityPoolParameters as unknown as {
  liquidityPoolConstantProduct(value: LiquidityPoolConstantProductParameters): LiquidityPoolParameters;
  read(io: Buffer): LiquidityPoolParameters;
  write(value: LiquidityPoolParameters, io: Buffer): void;
  isValid(value: LiquidityPoolParameters): boolean;
  toXDR(value: LiquidityPoolParameters): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolParameters;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolParameters;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ChangeTrustAsset {
  switch(): AssetType;
  alphaNum4(value?: AlphaNum4): AlphaNum4;
  alphaNum12(value?: AlphaNum12): AlphaNum12;
  liquidityPool(value?: LiquidityPoolParameters): LiquidityPoolParameters;
  value(): AlphaNum4 | AlphaNum12 | LiquidityPoolParameters | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ChangeTrustAsset = createCompatUnion({
  codec: modern.ChangeTrustAsset,
  switchEnum: _AssetType,
  arms: [
    { switchValues: ['assetTypeNative'], modern: 'Native' },
    { switchValues: ['assetTypeCreditAlphanum4'], modern: 'CreditAlphanum4', arm: 'alphaNum4', convert: structConverter(_AlphaNum4) },
    { switchValues: ['assetTypeCreditAlphanum12'], modern: 'CreditAlphanum12', arm: 'alphaNum12', convert: structConverter(_AlphaNum12) },
    { switchValues: ['assetTypePoolShare'], modern: 'PoolShare', arm: 'liquidityPool', convert: unionConverter(_LiquidityPoolParameters) },
  ],
});
export const ChangeTrustAsset = _ChangeTrustAsset as unknown as {
  assetTypeNative(): ChangeTrustAsset;
  assetTypeCreditAlphanum4(value: AlphaNum4): ChangeTrustAsset;
  assetTypeCreditAlphanum12(value: AlphaNum12): ChangeTrustAsset;
  assetTypePoolShare(value: LiquidityPoolParameters): ChangeTrustAsset;
  read(io: Buffer): ChangeTrustAsset;
  write(value: ChangeTrustAsset, io: Buffer): void;
  isValid(value: ChangeTrustAsset): boolean;
  toXDR(value: ChangeTrustAsset): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ChangeTrustAsset;
  fromXDR(input: string, format: 'hex' | 'base64'): ChangeTrustAsset;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ChangeTrustOp {
  line(value?: ChangeTrustAsset): ChangeTrustAsset;
  limit(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ChangeTrustOp = createCompatStruct({
  codec: modern.ChangeTrustOp,
  fields: [
    { name: 'line', modernName: 'line', convert: unionConverter(_ChangeTrustAsset) },
    { name: 'limit', modernName: 'limit', convert: int64Conv },
  ],
});
export const ChangeTrustOp = _ChangeTrustOp as unknown as {
  new(attributes: { line: ChangeTrustAsset; limit: Int64 }): ChangeTrustOp;
  read(io: Buffer): ChangeTrustOp;
  write(value: ChangeTrustOp, io: Buffer): void;
  isValid(value: ChangeTrustOp): boolean;
  toXDR(value: ChangeTrustOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ChangeTrustOp;
  fromXDR(input: string, format: 'hex' | 'base64'): ChangeTrustOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AssetCode {
  switch(): AssetType;
  assetCode4(value?: AssetCode4): AssetCode4;
  assetCode12(value?: AssetCode12): AssetCode12;
  value(): AssetCode4 | AssetCode12;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AssetCode = createCompatUnion({
  codec: modern.AssetCode,
  switchEnum: _AssetType,
  arms: [
    { switchValues: ['assetTypeCreditAlphanum4'], modern: 'CreditAlphanum4', arm: 'assetCode4', convert: id },
    { switchValues: ['assetTypeCreditAlphanum12'], modern: 'CreditAlphanum12', arm: 'assetCode12', convert: id },
  ],
});
export const AssetCode = _AssetCode as unknown as {
  assetTypeCreditAlphanum4(value: AssetCode4): AssetCode;
  assetTypeCreditAlphanum12(value: AssetCode12): AssetCode;
  read(io: Buffer): AssetCode;
  write(value: AssetCode, io: Buffer): void;
  isValid(value: AssetCode): boolean;
  toXDR(value: AssetCode): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AssetCode;
  fromXDR(input: string, format: 'hex' | 'base64'): AssetCode;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AllowTrustOp {
  trustor(value?: AccountId): AccountId;
  asset(value?: AssetCode): AssetCode;
  authorize(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AllowTrustOp = createCompatStruct({
  codec: modern.AllowTrustOp,
  fields: [
    { name: 'trustor', modernName: 'trustor', convert: unionConverter(_PublicKey) },
    { name: 'asset', modernName: 'asset', convert: unionConverter(_AssetCode) },
    { name: 'authorize', modernName: 'authorize', convert: id },
  ],
});
export const AllowTrustOp = _AllowTrustOp as unknown as {
  new(attributes: { trustor: AccountId; asset: AssetCode; authorize: Uint32 }): AllowTrustOp;
  read(io: Buffer): AllowTrustOp;
  write(value: AllowTrustOp, io: Buffer): void;
  isValid(value: AllowTrustOp): boolean;
  toXDR(value: AllowTrustOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AllowTrustOp;
  fromXDR(input: string, format: 'hex' | 'base64'): AllowTrustOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type String64 = string | Buffer;
export const String64 = createCompatTypedef({ codec: modern.String64, convert: id });

export type DataValue = Buffer;
export const DataValue = createCompatTypedef({ codec: modern.DataValue, convert: id });

export interface ManageDataOp {
  dataName(value?: String64): String64;
  dataValue(value?: null | DataValue): null | DataValue;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ManageDataOp = createCompatStruct({
  codec: modern.ManageDataOp,
  fields: [
    { name: 'dataName', modernName: 'dataName', convert: id },
    { name: 'dataValue', modernName: 'dataValue', convert: optionConverter(id) },
  ],
});
export const ManageDataOp = _ManageDataOp as unknown as {
  new(attributes: { dataName: String64; dataValue: null | DataValue }): ManageDataOp;
  read(io: Buffer): ManageDataOp;
  write(value: ManageDataOp, io: Buffer): void;
  isValid(value: ManageDataOp): boolean;
  toXDR(value: ManageDataOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ManageDataOp;
  fromXDR(input: string, format: 'hex' | 'base64'): ManageDataOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface BumpSequenceOp {
  bumpTo(value?: SequenceNumber): SequenceNumber;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _BumpSequenceOp = createCompatStruct({
  codec: modern.BumpSequenceOp,
  fields: [
    { name: 'bumpTo', modernName: 'bumpTo', convert: int64Conv },
  ],
});
export const BumpSequenceOp = _BumpSequenceOp as unknown as {
  new(attributes: { bumpTo: SequenceNumber }): BumpSequenceOp;
  read(io: Buffer): BumpSequenceOp;
  write(value: BumpSequenceOp, io: Buffer): void;
  isValid(value: BumpSequenceOp): boolean;
  toXDR(value: BumpSequenceOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): BumpSequenceOp;
  fromXDR(input: string, format: 'hex' | 'base64'): BumpSequenceOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ManageBuyOfferOp {
  selling(value?: Asset): Asset;
  buying(value?: Asset): Asset;
  buyAmount(value?: Int64): Int64;
  price(value?: Price): Price;
  offerId(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ManageBuyOfferOp = createCompatStruct({
  codec: modern.ManageBuyOfferOp,
  fields: [
    { name: 'selling', modernName: 'selling', convert: unionConverter(_Asset) },
    { name: 'buying', modernName: 'buying', convert: unionConverter(_Asset) },
    { name: 'buyAmount', modernName: 'buyAmount', convert: int64Conv },
    { name: 'price', modernName: 'price', convert: structConverter(_Price) },
    { name: 'offerId', modernName: 'offerID', convert: int64Conv },
  ],
});
export const ManageBuyOfferOp = _ManageBuyOfferOp as unknown as {
  new(attributes: { selling: Asset; buying: Asset; buyAmount: Int64; price: Price; offerId: Int64 }): ManageBuyOfferOp;
  read(io: Buffer): ManageBuyOfferOp;
  write(value: ManageBuyOfferOp, io: Buffer): void;
  isValid(value: ManageBuyOfferOp): boolean;
  toXDR(value: ManageBuyOfferOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ManageBuyOfferOp;
  fromXDR(input: string, format: 'hex' | 'base64'): ManageBuyOfferOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PathPaymentStrictSendOp {
  sendAsset(value?: Asset): Asset;
  sendAmount(value?: Int64): Int64;
  destination(value?: MuxedAccount): MuxedAccount;
  destAsset(value?: Asset): Asset;
  destMin(value?: Int64): Int64;
  path(value?: Asset[]): Asset[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PathPaymentStrictSendOp = createCompatStruct({
  codec: modern.PathPaymentStrictSendOp,
  fields: [
    { name: 'sendAsset', modernName: 'sendAsset', convert: unionConverter(_Asset) },
    { name: 'sendAmount', modernName: 'sendAmount', convert: int64Conv },
    { name: 'destination', modernName: 'destination', convert: unionConverter(_MuxedAccount) },
    { name: 'destAsset', modernName: 'destAsset', convert: unionConverter(_Asset) },
    { name: 'destMin', modernName: 'destMin', convert: int64Conv },
    { name: 'path', modernName: 'path', convert: arrayConverter(unionConverter(_Asset)) },
  ],
});
export const PathPaymentStrictSendOp = _PathPaymentStrictSendOp as unknown as {
  new(attributes: { sendAsset: Asset; sendAmount: Int64; destination: MuxedAccount; destAsset: Asset; destMin: Int64; path: Asset[] }): PathPaymentStrictSendOp;
  read(io: Buffer): PathPaymentStrictSendOp;
  write(value: PathPaymentStrictSendOp, io: Buffer): void;
  isValid(value: PathPaymentStrictSendOp): boolean;
  toXDR(value: PathPaymentStrictSendOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PathPaymentStrictSendOp;
  fromXDR(input: string, format: 'hex' | 'base64'): PathPaymentStrictSendOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimantType {
  readonly name: 'claimantTypeV0';
  readonly value: 0;
}
const _ClaimantType = createCompatEnum({
  codec: modern.ClaimantType,
  members: [
    { compat: 'claimantTypeV0', modern: 'ClaimantTypeV0', value: 0 },
  ],
});
export const ClaimantType = _ClaimantType as unknown as {
  claimantTypeV0(): ClaimantType;
};

export interface ClaimPredicateType {
  readonly name: 'claimPredicateUnconditional' | 'claimPredicateAnd' | 'claimPredicateOr' | 'claimPredicateNot' | 'claimPredicateBeforeAbsoluteTime' | 'claimPredicateBeforeRelativeTime';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5;
}
const _ClaimPredicateType = createCompatEnum({
  codec: modern.ClaimPredicateType,
  members: [
    { compat: 'claimPredicateUnconditional', modern: 'Unconditional', value: 0 },
    { compat: 'claimPredicateAnd', modern: 'And', value: 1 },
    { compat: 'claimPredicateOr', modern: 'Or', value: 2 },
    { compat: 'claimPredicateNot', modern: 'Not', value: 3 },
    { compat: 'claimPredicateBeforeAbsoluteTime', modern: 'BeforeAbsoluteTime', value: 4 },
    { compat: 'claimPredicateBeforeRelativeTime', modern: 'BeforeRelativeTime', value: 5 },
  ],
});
export const ClaimPredicateType = _ClaimPredicateType as unknown as {
  claimPredicateUnconditional(): ClaimPredicateType;
  claimPredicateAnd(): ClaimPredicateType;
  claimPredicateOr(): ClaimPredicateType;
  claimPredicateNot(): ClaimPredicateType;
  claimPredicateBeforeAbsoluteTime(): ClaimPredicateType;
  claimPredicateBeforeRelativeTime(): ClaimPredicateType;
};

export interface ClaimPredicate {
  switch(): ClaimPredicateType;
  andPredicates(value?: ClaimPredicate[]): ClaimPredicate[];
  orPredicates(value?: ClaimPredicate[]): ClaimPredicate[];
  notPredicate(value?: null | ClaimPredicate): null | ClaimPredicate;
  absBefore(value?: Int64): Int64;
  relBefore(value?: Int64): Int64;
  value(): ClaimPredicate[] | ClaimPredicate[] | null | ClaimPredicate | Int64 | Int64 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimPredicate = createCompatUnion({
  codec: modern.ClaimPredicate,
  switchEnum: _ClaimPredicateType,
  arms: [
    { switchValues: ['claimPredicateUnconditional'], modern: 'Unconditional' },
    { switchValues: ['claimPredicateAnd'], modern: 'And', arm: 'andPredicates', convert: arrayConverter(lazyConverter(() => unionConverter(_ClaimPredicate))) },
    { switchValues: ['claimPredicateOr'], modern: 'Or', arm: 'orPredicates', convert: arrayConverter(lazyConverter(() => unionConverter(_ClaimPredicate))) },
    { switchValues: ['claimPredicateNot'], modern: 'Not', arm: 'notPredicate', convert: optionConverter(lazyConverter(() => unionConverter(_ClaimPredicate))) },
    { switchValues: ['claimPredicateBeforeAbsoluteTime'], modern: 'BeforeAbsoluteTime', arm: 'absBefore', convert: int64Conv },
    { switchValues: ['claimPredicateBeforeRelativeTime'], modern: 'BeforeRelativeTime', arm: 'relBefore', convert: int64Conv },
  ],
});
export const ClaimPredicate = _ClaimPredicate as unknown as {
  claimPredicateUnconditional(): ClaimPredicate;
  claimPredicateAnd(value: ClaimPredicate[]): ClaimPredicate;
  claimPredicateOr(value: ClaimPredicate[]): ClaimPredicate;
  claimPredicateNot(value: null | ClaimPredicate): ClaimPredicate;
  claimPredicateBeforeAbsoluteTime(value: Int64): ClaimPredicate;
  claimPredicateBeforeRelativeTime(value: Int64): ClaimPredicate;
  read(io: Buffer): ClaimPredicate;
  write(value: ClaimPredicate, io: Buffer): void;
  isValid(value: ClaimPredicate): boolean;
  toXDR(value: ClaimPredicate): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimPredicate;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimPredicate;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimantV0 {
  destination(value?: AccountId): AccountId;
  predicate(value?: ClaimPredicate): ClaimPredicate;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimantV0 = createCompatStruct({
  codec: modern.ClaimantV0,
  fields: [
    { name: 'destination', modernName: 'destination', convert: unionConverter(_PublicKey) },
    { name: 'predicate', modernName: 'predicate', convert: lazyConverter(() => unionConverter(_ClaimPredicate)) },
  ],
});
export const ClaimantV0 = _ClaimantV0 as unknown as {
  new(attributes: { destination: AccountId; predicate: ClaimPredicate }): ClaimantV0;
  read(io: Buffer): ClaimantV0;
  write(value: ClaimantV0, io: Buffer): void;
  isValid(value: ClaimantV0): boolean;
  toXDR(value: ClaimantV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimantV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimantV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Claimant {
  switch(): ClaimantType;
  v0(value?: ClaimantV0): ClaimantV0;
  value(): ClaimantV0;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Claimant = createCompatUnion({
  codec: modern.Claimant,
  switchEnum: _ClaimantType,
  arms: [
    { switchValues: ['claimantTypeV0'], modern: 'ClaimantTypeV0', arm: 'v0', convert: id },
  ],
});
export const Claimant = _Claimant as unknown as {
  claimantTypeV0(value: ClaimantV0): Claimant;
  read(io: Buffer): Claimant;
  write(value: Claimant, io: Buffer): void;
  isValid(value: Claimant): boolean;
  toXDR(value: Claimant): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Claimant;
  fromXDR(input: string, format: 'hex' | 'base64'): Claimant;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface CreateClaimableBalanceOp {
  asset(value?: Asset): Asset;
  amount(value?: Int64): Int64;
  claimants(value?: Claimant[]): Claimant[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _CreateClaimableBalanceOp = createCompatStruct({
  codec: modern.CreateClaimableBalanceOp,
  fields: [
    { name: 'asset', modernName: 'asset', convert: unionConverter(_Asset) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
    { name: 'claimants', modernName: 'claimants', convert: arrayConverter(unionConverter(_Claimant)) },
  ],
});
export const CreateClaimableBalanceOp = _CreateClaimableBalanceOp as unknown as {
  new(attributes: { asset: Asset; amount: Int64; claimants: Claimant[] }): CreateClaimableBalanceOp;
  read(io: Buffer): CreateClaimableBalanceOp;
  write(value: CreateClaimableBalanceOp, io: Buffer): void;
  isValid(value: CreateClaimableBalanceOp): boolean;
  toXDR(value: CreateClaimableBalanceOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): CreateClaimableBalanceOp;
  fromXDR(input: string, format: 'hex' | 'base64'): CreateClaimableBalanceOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimClaimableBalanceOp {
  balanceId(value?: ClaimableBalanceId): ClaimableBalanceId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimClaimableBalanceOp = createCompatStruct({
  codec: modern.ClaimClaimableBalanceOp,
  fields: [
    { name: 'balanceId', modernName: 'balanceID', convert: unionConverter(_ClaimableBalanceId) },
  ],
});
export const ClaimClaimableBalanceOp = _ClaimClaimableBalanceOp as unknown as {
  new(attributes: { balanceId: ClaimableBalanceId }): ClaimClaimableBalanceOp;
  read(io: Buffer): ClaimClaimableBalanceOp;
  write(value: ClaimClaimableBalanceOp, io: Buffer): void;
  isValid(value: ClaimClaimableBalanceOp): boolean;
  toXDR(value: ClaimClaimableBalanceOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimClaimableBalanceOp;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimClaimableBalanceOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface BeginSponsoringFutureReservesOp {
  sponsoredId(value?: AccountId): AccountId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _BeginSponsoringFutureReservesOp = createCompatStruct({
  codec: modern.BeginSponsoringFutureReservesOp,
  fields: [
    { name: 'sponsoredId', modernName: 'sponsoredID', convert: unionConverter(_PublicKey) },
  ],
});
export const BeginSponsoringFutureReservesOp = _BeginSponsoringFutureReservesOp as unknown as {
  new(attributes: { sponsoredId: AccountId }): BeginSponsoringFutureReservesOp;
  read(io: Buffer): BeginSponsoringFutureReservesOp;
  write(value: BeginSponsoringFutureReservesOp, io: Buffer): void;
  isValid(value: BeginSponsoringFutureReservesOp): boolean;
  toXDR(value: BeginSponsoringFutureReservesOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): BeginSponsoringFutureReservesOp;
  fromXDR(input: string, format: 'hex' | 'base64'): BeginSponsoringFutureReservesOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface RevokeSponsorshipType {
  readonly name: 'revokeSponsorshipLedgerEntry' | 'revokeSponsorshipSigner';
  readonly value: 0 | 1;
}
const _RevokeSponsorshipType = createCompatEnum({
  codec: modern.RevokeSponsorshipType,
  members: [
    { compat: 'revokeSponsorshipLedgerEntry', modern: 'LedgerEntry', value: 0 },
    { compat: 'revokeSponsorshipSigner', modern: 'Signer', value: 1 },
  ],
});
export const RevokeSponsorshipType = _RevokeSponsorshipType as unknown as {
  revokeSponsorshipLedgerEntry(): RevokeSponsorshipType;
  revokeSponsorshipSigner(): RevokeSponsorshipType;
};

export interface LedgerEntryType {
  readonly name: 'account' | 'trustline' | 'offer' | 'data' | 'claimableBalance' | 'liquidityPool' | 'contractData' | 'contractCode' | 'configSetting' | 'ttl';
  readonly value: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
}
const _LedgerEntryType = createCompatEnum({
  codec: modern.LedgerEntryType,
  members: [
    { compat: 'account', modern: 'Account', value: 0 },
    { compat: 'trustline', modern: 'Trustline', value: 1 },
    { compat: 'offer', modern: 'Offer', value: 2 },
    { compat: 'data', modern: 'Data', value: 3 },
    { compat: 'claimableBalance', modern: 'ClaimableBalance', value: 4 },
    { compat: 'liquidityPool', modern: 'LiquidityPool', value: 5 },
    { compat: 'contractData', modern: 'ContractData', value: 6 },
    { compat: 'contractCode', modern: 'ContractCode', value: 7 },
    { compat: 'configSetting', modern: 'ConfigSetting', value: 8 },
    { compat: 'ttl', modern: 'Ttl', value: 9 },
  ],
});
export const LedgerEntryType = _LedgerEntryType as unknown as {
  account(): LedgerEntryType;
  trustline(): LedgerEntryType;
  offer(): LedgerEntryType;
  data(): LedgerEntryType;
  claimableBalance(): LedgerEntryType;
  liquidityPool(): LedgerEntryType;
  contractData(): LedgerEntryType;
  contractCode(): LedgerEntryType;
  configSetting(): LedgerEntryType;
  ttl(): LedgerEntryType;
};

export interface LedgerKeyAccount {
  accountId(value?: AccountId): AccountId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyAccount = createCompatStruct({
  codec: modern.LedgerKeyAccount,
  fields: [
    { name: 'accountId', modernName: 'accountID', convert: unionConverter(_PublicKey) },
  ],
});
export const LedgerKeyAccount = _LedgerKeyAccount as unknown as {
  new(attributes: { accountId: AccountId }): LedgerKeyAccount;
  read(io: Buffer): LedgerKeyAccount;
  write(value: LedgerKeyAccount, io: Buffer): void;
  isValid(value: LedgerKeyAccount): boolean;
  toXDR(value: LedgerKeyAccount): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyAccount;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyAccount;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TrustLineAsset {
  switch(): AssetType;
  alphaNum4(value?: AlphaNum4): AlphaNum4;
  alphaNum12(value?: AlphaNum12): AlphaNum12;
  liquidityPoolId(value?: PoolId): PoolId;
  value(): AlphaNum4 | AlphaNum12 | PoolId | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TrustLineAsset = createCompatUnion({
  codec: modern.TrustLineAsset,
  switchEnum: _AssetType,
  arms: [
    { switchValues: ['assetTypeNative'], modern: 'Native' },
    { switchValues: ['assetTypeCreditAlphanum4'], modern: 'CreditAlphanum4', arm: 'alphaNum4', convert: structConverter(_AlphaNum4) },
    { switchValues: ['assetTypeCreditAlphanum12'], modern: 'CreditAlphanum12', arm: 'alphaNum12', convert: structConverter(_AlphaNum12) },
    { switchValues: ['assetTypePoolShare'], modern: 'PoolShare', arm: 'liquidityPoolId', convert: id },
  ],
});
export const TrustLineAsset = _TrustLineAsset as unknown as {
  assetTypeNative(): TrustLineAsset;
  assetTypeCreditAlphanum4(value: AlphaNum4): TrustLineAsset;
  assetTypeCreditAlphanum12(value: AlphaNum12): TrustLineAsset;
  assetTypePoolShare(value: PoolId): TrustLineAsset;
  read(io: Buffer): TrustLineAsset;
  write(value: TrustLineAsset, io: Buffer): void;
  isValid(value: TrustLineAsset): boolean;
  toXDR(value: TrustLineAsset): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TrustLineAsset;
  fromXDR(input: string, format: 'hex' | 'base64'): TrustLineAsset;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKeyTrustLine {
  accountId(value?: AccountId): AccountId;
  asset(value?: TrustLineAsset): TrustLineAsset;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyTrustLine = createCompatStruct({
  codec: modern.LedgerKeyTrustLine,
  fields: [
    { name: 'accountId', modernName: 'accountID', convert: unionConverter(_PublicKey) },
    { name: 'asset', modernName: 'asset', convert: unionConverter(_TrustLineAsset) },
  ],
});
export const LedgerKeyTrustLine = _LedgerKeyTrustLine as unknown as {
  new(attributes: { accountId: AccountId; asset: TrustLineAsset }): LedgerKeyTrustLine;
  read(io: Buffer): LedgerKeyTrustLine;
  write(value: LedgerKeyTrustLine, io: Buffer): void;
  isValid(value: LedgerKeyTrustLine): boolean;
  toXDR(value: LedgerKeyTrustLine): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyTrustLine;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyTrustLine;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKeyOffer {
  sellerId(value?: AccountId): AccountId;
  offerId(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyOffer = createCompatStruct({
  codec: modern.LedgerKeyOffer,
  fields: [
    { name: 'sellerId', modernName: 'sellerID', convert: unionConverter(_PublicKey) },
    { name: 'offerId', modernName: 'offerID', convert: int64Conv },
  ],
});
export const LedgerKeyOffer = _LedgerKeyOffer as unknown as {
  new(attributes: { sellerId: AccountId; offerId: Int64 }): LedgerKeyOffer;
  read(io: Buffer): LedgerKeyOffer;
  write(value: LedgerKeyOffer, io: Buffer): void;
  isValid(value: LedgerKeyOffer): boolean;
  toXDR(value: LedgerKeyOffer): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyOffer;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyOffer;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKeyData {
  accountId(value?: AccountId): AccountId;
  dataName(value?: String64): String64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyData = createCompatStruct({
  codec: modern.LedgerKeyData,
  fields: [
    { name: 'accountId', modernName: 'accountID', convert: unionConverter(_PublicKey) },
    { name: 'dataName', modernName: 'dataName', convert: id },
  ],
});
export const LedgerKeyData = _LedgerKeyData as unknown as {
  new(attributes: { accountId: AccountId; dataName: String64 }): LedgerKeyData;
  read(io: Buffer): LedgerKeyData;
  write(value: LedgerKeyData, io: Buffer): void;
  isValid(value: LedgerKeyData): boolean;
  toXDR(value: LedgerKeyData): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyData;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyData;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKeyClaimableBalance {
  balanceId(value?: ClaimableBalanceId): ClaimableBalanceId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyClaimableBalance = createCompatStruct({
  codec: modern.LedgerKeyClaimableBalance,
  fields: [
    { name: 'balanceId', modernName: 'balanceID', convert: unionConverter(_ClaimableBalanceId) },
  ],
});
export const LedgerKeyClaimableBalance = _LedgerKeyClaimableBalance as unknown as {
  new(attributes: { balanceId: ClaimableBalanceId }): LedgerKeyClaimableBalance;
  read(io: Buffer): LedgerKeyClaimableBalance;
  write(value: LedgerKeyClaimableBalance, io: Buffer): void;
  isValid(value: LedgerKeyClaimableBalance): boolean;
  toXDR(value: LedgerKeyClaimableBalance): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyClaimableBalance;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyClaimableBalance;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKeyLiquidityPool {
  liquidityPoolId(value?: PoolId): PoolId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyLiquidityPool = createCompatStruct({
  codec: modern.LedgerKeyLiquidityPool,
  fields: [
    { name: 'liquidityPoolId', modernName: 'liquidityPoolID', convert: id },
  ],
});
export const LedgerKeyLiquidityPool = _LedgerKeyLiquidityPool as unknown as {
  new(attributes: { liquidityPoolId: PoolId }): LedgerKeyLiquidityPool;
  read(io: Buffer): LedgerKeyLiquidityPool;
  write(value: LedgerKeyLiquidityPool, io: Buffer): void;
  isValid(value: LedgerKeyLiquidityPool): boolean;
  toXDR(value: LedgerKeyLiquidityPool): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyLiquidityPool;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyLiquidityPool;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractDataDurability {
  readonly name: 'temporary' | 'persistent';
  readonly value: 0 | 1;
}
const _ContractDataDurability = createCompatEnum({
  codec: modern.ContractDataDurability,
  members: [
    { compat: 'temporary', modern: 'Temporary', value: 0 },
    { compat: 'persistent', modern: 'Persistent', value: 1 },
  ],
});
export const ContractDataDurability = _ContractDataDurability as unknown as {
  temporary(): ContractDataDurability;
  persistent(): ContractDataDurability;
};

export interface LedgerKeyContractData {
  contract(value?: ScAddress): ScAddress;
  key(value?: ScVal): ScVal;
  durability(value?: ContractDataDurability): ContractDataDurability;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyContractData = createCompatStruct({
  codec: modern.LedgerKeyContractData,
  fields: [
    { name: 'contract', modernName: 'contract', convert: unionConverter(_ScAddress) },
    { name: 'key', modernName: 'key', convert: lazyConverter(() => unionConverter(_ScVal)) },
    { name: 'durability', modernName: 'durability', convert: enumConverter(_ContractDataDurability) },
  ],
});
export const LedgerKeyContractData = _LedgerKeyContractData as unknown as {
  new(attributes: { contract: ScAddress; key: ScVal; durability: ContractDataDurability }): LedgerKeyContractData;
  read(io: Buffer): LedgerKeyContractData;
  write(value: LedgerKeyContractData, io: Buffer): void;
  isValid(value: LedgerKeyContractData): boolean;
  toXDR(value: LedgerKeyContractData): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyContractData;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyContractData;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKeyContractCode {
  hash(value?: Hash): Hash;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyContractCode = createCompatStruct({
  codec: modern.LedgerKeyContractCode,
  fields: [
    { name: 'hash', modernName: 'hash', convert: id },
  ],
});
export const LedgerKeyContractCode = _LedgerKeyContractCode as unknown as {
  new(attributes: { hash: Hash }): LedgerKeyContractCode;
  read(io: Buffer): LedgerKeyContractCode;
  write(value: LedgerKeyContractCode, io: Buffer): void;
  isValid(value: LedgerKeyContractCode): boolean;
  toXDR(value: LedgerKeyContractCode): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyContractCode;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyContractCode;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKeyConfigSetting {
  configSettingId(value?: ConfigSettingId): ConfigSettingId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyConfigSetting = createCompatStruct({
  codec: modern.LedgerKeyConfigSetting,
  fields: [
    { name: 'configSettingId', modernName: 'configSettingID', convert: enumConverter(_ConfigSettingId) },
  ],
});
export const LedgerKeyConfigSetting = _LedgerKeyConfigSetting as unknown as {
  new(attributes: { configSettingId: ConfigSettingId }): LedgerKeyConfigSetting;
  read(io: Buffer): LedgerKeyConfigSetting;
  write(value: LedgerKeyConfigSetting, io: Buffer): void;
  isValid(value: LedgerKeyConfigSetting): boolean;
  toXDR(value: LedgerKeyConfigSetting): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyConfigSetting;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyConfigSetting;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKeyTtl {
  keyHash(value?: Hash): Hash;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKeyTtl = createCompatStruct({
  codec: modern.LedgerKeyTtl,
  fields: [
    { name: 'keyHash', modernName: 'keyHash', convert: id },
  ],
});
export const LedgerKeyTtl = _LedgerKeyTtl as unknown as {
  new(attributes: { keyHash: Hash }): LedgerKeyTtl;
  read(io: Buffer): LedgerKeyTtl;
  write(value: LedgerKeyTtl, io: Buffer): void;
  isValid(value: LedgerKeyTtl): boolean;
  toXDR(value: LedgerKeyTtl): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKeyTtl;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKeyTtl;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerKey {
  switch(): LedgerEntryType;
  account(value?: LedgerKeyAccount): LedgerKeyAccount;
  trustLine(value?: LedgerKeyTrustLine): LedgerKeyTrustLine;
  offer(value?: LedgerKeyOffer): LedgerKeyOffer;
  data(value?: LedgerKeyData): LedgerKeyData;
  claimableBalance(value?: LedgerKeyClaimableBalance): LedgerKeyClaimableBalance;
  liquidityPool(value?: LedgerKeyLiquidityPool): LedgerKeyLiquidityPool;
  contractData(value?: LedgerKeyContractData): LedgerKeyContractData;
  contractCode(value?: LedgerKeyContractCode): LedgerKeyContractCode;
  configSetting(value?: LedgerKeyConfigSetting): LedgerKeyConfigSetting;
  ttl(value?: LedgerKeyTtl): LedgerKeyTtl;
  value(): LedgerKeyAccount | LedgerKeyTrustLine | LedgerKeyOffer | LedgerKeyData | LedgerKeyClaimableBalance | LedgerKeyLiquidityPool | LedgerKeyContractData | LedgerKeyContractCode | LedgerKeyConfigSetting | LedgerKeyTtl;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerKey = createCompatUnion({
  codec: modern.LedgerKey,
  switchEnum: _LedgerEntryType,
  arms: [
    { switchValues: ['account'], modern: 'Account', arm: 'account', convert: id },
    { switchValues: ['trustline'], modern: 'Trustline', arm: 'trustLine', convert: id },
    { switchValues: ['offer'], modern: 'Offer', arm: 'offer', convert: id },
    { switchValues: ['data'], modern: 'Data', arm: 'data', convert: id },
    { switchValues: ['claimableBalance'], modern: 'ClaimableBalance', arm: 'claimableBalance', convert: id },
    { switchValues: ['liquidityPool'], modern: 'LiquidityPool', arm: 'liquidityPool', convert: id },
    { switchValues: ['contractData'], modern: 'ContractData', arm: 'contractData', convert: id },
    { switchValues: ['contractCode'], modern: 'ContractCode', arm: 'contractCode', convert: id },
    { switchValues: ['configSetting'], modern: 'ConfigSetting', arm: 'configSetting', convert: id },
    { switchValues: ['ttl'], modern: 'Ttl', arm: 'ttl', convert: id },
  ],
});
export const LedgerKey = _LedgerKey as unknown as {
  account(value: LedgerKeyAccount): LedgerKey;
  trustline(value: LedgerKeyTrustLine): LedgerKey;
  offer(value: LedgerKeyOffer): LedgerKey;
  data(value: LedgerKeyData): LedgerKey;
  claimableBalance(value: LedgerKeyClaimableBalance): LedgerKey;
  liquidityPool(value: LedgerKeyLiquidityPool): LedgerKey;
  contractData(value: LedgerKeyContractData): LedgerKey;
  contractCode(value: LedgerKeyContractCode): LedgerKey;
  configSetting(value: LedgerKeyConfigSetting): LedgerKey;
  ttl(value: LedgerKeyTtl): LedgerKey;
  read(io: Buffer): LedgerKey;
  write(value: LedgerKey, io: Buffer): void;
  isValid(value: LedgerKey): boolean;
  toXDR(value: LedgerKey): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerKey;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerKey;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface RevokeSponsorshipOpSigner {
  accountId(value?: AccountId): AccountId;
  signerKey(value?: SignerKey): SignerKey;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _RevokeSponsorshipOpSigner = createCompatStruct({
  codec: modern.RevokeSponsorshipOpSigner,
  fields: [
    { name: 'accountId', modernName: 'accountID', convert: unionConverter(_PublicKey) },
    { name: 'signerKey', modernName: 'signerKey', convert: unionConverter(_SignerKey) },
  ],
});
export const RevokeSponsorshipOpSigner = _RevokeSponsorshipOpSigner as unknown as {
  new(attributes: { accountId: AccountId; signerKey: SignerKey }): RevokeSponsorshipOpSigner;
  read(io: Buffer): RevokeSponsorshipOpSigner;
  write(value: RevokeSponsorshipOpSigner, io: Buffer): void;
  isValid(value: RevokeSponsorshipOpSigner): boolean;
  toXDR(value: RevokeSponsorshipOpSigner): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): RevokeSponsorshipOpSigner;
  fromXDR(input: string, format: 'hex' | 'base64'): RevokeSponsorshipOpSigner;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface RevokeSponsorshipOp {
  switch(): RevokeSponsorshipType;
  ledgerKey(value?: LedgerKey): LedgerKey;
  signer(value?: RevokeSponsorshipOpSigner): RevokeSponsorshipOpSigner;
  value(): LedgerKey | RevokeSponsorshipOpSigner;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _RevokeSponsorshipOp = createCompatUnion({
  codec: modern.RevokeSponsorshipOp,
  switchEnum: _RevokeSponsorshipType,
  arms: [
    { switchValues: ['revokeSponsorshipLedgerEntry'], modern: 'LedgerEntry', arm: 'ledgerKey', convert: unionConverter(_LedgerKey) },
    { switchValues: ['revokeSponsorshipSigner'], modern: 'Signer', arm: 'signer', convert: id },
  ],
});
export const RevokeSponsorshipOp = _RevokeSponsorshipOp as unknown as {
  revokeSponsorshipLedgerEntry(value: LedgerKey): RevokeSponsorshipOp;
  revokeSponsorshipSigner(value: RevokeSponsorshipOpSigner): RevokeSponsorshipOp;
  read(io: Buffer): RevokeSponsorshipOp;
  write(value: RevokeSponsorshipOp, io: Buffer): void;
  isValid(value: RevokeSponsorshipOp): boolean;
  toXDR(value: RevokeSponsorshipOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): RevokeSponsorshipOp;
  fromXDR(input: string, format: 'hex' | 'base64'): RevokeSponsorshipOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClawbackOp {
  asset(value?: Asset): Asset;
  from(value?: MuxedAccount): MuxedAccount;
  amount(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClawbackOp = createCompatStruct({
  codec: modern.ClawbackOp,
  fields: [
    { name: 'asset', modernName: 'asset', convert: unionConverter(_Asset) },
    { name: 'from', modernName: 'from', convert: unionConverter(_MuxedAccount) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
  ],
});
export const ClawbackOp = _ClawbackOp as unknown as {
  new(attributes: { asset: Asset; from: MuxedAccount; amount: Int64 }): ClawbackOp;
  read(io: Buffer): ClawbackOp;
  write(value: ClawbackOp, io: Buffer): void;
  isValid(value: ClawbackOp): boolean;
  toXDR(value: ClawbackOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClawbackOp;
  fromXDR(input: string, format: 'hex' | 'base64'): ClawbackOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClawbackClaimableBalanceOp {
  balanceId(value?: ClaimableBalanceId): ClaimableBalanceId;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClawbackClaimableBalanceOp = createCompatStruct({
  codec: modern.ClawbackClaimableBalanceOp,
  fields: [
    { name: 'balanceId', modernName: 'balanceID', convert: unionConverter(_ClaimableBalanceId) },
  ],
});
export const ClawbackClaimableBalanceOp = _ClawbackClaimableBalanceOp as unknown as {
  new(attributes: { balanceId: ClaimableBalanceId }): ClawbackClaimableBalanceOp;
  read(io: Buffer): ClawbackClaimableBalanceOp;
  write(value: ClawbackClaimableBalanceOp, io: Buffer): void;
  isValid(value: ClawbackClaimableBalanceOp): boolean;
  toXDR(value: ClawbackClaimableBalanceOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClawbackClaimableBalanceOp;
  fromXDR(input: string, format: 'hex' | 'base64'): ClawbackClaimableBalanceOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SetTrustLineFlagsOp {
  trustor(value?: AccountId): AccountId;
  asset(value?: Asset): Asset;
  clearFlags(value?: Uint32): Uint32;
  setFlags(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SetTrustLineFlagsOp = createCompatStruct({
  codec: modern.SetTrustLineFlagsOp,
  fields: [
    { name: 'trustor', modernName: 'trustor', convert: unionConverter(_PublicKey) },
    { name: 'asset', modernName: 'asset', convert: unionConverter(_Asset) },
    { name: 'clearFlags', modernName: 'clearFlags', convert: id },
    { name: 'setFlags', modernName: 'setFlags', convert: id },
  ],
});
export const SetTrustLineFlagsOp = _SetTrustLineFlagsOp as unknown as {
  new(attributes: { trustor: AccountId; asset: Asset; clearFlags: Uint32; setFlags: Uint32 }): SetTrustLineFlagsOp;
  read(io: Buffer): SetTrustLineFlagsOp;
  write(value: SetTrustLineFlagsOp, io: Buffer): void;
  isValid(value: SetTrustLineFlagsOp): boolean;
  toXDR(value: SetTrustLineFlagsOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SetTrustLineFlagsOp;
  fromXDR(input: string, format: 'hex' | 'base64'): SetTrustLineFlagsOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolDepositOp {
  liquidityPoolId(value?: PoolId): PoolId;
  maxAmountA(value?: Int64): Int64;
  maxAmountB(value?: Int64): Int64;
  minPrice(value?: Price): Price;
  maxPrice(value?: Price): Price;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolDepositOp = createCompatStruct({
  codec: modern.LiquidityPoolDepositOp,
  fields: [
    { name: 'liquidityPoolId', modernName: 'liquidityPoolID', convert: id },
    { name: 'maxAmountA', modernName: 'maxAmountA', convert: int64Conv },
    { name: 'maxAmountB', modernName: 'maxAmountB', convert: int64Conv },
    { name: 'minPrice', modernName: 'minPrice', convert: structConverter(_Price) },
    { name: 'maxPrice', modernName: 'maxPrice', convert: structConverter(_Price) },
  ],
});
export const LiquidityPoolDepositOp = _LiquidityPoolDepositOp as unknown as {
  new(attributes: { liquidityPoolId: PoolId; maxAmountA: Int64; maxAmountB: Int64; minPrice: Price; maxPrice: Price }): LiquidityPoolDepositOp;
  read(io: Buffer): LiquidityPoolDepositOp;
  write(value: LiquidityPoolDepositOp, io: Buffer): void;
  isValid(value: LiquidityPoolDepositOp): boolean;
  toXDR(value: LiquidityPoolDepositOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolDepositOp;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolDepositOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolWithdrawOp {
  liquidityPoolId(value?: PoolId): PoolId;
  amount(value?: Int64): Int64;
  minAmountA(value?: Int64): Int64;
  minAmountB(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolWithdrawOp = createCompatStruct({
  codec: modern.LiquidityPoolWithdrawOp,
  fields: [
    { name: 'liquidityPoolId', modernName: 'liquidityPoolID', convert: id },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
    { name: 'minAmountA', modernName: 'minAmountA', convert: int64Conv },
    { name: 'minAmountB', modernName: 'minAmountB', convert: int64Conv },
  ],
});
export const LiquidityPoolWithdrawOp = _LiquidityPoolWithdrawOp as unknown as {
  new(attributes: { liquidityPoolId: PoolId; amount: Int64; minAmountA: Int64; minAmountB: Int64 }): LiquidityPoolWithdrawOp;
  read(io: Buffer): LiquidityPoolWithdrawOp;
  write(value: LiquidityPoolWithdrawOp, io: Buffer): void;
  isValid(value: LiquidityPoolWithdrawOp): boolean;
  toXDR(value: LiquidityPoolWithdrawOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolWithdrawOp;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolWithdrawOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HostFunctionType {
  readonly name: 'hostFunctionTypeInvokeContract' | 'hostFunctionTypeCreateContract' | 'hostFunctionTypeUploadContractWasm' | 'hostFunctionTypeCreateContractV2';
  readonly value: 0 | 1 | 2 | 3;
}
const _HostFunctionType = createCompatEnum({
  codec: modern.HostFunctionType,
  members: [
    { compat: 'hostFunctionTypeInvokeContract', modern: 'InvokeContract', value: 0 },
    { compat: 'hostFunctionTypeCreateContract', modern: 'CreateContract', value: 1 },
    { compat: 'hostFunctionTypeUploadContractWasm', modern: 'UploadContractWasm', value: 2 },
    { compat: 'hostFunctionTypeCreateContractV2', modern: 'CreateContractV2', value: 3 },
  ],
});
export const HostFunctionType = _HostFunctionType as unknown as {
  hostFunctionTypeInvokeContract(): HostFunctionType;
  hostFunctionTypeCreateContract(): HostFunctionType;
  hostFunctionTypeUploadContractWasm(): HostFunctionType;
  hostFunctionTypeCreateContractV2(): HostFunctionType;
};

export interface InvokeContractArgs {
  contractAddress(value?: ScAddress): ScAddress;
  functionName(value?: ScSymbol): ScSymbol;
  args(value?: ScVal[]): ScVal[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InvokeContractArgs = createCompatStruct({
  codec: modern.InvokeContractArgs,
  fields: [
    { name: 'contractAddress', modernName: 'contractAddress', convert: unionConverter(_ScAddress) },
    { name: 'functionName', modernName: 'functionName', convert: id },
    { name: 'args', modernName: 'args', convert: arrayConverter(lazyConverter(() => unionConverter(_ScVal))) },
  ],
});
export const InvokeContractArgs = _InvokeContractArgs as unknown as {
  new(attributes: { contractAddress: ScAddress; functionName: ScSymbol; args: ScVal[] }): InvokeContractArgs;
  read(io: Buffer): InvokeContractArgs;
  write(value: InvokeContractArgs, io: Buffer): void;
  isValid(value: InvokeContractArgs): boolean;
  toXDR(value: InvokeContractArgs): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InvokeContractArgs;
  fromXDR(input: string, format: 'hex' | 'base64'): InvokeContractArgs;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractIdPreimageType {
  readonly name: 'contractIdPreimageFromAddress' | 'contractIdPreimageFromAsset';
  readonly value: 0 | 1;
}
const _ContractIdPreimageType = createCompatEnum({
  codec: modern.ContractIDPreimageType,
  members: [
    { compat: 'contractIdPreimageFromAddress', modern: 'Address', value: 0 },
    { compat: 'contractIdPreimageFromAsset', modern: 'Asset', value: 1 },
  ],
});
export const ContractIdPreimageType = _ContractIdPreimageType as unknown as {
  contractIdPreimageFromAddress(): ContractIdPreimageType;
  contractIdPreimageFromAsset(): ContractIdPreimageType;
};

export interface ContractIdPreimageFromAddress {
  address(value?: ScAddress): ScAddress;
  salt(value?: Uint256): Uint256;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractIdPreimageFromAddress = createCompatStruct({
  codec: modern.ContractIDPreimageFromAddress,
  fields: [
    { name: 'address', modernName: 'address', convert: unionConverter(_ScAddress) },
    { name: 'salt', modernName: 'salt', convert: id },
  ],
});
export const ContractIdPreimageFromAddress = _ContractIdPreimageFromAddress as unknown as {
  new(attributes: { address: ScAddress; salt: Uint256 }): ContractIdPreimageFromAddress;
  read(io: Buffer): ContractIdPreimageFromAddress;
  write(value: ContractIdPreimageFromAddress, io: Buffer): void;
  isValid(value: ContractIdPreimageFromAddress): boolean;
  toXDR(value: ContractIdPreimageFromAddress): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractIdPreimageFromAddress;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractIdPreimageFromAddress;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractIdPreimage {
  switch(): ContractIdPreimageType;
  fromAddress(value?: ContractIdPreimageFromAddress): ContractIdPreimageFromAddress;
  fromAsset(value?: Asset): Asset;
  value(): ContractIdPreimageFromAddress | Asset;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractIdPreimage = createCompatUnion({
  codec: modern.ContractIDPreimage,
  switchEnum: _ContractIdPreimageType,
  arms: [
    { switchValues: ['contractIdPreimageFromAddress'], modern: 'Address', arm: 'fromAddress', convert: id },
    { switchValues: ['contractIdPreimageFromAsset'], modern: 'Asset', arm: 'fromAsset', convert: unionConverter(_Asset) },
  ],
});
export const ContractIdPreimage = _ContractIdPreimage as unknown as {
  contractIdPreimageFromAddress(value: ContractIdPreimageFromAddress): ContractIdPreimage;
  contractIdPreimageFromAsset(value: Asset): ContractIdPreimage;
  read(io: Buffer): ContractIdPreimage;
  write(value: ContractIdPreimage, io: Buffer): void;
  isValid(value: ContractIdPreimage): boolean;
  toXDR(value: ContractIdPreimage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractIdPreimage;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractIdPreimage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface CreateContractArgs {
  contractIdPreimage(value?: ContractIdPreimage): ContractIdPreimage;
  executable(value?: ContractExecutable): ContractExecutable;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _CreateContractArgs = createCompatStruct({
  codec: modern.CreateContractArgs,
  fields: [
    { name: 'contractIdPreimage', modernName: 'contractIDPreimage', convert: unionConverter(_ContractIdPreimage) },
    { name: 'executable', modernName: 'executable', convert: unionConverter(_ContractExecutable) },
  ],
});
export const CreateContractArgs = _CreateContractArgs as unknown as {
  new(attributes: { contractIdPreimage: ContractIdPreimage; executable: ContractExecutable }): CreateContractArgs;
  read(io: Buffer): CreateContractArgs;
  write(value: CreateContractArgs, io: Buffer): void;
  isValid(value: CreateContractArgs): boolean;
  toXDR(value: CreateContractArgs): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): CreateContractArgs;
  fromXDR(input: string, format: 'hex' | 'base64'): CreateContractArgs;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface CreateContractArgsV2 {
  contractIdPreimage(value?: ContractIdPreimage): ContractIdPreimage;
  executable(value?: ContractExecutable): ContractExecutable;
  constructorArgs(value?: ScVal[]): ScVal[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _CreateContractArgsV2 = createCompatStruct({
  codec: modern.CreateContractArgsV2,
  fields: [
    { name: 'contractIdPreimage', modernName: 'contractIDPreimage', convert: unionConverter(_ContractIdPreimage) },
    { name: 'executable', modernName: 'executable', convert: unionConverter(_ContractExecutable) },
    { name: 'constructorArgs', modernName: 'constructorArgs', convert: arrayConverter(lazyConverter(() => unionConverter(_ScVal))) },
  ],
});
export const CreateContractArgsV2 = _CreateContractArgsV2 as unknown as {
  new(attributes: { contractIdPreimage: ContractIdPreimage; executable: ContractExecutable; constructorArgs: ScVal[] }): CreateContractArgsV2;
  read(io: Buffer): CreateContractArgsV2;
  write(value: CreateContractArgsV2, io: Buffer): void;
  isValid(value: CreateContractArgsV2): boolean;
  toXDR(value: CreateContractArgsV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): CreateContractArgsV2;
  fromXDR(input: string, format: 'hex' | 'base64'): CreateContractArgsV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HostFunction {
  switch(): HostFunctionType;
  invokeContract(value?: InvokeContractArgs): InvokeContractArgs;
  createContract(value?: CreateContractArgs): CreateContractArgs;
  wasm(value?: Buffer): Buffer;
  createContractV2(value?: CreateContractArgsV2): CreateContractArgsV2;
  value(): InvokeContractArgs | CreateContractArgs | Buffer | CreateContractArgsV2;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HostFunction = createCompatUnion({
  codec: modern.HostFunction,
  switchEnum: _HostFunctionType,
  arms: [
    { switchValues: ['hostFunctionTypeInvokeContract'], modern: 'InvokeContract', arm: 'invokeContract', convert: structConverter(_InvokeContractArgs) },
    { switchValues: ['hostFunctionTypeCreateContract'], modern: 'CreateContract', arm: 'createContract', convert: structConverter(_CreateContractArgs) },
    { switchValues: ['hostFunctionTypeUploadContractWasm'], modern: 'UploadContractWasm', arm: 'wasm', convert: id },
    { switchValues: ['hostFunctionTypeCreateContractV2'], modern: 'CreateContractV2', arm: 'createContractV2', convert: structConverter(_CreateContractArgsV2) },
  ],
});
export const HostFunction = _HostFunction as unknown as {
  hostFunctionTypeInvokeContract(value: InvokeContractArgs): HostFunction;
  hostFunctionTypeCreateContract(value: CreateContractArgs): HostFunction;
  hostFunctionTypeUploadContractWasm(value: Buffer): HostFunction;
  hostFunctionTypeCreateContractV2(value: CreateContractArgsV2): HostFunction;
  read(io: Buffer): HostFunction;
  write(value: HostFunction, io: Buffer): void;
  isValid(value: HostFunction): boolean;
  toXDR(value: HostFunction): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HostFunction;
  fromXDR(input: string, format: 'hex' | 'base64'): HostFunction;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanCredentialsType {
  readonly name: 'sorobanCredentialsSourceAccount' | 'sorobanCredentialsAddress';
  readonly value: 0 | 1;
}
const _SorobanCredentialsType = createCompatEnum({
  codec: modern.SorobanCredentialsType,
  members: [
    { compat: 'sorobanCredentialsSourceAccount', modern: 'SourceAccount', value: 0 },
    { compat: 'sorobanCredentialsAddress', modern: 'Address', value: 1 },
  ],
});
export const SorobanCredentialsType = _SorobanCredentialsType as unknown as {
  sorobanCredentialsSourceAccount(): SorobanCredentialsType;
  sorobanCredentialsAddress(): SorobanCredentialsType;
};

export interface SorobanAddressCredentials {
  address(value?: ScAddress): ScAddress;
  nonce(value?: Int64): Int64;
  signatureExpirationLedger(value?: Uint32): Uint32;
  signature(value?: ScVal): ScVal;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanAddressCredentials = createCompatStruct({
  codec: modern.SorobanAddressCredentials,
  fields: [
    { name: 'address', modernName: 'address', convert: unionConverter(_ScAddress) },
    { name: 'nonce', modernName: 'nonce', convert: int64Conv },
    { name: 'signatureExpirationLedger', modernName: 'signatureExpirationLedger', convert: id },
    { name: 'signature', modernName: 'signature', convert: lazyConverter(() => unionConverter(_ScVal)) },
  ],
});
export const SorobanAddressCredentials = _SorobanAddressCredentials as unknown as {
  new(attributes: { address: ScAddress; nonce: Int64; signatureExpirationLedger: Uint32; signature: ScVal }): SorobanAddressCredentials;
  read(io: Buffer): SorobanAddressCredentials;
  write(value: SorobanAddressCredentials, io: Buffer): void;
  isValid(value: SorobanAddressCredentials): boolean;
  toXDR(value: SorobanAddressCredentials): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanAddressCredentials;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanAddressCredentials;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanCredentials {
  switch(): SorobanCredentialsType;
  address(value?: SorobanAddressCredentials): SorobanAddressCredentials;
  value(): SorobanAddressCredentials | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanCredentials = createCompatUnion({
  codec: modern.SorobanCredentials,
  switchEnum: _SorobanCredentialsType,
  arms: [
    { switchValues: ['sorobanCredentialsSourceAccount'], modern: 'SourceAccount' },
    { switchValues: ['sorobanCredentialsAddress'], modern: 'Address', arm: 'address', convert: structConverter(_SorobanAddressCredentials) },
  ],
});
export const SorobanCredentials = _SorobanCredentials as unknown as {
  sorobanCredentialsSourceAccount(): SorobanCredentials;
  sorobanCredentialsAddress(value: SorobanAddressCredentials): SorobanCredentials;
  read(io: Buffer): SorobanCredentials;
  write(value: SorobanCredentials, io: Buffer): void;
  isValid(value: SorobanCredentials): boolean;
  toXDR(value: SorobanCredentials): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanCredentials;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanCredentials;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanAuthorizedFunctionType {
  readonly name: 'sorobanAuthorizedFunctionTypeContractFn' | 'sorobanAuthorizedFunctionTypeCreateContractHostFn' | 'sorobanAuthorizedFunctionTypeCreateContractV2HostFn';
  readonly value: 0 | 1 | 2;
}
const _SorobanAuthorizedFunctionType = createCompatEnum({
  codec: modern.SorobanAuthorizedFunctionType,
  members: [
    { compat: 'sorobanAuthorizedFunctionTypeContractFn', modern: 'ContractFn', value: 0 },
    { compat: 'sorobanAuthorizedFunctionTypeCreateContractHostFn', modern: 'CreateContractHostFn', value: 1 },
    { compat: 'sorobanAuthorizedFunctionTypeCreateContractV2HostFn', modern: 'CreateContractV2HostFn', value: 2 },
  ],
});
export const SorobanAuthorizedFunctionType = _SorobanAuthorizedFunctionType as unknown as {
  sorobanAuthorizedFunctionTypeContractFn(): SorobanAuthorizedFunctionType;
  sorobanAuthorizedFunctionTypeCreateContractHostFn(): SorobanAuthorizedFunctionType;
  sorobanAuthorizedFunctionTypeCreateContractV2HostFn(): SorobanAuthorizedFunctionType;
};

export interface SorobanAuthorizedFunction {
  switch(): SorobanAuthorizedFunctionType;
  contractFn(value?: InvokeContractArgs): InvokeContractArgs;
  createContractHostFn(value?: CreateContractArgs): CreateContractArgs;
  createContractV2HostFn(value?: CreateContractArgsV2): CreateContractArgsV2;
  value(): InvokeContractArgs | CreateContractArgs | CreateContractArgsV2;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanAuthorizedFunction = createCompatUnion({
  codec: modern.SorobanAuthorizedFunction,
  switchEnum: _SorobanAuthorizedFunctionType,
  arms: [
    { switchValues: ['sorobanAuthorizedFunctionTypeContractFn'], modern: 'ContractFn', arm: 'contractFn', convert: structConverter(_InvokeContractArgs) },
    { switchValues: ['sorobanAuthorizedFunctionTypeCreateContractHostFn'], modern: 'CreateContractHostFn', arm: 'createContractHostFn', convert: structConverter(_CreateContractArgs) },
    { switchValues: ['sorobanAuthorizedFunctionTypeCreateContractV2HostFn'], modern: 'CreateContractV2HostFn', arm: 'createContractV2HostFn', convert: structConverter(_CreateContractArgsV2) },
  ],
});
export const SorobanAuthorizedFunction = _SorobanAuthorizedFunction as unknown as {
  sorobanAuthorizedFunctionTypeContractFn(value: InvokeContractArgs): SorobanAuthorizedFunction;
  sorobanAuthorizedFunctionTypeCreateContractHostFn(value: CreateContractArgs): SorobanAuthorizedFunction;
  sorobanAuthorizedFunctionTypeCreateContractV2HostFn(value: CreateContractArgsV2): SorobanAuthorizedFunction;
  read(io: Buffer): SorobanAuthorizedFunction;
  write(value: SorobanAuthorizedFunction, io: Buffer): void;
  isValid(value: SorobanAuthorizedFunction): boolean;
  toXDR(value: SorobanAuthorizedFunction): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanAuthorizedFunction;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanAuthorizedFunction;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanAuthorizedInvocation {
  function(value?: SorobanAuthorizedFunction): SorobanAuthorizedFunction;
  subInvocations(value?: SorobanAuthorizedInvocation[]): SorobanAuthorizedInvocation[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanAuthorizedInvocation = createCompatStruct({
  codec: modern.SorobanAuthorizedInvocation,
  fields: [
    { name: 'function', modernName: 'function', convert: unionConverter(_SorobanAuthorizedFunction) },
    { name: 'subInvocations', modernName: 'subInvocations', convert: arrayConverter(lazyConverter(() => structConverter(_SorobanAuthorizedInvocation))) },
  ],
});
export const SorobanAuthorizedInvocation = _SorobanAuthorizedInvocation as unknown as {
  new(attributes: { function: SorobanAuthorizedFunction; subInvocations: SorobanAuthorizedInvocation[] }): SorobanAuthorizedInvocation;
  read(io: Buffer): SorobanAuthorizedInvocation;
  write(value: SorobanAuthorizedInvocation, io: Buffer): void;
  isValid(value: SorobanAuthorizedInvocation): boolean;
  toXDR(value: SorobanAuthorizedInvocation): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanAuthorizedInvocation;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanAuthorizedInvocation;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanAuthorizationEntry {
  credentials(value?: SorobanCredentials): SorobanCredentials;
  rootInvocation(value?: SorobanAuthorizedInvocation): SorobanAuthorizedInvocation;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanAuthorizationEntry = createCompatStruct({
  codec: modern.SorobanAuthorizationEntry,
  fields: [
    { name: 'credentials', modernName: 'credentials', convert: unionConverter(_SorobanCredentials) },
    { name: 'rootInvocation', modernName: 'rootInvocation', convert: lazyConverter(() => structConverter(_SorobanAuthorizedInvocation)) },
  ],
});
export const SorobanAuthorizationEntry = _SorobanAuthorizationEntry as unknown as {
  new(attributes: { credentials: SorobanCredentials; rootInvocation: SorobanAuthorizedInvocation }): SorobanAuthorizationEntry;
  read(io: Buffer): SorobanAuthorizationEntry;
  write(value: SorobanAuthorizationEntry, io: Buffer): void;
  isValid(value: SorobanAuthorizationEntry): boolean;
  toXDR(value: SorobanAuthorizationEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanAuthorizationEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanAuthorizationEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InvokeHostFunctionOp {
  hostFunction(value?: HostFunction): HostFunction;
  auth(value?: SorobanAuthorizationEntry[]): SorobanAuthorizationEntry[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InvokeHostFunctionOp = createCompatStruct({
  codec: modern.InvokeHostFunctionOp,
  fields: [
    { name: 'hostFunction', modernName: 'hostFunction', convert: unionConverter(_HostFunction) },
    { name: 'auth', modernName: 'auth', convert: arrayConverter(structConverter(_SorobanAuthorizationEntry)) },
  ],
});
export const InvokeHostFunctionOp = _InvokeHostFunctionOp as unknown as {
  new(attributes: { hostFunction: HostFunction; auth: SorobanAuthorizationEntry[] }): InvokeHostFunctionOp;
  read(io: Buffer): InvokeHostFunctionOp;
  write(value: InvokeHostFunctionOp, io: Buffer): void;
  isValid(value: InvokeHostFunctionOp): boolean;
  toXDR(value: InvokeHostFunctionOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InvokeHostFunctionOp;
  fromXDR(input: string, format: 'hex' | 'base64'): InvokeHostFunctionOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ExtendFootprintTtlOp {
  ext(value?: ExtensionPoint): ExtensionPoint;
  extendTo(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ExtendFootprintTtlOp = createCompatStruct({
  codec: modern.ExtendFootprintTTLOp,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'extendTo', modernName: 'extendTo', convert: id },
  ],
});
export const ExtendFootprintTtlOp = _ExtendFootprintTtlOp as unknown as {
  new(attributes: { ext: ExtensionPoint; extendTo: Uint32 }): ExtendFootprintTtlOp;
  read(io: Buffer): ExtendFootprintTtlOp;
  write(value: ExtendFootprintTtlOp, io: Buffer): void;
  isValid(value: ExtendFootprintTtlOp): boolean;
  toXDR(value: ExtendFootprintTtlOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ExtendFootprintTtlOp;
  fromXDR(input: string, format: 'hex' | 'base64'): ExtendFootprintTtlOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface RestoreFootprintOp {
  ext(value?: ExtensionPoint): ExtensionPoint;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _RestoreFootprintOp = createCompatStruct({
  codec: modern.RestoreFootprintOp,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
  ],
});
export const RestoreFootprintOp = _RestoreFootprintOp as unknown as {
  new(attributes: { ext: ExtensionPoint }): RestoreFootprintOp;
  read(io: Buffer): RestoreFootprintOp;
  write(value: RestoreFootprintOp, io: Buffer): void;
  isValid(value: RestoreFootprintOp): boolean;
  toXDR(value: RestoreFootprintOp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): RestoreFootprintOp;
  fromXDR(input: string, format: 'hex' | 'base64'): RestoreFootprintOp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface OperationBody {
  switch(): OperationType;
  createAccountOp(value?: CreateAccountOp): CreateAccountOp;
  paymentOp(value?: PaymentOp): PaymentOp;
  pathPaymentStrictReceiveOp(value?: PathPaymentStrictReceiveOp): PathPaymentStrictReceiveOp;
  manageSellOfferOp(value?: ManageSellOfferOp): ManageSellOfferOp;
  createPassiveSellOfferOp(value?: CreatePassiveSellOfferOp): CreatePassiveSellOfferOp;
  setOptionsOp(value?: SetOptionsOp): SetOptionsOp;
  changeTrustOp(value?: ChangeTrustOp): ChangeTrustOp;
  allowTrustOp(value?: AllowTrustOp): AllowTrustOp;
  destination(value?: MuxedAccount): MuxedAccount;
  manageDataOp(value?: ManageDataOp): ManageDataOp;
  bumpSequenceOp(value?: BumpSequenceOp): BumpSequenceOp;
  manageBuyOfferOp(value?: ManageBuyOfferOp): ManageBuyOfferOp;
  pathPaymentStrictSendOp(value?: PathPaymentStrictSendOp): PathPaymentStrictSendOp;
  createClaimableBalanceOp(value?: CreateClaimableBalanceOp): CreateClaimableBalanceOp;
  claimClaimableBalanceOp(value?: ClaimClaimableBalanceOp): ClaimClaimableBalanceOp;
  beginSponsoringFutureReservesOp(value?: BeginSponsoringFutureReservesOp): BeginSponsoringFutureReservesOp;
  revokeSponsorshipOp(value?: RevokeSponsorshipOp): RevokeSponsorshipOp;
  clawbackOp(value?: ClawbackOp): ClawbackOp;
  clawbackClaimableBalanceOp(value?: ClawbackClaimableBalanceOp): ClawbackClaimableBalanceOp;
  setTrustLineFlagsOp(value?: SetTrustLineFlagsOp): SetTrustLineFlagsOp;
  liquidityPoolDepositOp(value?: LiquidityPoolDepositOp): LiquidityPoolDepositOp;
  liquidityPoolWithdrawOp(value?: LiquidityPoolWithdrawOp): LiquidityPoolWithdrawOp;
  invokeHostFunctionOp(value?: InvokeHostFunctionOp): InvokeHostFunctionOp;
  extendFootprintTtlOp(value?: ExtendFootprintTtlOp): ExtendFootprintTtlOp;
  restoreFootprintOp(value?: RestoreFootprintOp): RestoreFootprintOp;
  value(): CreateAccountOp | PaymentOp | PathPaymentStrictReceiveOp | ManageSellOfferOp | CreatePassiveSellOfferOp | SetOptionsOp | ChangeTrustOp | AllowTrustOp | MuxedAccount | ManageDataOp | BumpSequenceOp | ManageBuyOfferOp | PathPaymentStrictSendOp | CreateClaimableBalanceOp | ClaimClaimableBalanceOp | BeginSponsoringFutureReservesOp | RevokeSponsorshipOp | ClawbackOp | ClawbackClaimableBalanceOp | SetTrustLineFlagsOp | LiquidityPoolDepositOp | LiquidityPoolWithdrawOp | InvokeHostFunctionOp | ExtendFootprintTtlOp | RestoreFootprintOp | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _OperationBody = createCompatUnion({
  codec: modern.OperationBody,
  switchEnum: _OperationType,
  arms: [
    { switchValues: ['createAccount'], modern: 'CreateAccount', arm: 'createAccountOp', convert: structConverter(_CreateAccountOp) },
    { switchValues: ['payment'], modern: 'Payment', arm: 'paymentOp', convert: structConverter(_PaymentOp) },
    { switchValues: ['pathPaymentStrictReceive'], modern: 'PathPaymentStrictReceive', arm: 'pathPaymentStrictReceiveOp', convert: structConverter(_PathPaymentStrictReceiveOp) },
    { switchValues: ['manageSellOffer'], modern: 'ManageSellOffer', arm: 'manageSellOfferOp', convert: structConverter(_ManageSellOfferOp) },
    { switchValues: ['createPassiveSellOffer'], modern: 'CreatePassiveSellOffer', arm: 'createPassiveSellOfferOp', convert: structConverter(_CreatePassiveSellOfferOp) },
    { switchValues: ['setOptions'], modern: 'SetOptions', arm: 'setOptionsOp', convert: structConverter(_SetOptionsOp) },
    { switchValues: ['changeTrust'], modern: 'ChangeTrust', arm: 'changeTrustOp', convert: structConverter(_ChangeTrustOp) },
    { switchValues: ['allowTrust'], modern: 'AllowTrust', arm: 'allowTrustOp', convert: structConverter(_AllowTrustOp) },
    { switchValues: ['accountMerge'], modern: 'AccountMerge', arm: 'destination', convert: unionConverter(_MuxedAccount) },
    { switchValues: ['inflation'], modern: 'Inflation' },
    { switchValues: ['manageData'], modern: 'ManageData', arm: 'manageDataOp', convert: structConverter(_ManageDataOp) },
    { switchValues: ['bumpSequence'], modern: 'BumpSequence', arm: 'bumpSequenceOp', convert: structConverter(_BumpSequenceOp) },
    { switchValues: ['manageBuyOffer'], modern: 'ManageBuyOffer', arm: 'manageBuyOfferOp', convert: structConverter(_ManageBuyOfferOp) },
    { switchValues: ['pathPaymentStrictSend'], modern: 'PathPaymentStrictSend', arm: 'pathPaymentStrictSendOp', convert: structConverter(_PathPaymentStrictSendOp) },
    { switchValues: ['createClaimableBalance'], modern: 'CreateClaimableBalance', arm: 'createClaimableBalanceOp', convert: structConverter(_CreateClaimableBalanceOp) },
    { switchValues: ['claimClaimableBalance'], modern: 'ClaimClaimableBalance', arm: 'claimClaimableBalanceOp', convert: structConverter(_ClaimClaimableBalanceOp) },
    { switchValues: ['beginSponsoringFutureReserves'], modern: 'BeginSponsoringFutureReserves', arm: 'beginSponsoringFutureReservesOp', convert: structConverter(_BeginSponsoringFutureReservesOp) },
    { switchValues: ['endSponsoringFutureReserves'], modern: 'EndSponsoringFutureReserves' },
    { switchValues: ['revokeSponsorship'], modern: 'RevokeSponsorship', arm: 'revokeSponsorshipOp', convert: unionConverter(_RevokeSponsorshipOp) },
    { switchValues: ['clawback'], modern: 'Clawback', arm: 'clawbackOp', convert: structConverter(_ClawbackOp) },
    { switchValues: ['clawbackClaimableBalance'], modern: 'ClawbackClaimableBalance', arm: 'clawbackClaimableBalanceOp', convert: structConverter(_ClawbackClaimableBalanceOp) },
    { switchValues: ['setTrustLineFlags'], modern: 'SetTrustLineFlags', arm: 'setTrustLineFlagsOp', convert: structConverter(_SetTrustLineFlagsOp) },
    { switchValues: ['liquidityPoolDeposit'], modern: 'LiquidityPoolDeposit', arm: 'liquidityPoolDepositOp', convert: structConverter(_LiquidityPoolDepositOp) },
    { switchValues: ['liquidityPoolWithdraw'], modern: 'LiquidityPoolWithdraw', arm: 'liquidityPoolWithdrawOp', convert: structConverter(_LiquidityPoolWithdrawOp) },
    { switchValues: ['invokeHostFunction'], modern: 'InvokeHostFunction', arm: 'invokeHostFunctionOp', convert: structConverter(_InvokeHostFunctionOp) },
    { switchValues: ['extendFootprintTtl'], modern: 'ExtendFootprintTtl', arm: 'extendFootprintTtlOp', convert: structConverter(_ExtendFootprintTtlOp) },
    { switchValues: ['restoreFootprint'], modern: 'RestoreFootprint', arm: 'restoreFootprintOp', convert: structConverter(_RestoreFootprintOp) },
  ],
});
export const OperationBody = _OperationBody as unknown as {
  createAccount(value: CreateAccountOp): OperationBody;
  payment(value: PaymentOp): OperationBody;
  pathPaymentStrictReceive(value: PathPaymentStrictReceiveOp): OperationBody;
  manageSellOffer(value: ManageSellOfferOp): OperationBody;
  createPassiveSellOffer(value: CreatePassiveSellOfferOp): OperationBody;
  setOptions(value: SetOptionsOp): OperationBody;
  changeTrust(value: ChangeTrustOp): OperationBody;
  allowTrust(value: AllowTrustOp): OperationBody;
  accountMerge(value: MuxedAccount): OperationBody;
  inflation(): OperationBody;
  manageData(value: ManageDataOp): OperationBody;
  bumpSequence(value: BumpSequenceOp): OperationBody;
  manageBuyOffer(value: ManageBuyOfferOp): OperationBody;
  pathPaymentStrictSend(value: PathPaymentStrictSendOp): OperationBody;
  createClaimableBalance(value: CreateClaimableBalanceOp): OperationBody;
  claimClaimableBalance(value: ClaimClaimableBalanceOp): OperationBody;
  beginSponsoringFutureReserves(value: BeginSponsoringFutureReservesOp): OperationBody;
  endSponsoringFutureReserves(): OperationBody;
  revokeSponsorship(value: RevokeSponsorshipOp): OperationBody;
  clawback(value: ClawbackOp): OperationBody;
  clawbackClaimableBalance(value: ClawbackClaimableBalanceOp): OperationBody;
  setTrustLineFlags(value: SetTrustLineFlagsOp): OperationBody;
  liquidityPoolDeposit(value: LiquidityPoolDepositOp): OperationBody;
  liquidityPoolWithdraw(value: LiquidityPoolWithdrawOp): OperationBody;
  invokeHostFunction(value: InvokeHostFunctionOp): OperationBody;
  extendFootprintTtl(value: ExtendFootprintTtlOp): OperationBody;
  restoreFootprint(value: RestoreFootprintOp): OperationBody;
  read(io: Buffer): OperationBody;
  write(value: OperationBody, io: Buffer): void;
  isValid(value: OperationBody): boolean;
  toXDR(value: OperationBody): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): OperationBody;
  fromXDR(input: string, format: 'hex' | 'base64'): OperationBody;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Operation {
  sourceAccount(value?: null | MuxedAccount): null | MuxedAccount;
  body(value?: OperationBody): OperationBody;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Operation = createCompatStruct({
  codec: modern.Operation,
  fields: [
    { name: 'sourceAccount', modernName: 'sourceAccount', convert: optionConverter(unionConverter(_MuxedAccount)) },
    { name: 'body', modernName: 'body', convert: id },
  ],
});
export const Operation = _Operation as unknown as {
  new(attributes: { sourceAccount: null | MuxedAccount; body: OperationBody }): Operation;
  read(io: Buffer): Operation;
  write(value: Operation, io: Buffer): void;
  isValid(value: Operation): boolean;
  toXDR(value: Operation): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Operation;
  fromXDR(input: string, format: 'hex' | 'base64'): Operation;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const MAX_OPS_PER_TX = 100;

export interface TransactionV0Ext {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionV0Ext = createCompatUnion({
  codec: modern.TransactionV0Ext,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const TransactionV0Ext = _TransactionV0Ext as unknown as {
  0(): TransactionV0Ext;
  read(io: Buffer): TransactionV0Ext;
  write(value: TransactionV0Ext, io: Buffer): void;
  isValid(value: TransactionV0Ext): boolean;
  toXDR(value: TransactionV0Ext): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionV0Ext;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionV0Ext;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionV0 {
  sourceAccountEd25519(value?: Uint256): Uint256;
  fee(value?: Uint32): Uint32;
  seqNum(value?: SequenceNumber): SequenceNumber;
  timeBounds(value?: null | TimeBounds): null | TimeBounds;
  memo(value?: Memo): Memo;
  operations(value?: Operation[]): Operation[];
  ext(value?: TransactionV0Ext): TransactionV0Ext;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionV0 = createCompatStruct({
  codec: modern.TransactionV0,
  fields: [
    { name: 'sourceAccountEd25519', modernName: 'sourceAccountEd25519', convert: id },
    { name: 'fee', modernName: 'fee', convert: id },
    { name: 'seqNum', modernName: 'seqNum', convert: int64Conv },
    { name: 'timeBounds', modernName: 'timeBounds', convert: optionConverter(structConverter(_TimeBounds)) },
    { name: 'memo', modernName: 'memo', convert: unionConverter(_Memo) },
    { name: 'operations', modernName: 'operations', convert: arrayConverter(structConverter(_Operation)) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const TransactionV0 = _TransactionV0 as unknown as {
  new(attributes: { sourceAccountEd25519: Uint256; fee: Uint32; seqNum: SequenceNumber; timeBounds: null | TimeBounds; memo: Memo; operations: Operation[]; ext: TransactionV0Ext }): TransactionV0;
  read(io: Buffer): TransactionV0;
  write(value: TransactionV0, io: Buffer): void;
  isValid(value: TransactionV0): boolean;
  toXDR(value: TransactionV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionV0;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type SignatureHint = Buffer;
export const SignatureHint = createCompatTypedef({ codec: modern.SignatureHint, convert: id });

export interface DecoratedSignature {
  hint(value?: SignatureHint): SignatureHint;
  signature(value?: Signature): Signature;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _DecoratedSignature = createCompatStruct({
  codec: modern.DecoratedSignature,
  fields: [
    { name: 'hint', modernName: 'hint', convert: id },
    { name: 'signature', modernName: 'signature', convert: id },
  ],
});
export const DecoratedSignature = _DecoratedSignature as unknown as {
  new(attributes: { hint: SignatureHint; signature: Signature }): DecoratedSignature;
  read(io: Buffer): DecoratedSignature;
  write(value: DecoratedSignature, io: Buffer): void;
  isValid(value: DecoratedSignature): boolean;
  toXDR(value: DecoratedSignature): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): DecoratedSignature;
  fromXDR(input: string, format: 'hex' | 'base64'): DecoratedSignature;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionV0Envelope {
  tx(value?: TransactionV0): TransactionV0;
  signatures(value?: DecoratedSignature[]): DecoratedSignature[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionV0Envelope = createCompatStruct({
  codec: modern.TransactionV0Envelope,
  fields: [
    { name: 'tx', modernName: 'tx', convert: structConverter(_TransactionV0) },
    { name: 'signatures', modernName: 'signatures', convert: arrayConverter(structConverter(_DecoratedSignature)) },
  ],
});
export const TransactionV0Envelope = _TransactionV0Envelope as unknown as {
  new(attributes: { tx: TransactionV0; signatures: DecoratedSignature[] }): TransactionV0Envelope;
  read(io: Buffer): TransactionV0Envelope;
  write(value: TransactionV0Envelope, io: Buffer): void;
  isValid(value: TransactionV0Envelope): boolean;
  toXDR(value: TransactionV0Envelope): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionV0Envelope;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionV0Envelope;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PreconditionType {
  readonly name: 'precondNone' | 'precondTime' | 'precondV2';
  readonly value: 0 | 1 | 2;
}
const _PreconditionType = createCompatEnum({
  codec: modern.PreconditionType,
  members: [
    { compat: 'precondNone', modern: 'None', value: 0 },
    { compat: 'precondTime', modern: 'Time', value: 1 },
    { compat: 'precondV2', modern: 'V2', value: 2 },
  ],
});
export const PreconditionType = _PreconditionType as unknown as {
  precondNone(): PreconditionType;
  precondTime(): PreconditionType;
  precondV2(): PreconditionType;
};

export interface LedgerBounds {
  minLedger(value?: Uint32): Uint32;
  maxLedger(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerBounds = createCompatStruct({
  codec: modern.LedgerBounds,
  fields: [
    { name: 'minLedger', modernName: 'minLedger', convert: id },
    { name: 'maxLedger', modernName: 'maxLedger', convert: id },
  ],
});
export const LedgerBounds = _LedgerBounds as unknown as {
  new(attributes: { minLedger: Uint32; maxLedger: Uint32 }): LedgerBounds;
  read(io: Buffer): LedgerBounds;
  write(value: LedgerBounds, io: Buffer): void;
  isValid(value: LedgerBounds): boolean;
  toXDR(value: LedgerBounds): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerBounds;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerBounds;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PreconditionsV2 {
  timeBounds(value?: null | TimeBounds): null | TimeBounds;
  ledgerBounds(value?: null | LedgerBounds): null | LedgerBounds;
  minSeqNum(value?: null | SequenceNumber): null | SequenceNumber;
  minSeqAge(value?: Duration): Duration;
  minSeqLedgerGap(value?: Uint32): Uint32;
  extraSigners(value?: SignerKey[]): SignerKey[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PreconditionsV2 = createCompatStruct({
  codec: modern.PreconditionsV2,
  fields: [
    { name: 'timeBounds', modernName: 'timeBounds', convert: optionConverter(structConverter(_TimeBounds)) },
    { name: 'ledgerBounds', modernName: 'ledgerBounds', convert: optionConverter(structConverter(_LedgerBounds)) },
    { name: 'minSeqNum', modernName: 'minSeqNum', convert: optionConverter(int64Conv) },
    { name: 'minSeqAge', modernName: 'minSeqAge', convert: uint64Conv },
    { name: 'minSeqLedgerGap', modernName: 'minSeqLedgerGap', convert: id },
    { name: 'extraSigners', modernName: 'extraSigners', convert: arrayConverter(unionConverter(_SignerKey)) },
  ],
});
export const PreconditionsV2 = _PreconditionsV2 as unknown as {
  new(attributes: { timeBounds: null | TimeBounds; ledgerBounds: null | LedgerBounds; minSeqNum: null | SequenceNumber; minSeqAge: Duration; minSeqLedgerGap: Uint32; extraSigners: SignerKey[] }): PreconditionsV2;
  read(io: Buffer): PreconditionsV2;
  write(value: PreconditionsV2, io: Buffer): void;
  isValid(value: PreconditionsV2): boolean;
  toXDR(value: PreconditionsV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PreconditionsV2;
  fromXDR(input: string, format: 'hex' | 'base64'): PreconditionsV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Preconditions {
  switch(): PreconditionType;
  timeBounds(value?: TimeBounds): TimeBounds;
  v2(value?: PreconditionsV2): PreconditionsV2;
  value(): TimeBounds | PreconditionsV2 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Preconditions = createCompatUnion({
  codec: modern.Preconditions,
  switchEnum: _PreconditionType,
  arms: [
    { switchValues: ['precondNone'], modern: 'None' },
    { switchValues: ['precondTime'], modern: 'Time', arm: 'timeBounds', convert: structConverter(_TimeBounds) },
    { switchValues: ['precondV2'], modern: 'V2', arm: 'v2', convert: structConverter(_PreconditionsV2) },
  ],
});
export const Preconditions = _Preconditions as unknown as {
  precondNone(): Preconditions;
  precondTime(value: TimeBounds): Preconditions;
  precondV2(value: PreconditionsV2): Preconditions;
  read(io: Buffer): Preconditions;
  write(value: Preconditions, io: Buffer): void;
  isValid(value: Preconditions): boolean;
  toXDR(value: Preconditions): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Preconditions;
  fromXDR(input: string, format: 'hex' | 'base64'): Preconditions;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanResourcesExtV0 {
  archivedSorobanEntries(value?: Uint32[]): Uint32[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanResourcesExtV0 = createCompatStruct({
  codec: modern.SorobanResourcesExtV0,
  fields: [
    { name: 'archivedSorobanEntries', modernName: 'archivedSorobanEntries', convert: arrayConverter(id) },
  ],
});
export const SorobanResourcesExtV0 = _SorobanResourcesExtV0 as unknown as {
  new(attributes: { archivedSorobanEntries: Uint32[] }): SorobanResourcesExtV0;
  read(io: Buffer): SorobanResourcesExtV0;
  write(value: SorobanResourcesExtV0, io: Buffer): void;
  isValid(value: SorobanResourcesExtV0): boolean;
  toXDR(value: SorobanResourcesExtV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanResourcesExtV0;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanResourcesExtV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanTransactionDataExt {
  switch(): number;
  resourceExt(value?: SorobanResourcesExtV0): SorobanResourcesExtV0;
  value(): SorobanResourcesExtV0 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanTransactionDataExt = createCompatUnion({
  codec: modern.SorobanTransactionDataExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'resourceExt', convert: structConverter(_SorobanResourcesExtV0) },
  ],
});
export const SorobanTransactionDataExt = _SorobanTransactionDataExt as unknown as {
  0(): SorobanTransactionDataExt;
  1(value: SorobanResourcesExtV0): SorobanTransactionDataExt;
  read(io: Buffer): SorobanTransactionDataExt;
  write(value: SorobanTransactionDataExt, io: Buffer): void;
  isValid(value: SorobanTransactionDataExt): boolean;
  toXDR(value: SorobanTransactionDataExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanTransactionDataExt;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanTransactionDataExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerFootprint {
  readOnly(value?: LedgerKey[]): LedgerKey[];
  readWrite(value?: LedgerKey[]): LedgerKey[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerFootprint = createCompatStruct({
  codec: modern.LedgerFootprint,
  fields: [
    { name: 'readOnly', modernName: 'readOnly', convert: arrayConverter(unionConverter(_LedgerKey)) },
    { name: 'readWrite', modernName: 'readWrite', convert: arrayConverter(unionConverter(_LedgerKey)) },
  ],
});
export const LedgerFootprint = _LedgerFootprint as unknown as {
  new(attributes: { readOnly: LedgerKey[]; readWrite: LedgerKey[] }): LedgerFootprint;
  read(io: Buffer): LedgerFootprint;
  write(value: LedgerFootprint, io: Buffer): void;
  isValid(value: LedgerFootprint): boolean;
  toXDR(value: LedgerFootprint): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerFootprint;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerFootprint;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanResources {
  footprint(value?: LedgerFootprint): LedgerFootprint;
  instructions(value?: Uint32): Uint32;
  diskReadBytes(value?: Uint32): Uint32;
  writeBytes(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanResources = createCompatStruct({
  codec: modern.SorobanResources,
  fields: [
    { name: 'footprint', modernName: 'footprint', convert: structConverter(_LedgerFootprint) },
    { name: 'instructions', modernName: 'instructions', convert: id },
    { name: 'diskReadBytes', modernName: 'diskReadBytes', convert: id },
    { name: 'writeBytes', modernName: 'writeBytes', convert: id },
  ],
});
export const SorobanResources = _SorobanResources as unknown as {
  new(attributes: { footprint: LedgerFootprint; instructions: Uint32; diskReadBytes: Uint32; writeBytes: Uint32 }): SorobanResources;
  read(io: Buffer): SorobanResources;
  write(value: SorobanResources, io: Buffer): void;
  isValid(value: SorobanResources): boolean;
  toXDR(value: SorobanResources): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanResources;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanResources;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanTransactionData {
  ext(value?: SorobanTransactionDataExt): SorobanTransactionDataExt;
  resources(value?: SorobanResources): SorobanResources;
  resourceFee(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanTransactionData = createCompatStruct({
  codec: modern.SorobanTransactionData,
  fields: [
    { name: 'ext', modernName: 'ext', convert: id },
    { name: 'resources', modernName: 'resources', convert: structConverter(_SorobanResources) },
    { name: 'resourceFee', modernName: 'resourceFee', convert: int64Conv },
  ],
});
export const SorobanTransactionData = _SorobanTransactionData as unknown as {
  new(attributes: { ext: SorobanTransactionDataExt; resources: SorobanResources; resourceFee: Int64 }): SorobanTransactionData;
  read(io: Buffer): SorobanTransactionData;
  write(value: SorobanTransactionData, io: Buffer): void;
  isValid(value: SorobanTransactionData): boolean;
  toXDR(value: SorobanTransactionData): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanTransactionData;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanTransactionData;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionExt {
  switch(): number;
  sorobanData(value?: SorobanTransactionData): SorobanTransactionData;
  value(): SorobanTransactionData | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionExt = createCompatUnion({
  codec: modern.TransactionExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'sorobanData', convert: structConverter(_SorobanTransactionData) },
  ],
});
export const TransactionExt = _TransactionExt as unknown as {
  0(): TransactionExt;
  1(value: SorobanTransactionData): TransactionExt;
  read(io: Buffer): TransactionExt;
  write(value: TransactionExt, io: Buffer): void;
  isValid(value: TransactionExt): boolean;
  toXDR(value: TransactionExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionExt;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Transaction {
  sourceAccount(value?: MuxedAccount): MuxedAccount;
  fee(value?: Uint32): Uint32;
  seqNum(value?: SequenceNumber): SequenceNumber;
  cond(value?: Preconditions): Preconditions;
  memo(value?: Memo): Memo;
  operations(value?: Operation[]): Operation[];
  ext(value?: TransactionExt): TransactionExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Transaction = createCompatStruct({
  codec: modern.Transaction,
  fields: [
    { name: 'sourceAccount', modernName: 'sourceAccount', convert: unionConverter(_MuxedAccount) },
    { name: 'fee', modernName: 'fee', convert: id },
    { name: 'seqNum', modernName: 'seqNum', convert: int64Conv },
    { name: 'cond', modernName: 'cond', convert: unionConverter(_Preconditions) },
    { name: 'memo', modernName: 'memo', convert: unionConverter(_Memo) },
    { name: 'operations', modernName: 'operations', convert: arrayConverter(structConverter(_Operation)) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const Transaction = _Transaction as unknown as {
  new(attributes: { sourceAccount: MuxedAccount; fee: Uint32; seqNum: SequenceNumber; cond: Preconditions; memo: Memo; operations: Operation[]; ext: TransactionExt }): Transaction;
  read(io: Buffer): Transaction;
  write(value: Transaction, io: Buffer): void;
  isValid(value: Transaction): boolean;
  toXDR(value: Transaction): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Transaction;
  fromXDR(input: string, format: 'hex' | 'base64'): Transaction;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionV1Envelope {
  tx(value?: Transaction): Transaction;
  signatures(value?: DecoratedSignature[]): DecoratedSignature[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionV1Envelope = createCompatStruct({
  codec: modern.TransactionV1Envelope,
  fields: [
    { name: 'tx', modernName: 'tx', convert: structConverter(_Transaction) },
    { name: 'signatures', modernName: 'signatures', convert: arrayConverter(structConverter(_DecoratedSignature)) },
  ],
});
export const TransactionV1Envelope = _TransactionV1Envelope as unknown as {
  new(attributes: { tx: Transaction; signatures: DecoratedSignature[] }): TransactionV1Envelope;
  read(io: Buffer): TransactionV1Envelope;
  write(value: TransactionV1Envelope, io: Buffer): void;
  isValid(value: TransactionV1Envelope): boolean;
  toXDR(value: TransactionV1Envelope): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionV1Envelope;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionV1Envelope;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface FeeBumpTransactionInnerTx {
  switch(): EnvelopeType;
  v1(value?: TransactionV1Envelope): TransactionV1Envelope;
  value(): TransactionV1Envelope;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _FeeBumpTransactionInnerTx = createCompatUnion({
  codec: modern.FeeBumpTransactionInnerTx,
  switchEnum: _EnvelopeType,
  arms: [
    { switchValues: ['envelopeTypeTx'], modern: 'Tx', arm: 'v1', convert: structConverter(_TransactionV1Envelope) },
  ],
});
export const FeeBumpTransactionInnerTx = _FeeBumpTransactionInnerTx as unknown as {
  envelopeTypeTx(value: TransactionV1Envelope): FeeBumpTransactionInnerTx;
  read(io: Buffer): FeeBumpTransactionInnerTx;
  write(value: FeeBumpTransactionInnerTx, io: Buffer): void;
  isValid(value: FeeBumpTransactionInnerTx): boolean;
  toXDR(value: FeeBumpTransactionInnerTx): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): FeeBumpTransactionInnerTx;
  fromXDR(input: string, format: 'hex' | 'base64'): FeeBumpTransactionInnerTx;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface FeeBumpTransactionExt {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _FeeBumpTransactionExt = createCompatUnion({
  codec: modern.FeeBumpTransactionExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const FeeBumpTransactionExt = _FeeBumpTransactionExt as unknown as {
  0(): FeeBumpTransactionExt;
  read(io: Buffer): FeeBumpTransactionExt;
  write(value: FeeBumpTransactionExt, io: Buffer): void;
  isValid(value: FeeBumpTransactionExt): boolean;
  toXDR(value: FeeBumpTransactionExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): FeeBumpTransactionExt;
  fromXDR(input: string, format: 'hex' | 'base64'): FeeBumpTransactionExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface FeeBumpTransaction {
  feeSource(value?: MuxedAccount): MuxedAccount;
  fee(value?: Int64): Int64;
  innerTx(value?: FeeBumpTransactionInnerTx): FeeBumpTransactionInnerTx;
  ext(value?: FeeBumpTransactionExt): FeeBumpTransactionExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _FeeBumpTransaction = createCompatStruct({
  codec: modern.FeeBumpTransaction,
  fields: [
    { name: 'feeSource', modernName: 'feeSource', convert: unionConverter(_MuxedAccount) },
    { name: 'fee', modernName: 'fee', convert: int64Conv },
    { name: 'innerTx', modernName: 'innerTx', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const FeeBumpTransaction = _FeeBumpTransaction as unknown as {
  new(attributes: { feeSource: MuxedAccount; fee: Int64; innerTx: FeeBumpTransactionInnerTx; ext: FeeBumpTransactionExt }): FeeBumpTransaction;
  read(io: Buffer): FeeBumpTransaction;
  write(value: FeeBumpTransaction, io: Buffer): void;
  isValid(value: FeeBumpTransaction): boolean;
  toXDR(value: FeeBumpTransaction): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): FeeBumpTransaction;
  fromXDR(input: string, format: 'hex' | 'base64'): FeeBumpTransaction;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface FeeBumpTransactionEnvelope {
  tx(value?: FeeBumpTransaction): FeeBumpTransaction;
  signatures(value?: DecoratedSignature[]): DecoratedSignature[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _FeeBumpTransactionEnvelope = createCompatStruct({
  codec: modern.FeeBumpTransactionEnvelope,
  fields: [
    { name: 'tx', modernName: 'tx', convert: structConverter(_FeeBumpTransaction) },
    { name: 'signatures', modernName: 'signatures', convert: arrayConverter(structConverter(_DecoratedSignature)) },
  ],
});
export const FeeBumpTransactionEnvelope = _FeeBumpTransactionEnvelope as unknown as {
  new(attributes: { tx: FeeBumpTransaction; signatures: DecoratedSignature[] }): FeeBumpTransactionEnvelope;
  read(io: Buffer): FeeBumpTransactionEnvelope;
  write(value: FeeBumpTransactionEnvelope, io: Buffer): void;
  isValid(value: FeeBumpTransactionEnvelope): boolean;
  toXDR(value: FeeBumpTransactionEnvelope): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): FeeBumpTransactionEnvelope;
  fromXDR(input: string, format: 'hex' | 'base64'): FeeBumpTransactionEnvelope;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionEnvelope {
  switch(): EnvelopeType;
  v0(value?: TransactionV0Envelope): TransactionV0Envelope;
  v1(value?: TransactionV1Envelope): TransactionV1Envelope;
  feeBump(value?: FeeBumpTransactionEnvelope): FeeBumpTransactionEnvelope;
  value(): TransactionV0Envelope | TransactionV1Envelope | FeeBumpTransactionEnvelope;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionEnvelope = createCompatUnion({
  codec: modern.TransactionEnvelope,
  switchEnum: _EnvelopeType,
  arms: [
    { switchValues: ['envelopeTypeTxV0'], modern: 'TxV0', arm: 'v0', convert: structConverter(_TransactionV0Envelope) },
    { switchValues: ['envelopeTypeTx'], modern: 'Tx', arm: 'v1', convert: structConverter(_TransactionV1Envelope) },
    { switchValues: ['envelopeTypeTxFeeBump'], modern: 'TxFeeBump', arm: 'feeBump', convert: structConverter(_FeeBumpTransactionEnvelope) },
  ],
});
export const TransactionEnvelope = _TransactionEnvelope as unknown as {
  envelopeTypeTxV0(value: TransactionV0Envelope): TransactionEnvelope;
  envelopeTypeTx(value: TransactionV1Envelope): TransactionEnvelope;
  envelopeTypeTxFeeBump(value: FeeBumpTransactionEnvelope): TransactionEnvelope;
  read(io: Buffer): TransactionEnvelope;
  write(value: TransactionEnvelope, io: Buffer): void;
  isValid(value: TransactionEnvelope): boolean;
  toXDR(value: TransactionEnvelope): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionEnvelope;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionEnvelope;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionSet {
  previousLedgerHash(value?: Hash): Hash;
  txes(value?: TransactionEnvelope[]): TransactionEnvelope[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionSet = createCompatStruct({
  codec: modern.TransactionSet,
  fields: [
    { name: 'previousLedgerHash', modernName: 'previousLedgerHash', convert: id },
    { name: 'txes', modernName: 'txs', convert: arrayConverter(unionConverter(_TransactionEnvelope)) },
  ],
});
export const TransactionSet = _TransactionSet as unknown as {
  new(attributes: { previousLedgerHash: Hash; txes: TransactionEnvelope[] }): TransactionSet;
  read(io: Buffer): TransactionSet;
  write(value: TransactionSet, io: Buffer): void;
  isValid(value: TransactionSet): boolean;
  toXDR(value: TransactionSet): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionSet;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionSet;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionResultCode {
  readonly name: 'txFeeBumpInnerSuccess' | 'txSuccess' | 'txFailed' | 'txTooEarly' | 'txTooLate' | 'txMissingOperation' | 'txBadSeq' | 'txBadAuth' | 'txInsufficientBalance' | 'txNoAccount' | 'txInsufficientFee' | 'txBadAuthExtra' | 'txInternalError' | 'txNotSupported' | 'txFeeBumpInnerFailed' | 'txBadSponsorship' | 'txBadMinSeqAgeOrGap' | 'txMalformed' | 'txSorobanInvalid';
  readonly value: 1 | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10 | -11 | -12 | -13 | -14 | -15 | -16 | -17;
}
const _TransactionResultCode = createCompatEnum({
  codec: modern.TransactionResultCode,
  members: [
    { compat: 'txFeeBumpInnerSuccess', modern: 'TxFEEBumpInnerSuccess', value: 1 },
    { compat: 'txSuccess', modern: 'TxSUCCESS', value: 0 },
    { compat: 'txFailed', modern: 'TxFAILED', value: -1 },
    { compat: 'txTooEarly', modern: 'TxTOOEarly', value: -2 },
    { compat: 'txTooLate', modern: 'TxTOOLate', value: -3 },
    { compat: 'txMissingOperation', modern: 'TxMISSINGOperation', value: -4 },
    { compat: 'txBadSeq', modern: 'TxBADSeq', value: -5 },
    { compat: 'txBadAuth', modern: 'TxBADAuth', value: -6 },
    { compat: 'txInsufficientBalance', modern: 'TxINSUFFICIENTBalance', value: -7 },
    { compat: 'txNoAccount', modern: 'TxNOAccount', value: -8 },
    { compat: 'txInsufficientFee', modern: 'TxINSUFFICIENTFee', value: -9 },
    { compat: 'txBadAuthExtra', modern: 'TxBADAuthExtra', value: -10 },
    { compat: 'txInternalError', modern: 'TxINTERNALError', value: -11 },
    { compat: 'txNotSupported', modern: 'TxNOTSupported', value: -12 },
    { compat: 'txFeeBumpInnerFailed', modern: 'TxFEEBumpInnerFailed', value: -13 },
    { compat: 'txBadSponsorship', modern: 'TxBADSponsorship', value: -14 },
    { compat: 'txBadMinSeqAgeOrGap', modern: 'TxBADMinSeqAgeOrGap', value: -15 },
    { compat: 'txMalformed', modern: 'TxMALFORMED', value: -16 },
    { compat: 'txSorobanInvalid', modern: 'TxSOROBANInvalid', value: -17 },
  ],
});
export const TransactionResultCode = _TransactionResultCode as unknown as {
  txFeeBumpInnerSuccess(): TransactionResultCode;
  txSuccess(): TransactionResultCode;
  txFailed(): TransactionResultCode;
  txTooEarly(): TransactionResultCode;
  txTooLate(): TransactionResultCode;
  txMissingOperation(): TransactionResultCode;
  txBadSeq(): TransactionResultCode;
  txBadAuth(): TransactionResultCode;
  txInsufficientBalance(): TransactionResultCode;
  txNoAccount(): TransactionResultCode;
  txInsufficientFee(): TransactionResultCode;
  txBadAuthExtra(): TransactionResultCode;
  txInternalError(): TransactionResultCode;
  txNotSupported(): TransactionResultCode;
  txFeeBumpInnerFailed(): TransactionResultCode;
  txBadSponsorship(): TransactionResultCode;
  txBadMinSeqAgeOrGap(): TransactionResultCode;
  txMalformed(): TransactionResultCode;
  txSorobanInvalid(): TransactionResultCode;
};

export interface OperationResultCode {
  readonly name: 'opInner' | 'opBadAuth' | 'opNoAccount' | 'opNotSupported' | 'opTooManySubentries' | 'opExceededWorkLimit' | 'opTooManySponsoring';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6;
}
const _OperationResultCode = createCompatEnum({
  codec: modern.OperationResultCode,
  members: [
    { compat: 'opInner', modern: 'OpINNER', value: 0 },
    { compat: 'opBadAuth', modern: 'OpBADAuth', value: -1 },
    { compat: 'opNoAccount', modern: 'OpNOAccount', value: -2 },
    { compat: 'opNotSupported', modern: 'OpNOTSupported', value: -3 },
    { compat: 'opTooManySubentries', modern: 'OpTOOManySubentries', value: -4 },
    { compat: 'opExceededWorkLimit', modern: 'OpEXCEEDEDWorkLimit', value: -5 },
    { compat: 'opTooManySponsoring', modern: 'OpTOOManySponsoring', value: -6 },
  ],
});
export const OperationResultCode = _OperationResultCode as unknown as {
  opInner(): OperationResultCode;
  opBadAuth(): OperationResultCode;
  opNoAccount(): OperationResultCode;
  opNotSupported(): OperationResultCode;
  opTooManySubentries(): OperationResultCode;
  opExceededWorkLimit(): OperationResultCode;
  opTooManySponsoring(): OperationResultCode;
};

export interface CreateAccountResultCode {
  readonly name: 'createAccountSuccess' | 'createAccountMalformed' | 'createAccountUnderfunded' | 'createAccountLowReserve' | 'createAccountAlreadyExist';
  readonly value: 0 | -1 | -2 | -3 | -4;
}
const _CreateAccountResultCode = createCompatEnum({
  codec: modern.CreateAccountResultCode,
  members: [
    { compat: 'createAccountSuccess', modern: 'Success', value: 0 },
    { compat: 'createAccountMalformed', modern: 'Malformed', value: -1 },
    { compat: 'createAccountUnderfunded', modern: 'Underfunded', value: -2 },
    { compat: 'createAccountLowReserve', modern: 'LowReserve', value: -3 },
    { compat: 'createAccountAlreadyExist', modern: 'AlreadyExist', value: -4 },
  ],
});
export const CreateAccountResultCode = _CreateAccountResultCode as unknown as {
  createAccountSuccess(): CreateAccountResultCode;
  createAccountMalformed(): CreateAccountResultCode;
  createAccountUnderfunded(): CreateAccountResultCode;
  createAccountLowReserve(): CreateAccountResultCode;
  createAccountAlreadyExist(): CreateAccountResultCode;
};

export interface CreateAccountResult {
  switch(): CreateAccountResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _CreateAccountResult = createCompatUnion({
  codec: modern.CreateAccountResult,
  switchEnum: _CreateAccountResultCode,
  arms: [
    { switchValues: ['createAccountSuccess'], modern: 'Success' },
    { switchValues: ['createAccountMalformed', 'createAccountUnderfunded', 'createAccountLowReserve', 'createAccountAlreadyExist'], modern: 'Malformed' },
  ],
});
export const CreateAccountResult = _CreateAccountResult as unknown as {
  createAccountSuccess(): CreateAccountResult;
  createAccountMalformed(): CreateAccountResult;
  createAccountUnderfunded(): CreateAccountResult;
  createAccountLowReserve(): CreateAccountResult;
  createAccountAlreadyExist(): CreateAccountResult;
  read(io: Buffer): CreateAccountResult;
  write(value: CreateAccountResult, io: Buffer): void;
  isValid(value: CreateAccountResult): boolean;
  toXDR(value: CreateAccountResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): CreateAccountResult;
  fromXDR(input: string, format: 'hex' | 'base64'): CreateAccountResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PaymentResultCode {
  readonly name: 'paymentSuccess' | 'paymentMalformed' | 'paymentUnderfunded' | 'paymentSrcNoTrust' | 'paymentSrcNotAuthorized' | 'paymentNoDestination' | 'paymentNoTrust' | 'paymentNotAuthorized' | 'paymentLineFull' | 'paymentNoIssuer';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9;
}
const _PaymentResultCode = createCompatEnum({
  codec: modern.PaymentResultCode,
  members: [
    { compat: 'paymentSuccess', modern: 'Success', value: 0 },
    { compat: 'paymentMalformed', modern: 'Malformed', value: -1 },
    { compat: 'paymentUnderfunded', modern: 'Underfunded', value: -2 },
    { compat: 'paymentSrcNoTrust', modern: 'SrcNoTrust', value: -3 },
    { compat: 'paymentSrcNotAuthorized', modern: 'SrcNotAuthorized', value: -4 },
    { compat: 'paymentNoDestination', modern: 'NoDestination', value: -5 },
    { compat: 'paymentNoTrust', modern: 'NoTrust', value: -6 },
    { compat: 'paymentNotAuthorized', modern: 'NotAuthorized', value: -7 },
    { compat: 'paymentLineFull', modern: 'LineFull', value: -8 },
    { compat: 'paymentNoIssuer', modern: 'NoIssuer', value: -9 },
  ],
});
export const PaymentResultCode = _PaymentResultCode as unknown as {
  paymentSuccess(): PaymentResultCode;
  paymentMalformed(): PaymentResultCode;
  paymentUnderfunded(): PaymentResultCode;
  paymentSrcNoTrust(): PaymentResultCode;
  paymentSrcNotAuthorized(): PaymentResultCode;
  paymentNoDestination(): PaymentResultCode;
  paymentNoTrust(): PaymentResultCode;
  paymentNotAuthorized(): PaymentResultCode;
  paymentLineFull(): PaymentResultCode;
  paymentNoIssuer(): PaymentResultCode;
};

export interface PaymentResult {
  switch(): PaymentResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PaymentResult = createCompatUnion({
  codec: modern.PaymentResult,
  switchEnum: _PaymentResultCode,
  arms: [
    { switchValues: ['paymentSuccess'], modern: 'Success' },
    { switchValues: ['paymentMalformed', 'paymentUnderfunded', 'paymentSrcNoTrust', 'paymentSrcNotAuthorized', 'paymentNoDestination', 'paymentNoTrust', 'paymentNotAuthorized', 'paymentLineFull', 'paymentNoIssuer'], modern: 'Malformed' },
  ],
});
export const PaymentResult = _PaymentResult as unknown as {
  paymentSuccess(): PaymentResult;
  paymentMalformed(): PaymentResult;
  paymentUnderfunded(): PaymentResult;
  paymentSrcNoTrust(): PaymentResult;
  paymentSrcNotAuthorized(): PaymentResult;
  paymentNoDestination(): PaymentResult;
  paymentNoTrust(): PaymentResult;
  paymentNotAuthorized(): PaymentResult;
  paymentLineFull(): PaymentResult;
  paymentNoIssuer(): PaymentResult;
  read(io: Buffer): PaymentResult;
  write(value: PaymentResult, io: Buffer): void;
  isValid(value: PaymentResult): boolean;
  toXDR(value: PaymentResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PaymentResult;
  fromXDR(input: string, format: 'hex' | 'base64'): PaymentResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PathPaymentStrictReceiveResultCode {
  readonly name: 'pathPaymentStrictReceiveSuccess' | 'pathPaymentStrictReceiveMalformed' | 'pathPaymentStrictReceiveUnderfunded' | 'pathPaymentStrictReceiveSrcNoTrust' | 'pathPaymentStrictReceiveSrcNotAuthorized' | 'pathPaymentStrictReceiveNoDestination' | 'pathPaymentStrictReceiveNoTrust' | 'pathPaymentStrictReceiveNotAuthorized' | 'pathPaymentStrictReceiveLineFull' | 'pathPaymentStrictReceiveNoIssuer' | 'pathPaymentStrictReceiveTooFewOffers' | 'pathPaymentStrictReceiveOfferCrossSelf' | 'pathPaymentStrictReceiveOverSendmax';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10 | -11 | -12;
}
const _PathPaymentStrictReceiveResultCode = createCompatEnum({
  codec: modern.PathPaymentStrictReceiveResultCode,
  members: [
    { compat: 'pathPaymentStrictReceiveSuccess', modern: 'Success', value: 0 },
    { compat: 'pathPaymentStrictReceiveMalformed', modern: 'Malformed', value: -1 },
    { compat: 'pathPaymentStrictReceiveUnderfunded', modern: 'Underfunded', value: -2 },
    { compat: 'pathPaymentStrictReceiveSrcNoTrust', modern: 'SrcNoTrust', value: -3 },
    { compat: 'pathPaymentStrictReceiveSrcNotAuthorized', modern: 'SrcNotAuthorized', value: -4 },
    { compat: 'pathPaymentStrictReceiveNoDestination', modern: 'NoDestination', value: -5 },
    { compat: 'pathPaymentStrictReceiveNoTrust', modern: 'NoTrust', value: -6 },
    { compat: 'pathPaymentStrictReceiveNotAuthorized', modern: 'NotAuthorized', value: -7 },
    { compat: 'pathPaymentStrictReceiveLineFull', modern: 'LineFull', value: -8 },
    { compat: 'pathPaymentStrictReceiveNoIssuer', modern: 'NoIssuer', value: -9 },
    { compat: 'pathPaymentStrictReceiveTooFewOffers', modern: 'TooFewOffers', value: -10 },
    { compat: 'pathPaymentStrictReceiveOfferCrossSelf', modern: 'OfferCrossSelf', value: -11 },
    { compat: 'pathPaymentStrictReceiveOverSendmax', modern: 'OverSendmax', value: -12 },
  ],
});
export const PathPaymentStrictReceiveResultCode = _PathPaymentStrictReceiveResultCode as unknown as {
  pathPaymentStrictReceiveSuccess(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveMalformed(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveUnderfunded(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveSrcNoTrust(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveSrcNotAuthorized(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveNoDestination(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveNoTrust(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveNotAuthorized(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveLineFull(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveNoIssuer(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveTooFewOffers(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveOfferCrossSelf(): PathPaymentStrictReceiveResultCode;
  pathPaymentStrictReceiveOverSendmax(): PathPaymentStrictReceiveResultCode;
};

export interface ClaimAtomType {
  readonly name: 'claimAtomTypeV0' | 'claimAtomTypeOrderBook' | 'claimAtomTypeLiquidityPool';
  readonly value: 0 | 1 | 2;
}
const _ClaimAtomType = createCompatEnum({
  codec: modern.ClaimAtomType,
  members: [
    { compat: 'claimAtomTypeV0', modern: 'V0', value: 0 },
    { compat: 'claimAtomTypeOrderBook', modern: 'OrderBook', value: 1 },
    { compat: 'claimAtomTypeLiquidityPool', modern: 'LiquidityPool', value: 2 },
  ],
});
export const ClaimAtomType = _ClaimAtomType as unknown as {
  claimAtomTypeV0(): ClaimAtomType;
  claimAtomTypeOrderBook(): ClaimAtomType;
  claimAtomTypeLiquidityPool(): ClaimAtomType;
};

export interface ClaimOfferAtomV0 {
  sellerEd25519(value?: Uint256): Uint256;
  offerId(value?: Int64): Int64;
  assetSold(value?: Asset): Asset;
  amountSold(value?: Int64): Int64;
  assetBought(value?: Asset): Asset;
  amountBought(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimOfferAtomV0 = createCompatStruct({
  codec: modern.ClaimOfferAtomV0,
  fields: [
    { name: 'sellerEd25519', modernName: 'sellerEd25519', convert: id },
    { name: 'offerId', modernName: 'offerID', convert: int64Conv },
    { name: 'assetSold', modernName: 'assetSold', convert: unionConverter(_Asset) },
    { name: 'amountSold', modernName: 'amountSold', convert: int64Conv },
    { name: 'assetBought', modernName: 'assetBought', convert: unionConverter(_Asset) },
    { name: 'amountBought', modernName: 'amountBought', convert: int64Conv },
  ],
});
export const ClaimOfferAtomV0 = _ClaimOfferAtomV0 as unknown as {
  new(attributes: { sellerEd25519: Uint256; offerId: Int64; assetSold: Asset; amountSold: Int64; assetBought: Asset; amountBought: Int64 }): ClaimOfferAtomV0;
  read(io: Buffer): ClaimOfferAtomV0;
  write(value: ClaimOfferAtomV0, io: Buffer): void;
  isValid(value: ClaimOfferAtomV0): boolean;
  toXDR(value: ClaimOfferAtomV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimOfferAtomV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimOfferAtomV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimOfferAtom {
  sellerId(value?: AccountId): AccountId;
  offerId(value?: Int64): Int64;
  assetSold(value?: Asset): Asset;
  amountSold(value?: Int64): Int64;
  assetBought(value?: Asset): Asset;
  amountBought(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimOfferAtom = createCompatStruct({
  codec: modern.ClaimOfferAtom,
  fields: [
    { name: 'sellerId', modernName: 'sellerID', convert: unionConverter(_PublicKey) },
    { name: 'offerId', modernName: 'offerID', convert: int64Conv },
    { name: 'assetSold', modernName: 'assetSold', convert: unionConverter(_Asset) },
    { name: 'amountSold', modernName: 'amountSold', convert: int64Conv },
    { name: 'assetBought', modernName: 'assetBought', convert: unionConverter(_Asset) },
    { name: 'amountBought', modernName: 'amountBought', convert: int64Conv },
  ],
});
export const ClaimOfferAtom = _ClaimOfferAtom as unknown as {
  new(attributes: { sellerId: AccountId; offerId: Int64; assetSold: Asset; amountSold: Int64; assetBought: Asset; amountBought: Int64 }): ClaimOfferAtom;
  read(io: Buffer): ClaimOfferAtom;
  write(value: ClaimOfferAtom, io: Buffer): void;
  isValid(value: ClaimOfferAtom): boolean;
  toXDR(value: ClaimOfferAtom): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimOfferAtom;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimOfferAtom;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimLiquidityAtom {
  liquidityPoolId(value?: PoolId): PoolId;
  assetSold(value?: Asset): Asset;
  amountSold(value?: Int64): Int64;
  assetBought(value?: Asset): Asset;
  amountBought(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimLiquidityAtom = createCompatStruct({
  codec: modern.ClaimLiquidityAtom,
  fields: [
    { name: 'liquidityPoolId', modernName: 'liquidityPoolID', convert: id },
    { name: 'assetSold', modernName: 'assetSold', convert: unionConverter(_Asset) },
    { name: 'amountSold', modernName: 'amountSold', convert: int64Conv },
    { name: 'assetBought', modernName: 'assetBought', convert: unionConverter(_Asset) },
    { name: 'amountBought', modernName: 'amountBought', convert: int64Conv },
  ],
});
export const ClaimLiquidityAtom = _ClaimLiquidityAtom as unknown as {
  new(attributes: { liquidityPoolId: PoolId; assetSold: Asset; amountSold: Int64; assetBought: Asset; amountBought: Int64 }): ClaimLiquidityAtom;
  read(io: Buffer): ClaimLiquidityAtom;
  write(value: ClaimLiquidityAtom, io: Buffer): void;
  isValid(value: ClaimLiquidityAtom): boolean;
  toXDR(value: ClaimLiquidityAtom): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimLiquidityAtom;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimLiquidityAtom;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimAtom {
  switch(): ClaimAtomType;
  v0(value?: ClaimOfferAtomV0): ClaimOfferAtomV0;
  orderBook(value?: ClaimOfferAtom): ClaimOfferAtom;
  liquidityPool(value?: ClaimLiquidityAtom): ClaimLiquidityAtom;
  value(): ClaimOfferAtomV0 | ClaimOfferAtom | ClaimLiquidityAtom;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimAtom = createCompatUnion({
  codec: modern.ClaimAtom,
  switchEnum: _ClaimAtomType,
  arms: [
    { switchValues: ['claimAtomTypeV0'], modern: 'V0', arm: 'v0', convert: structConverter(_ClaimOfferAtomV0) },
    { switchValues: ['claimAtomTypeOrderBook'], modern: 'OrderBook', arm: 'orderBook', convert: structConverter(_ClaimOfferAtom) },
    { switchValues: ['claimAtomTypeLiquidityPool'], modern: 'LiquidityPool', arm: 'liquidityPool', convert: structConverter(_ClaimLiquidityAtom) },
  ],
});
export const ClaimAtom = _ClaimAtom as unknown as {
  claimAtomTypeV0(value: ClaimOfferAtomV0): ClaimAtom;
  claimAtomTypeOrderBook(value: ClaimOfferAtom): ClaimAtom;
  claimAtomTypeLiquidityPool(value: ClaimLiquidityAtom): ClaimAtom;
  read(io: Buffer): ClaimAtom;
  write(value: ClaimAtom, io: Buffer): void;
  isValid(value: ClaimAtom): boolean;
  toXDR(value: ClaimAtom): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimAtom;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimAtom;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SimplePaymentResult {
  destination(value?: AccountId): AccountId;
  asset(value?: Asset): Asset;
  amount(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SimplePaymentResult = createCompatStruct({
  codec: modern.SimplePaymentResult,
  fields: [
    { name: 'destination', modernName: 'destination', convert: unionConverter(_PublicKey) },
    { name: 'asset', modernName: 'asset', convert: unionConverter(_Asset) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
  ],
});
export const SimplePaymentResult = _SimplePaymentResult as unknown as {
  new(attributes: { destination: AccountId; asset: Asset; amount: Int64 }): SimplePaymentResult;
  read(io: Buffer): SimplePaymentResult;
  write(value: SimplePaymentResult, io: Buffer): void;
  isValid(value: SimplePaymentResult): boolean;
  toXDR(value: SimplePaymentResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SimplePaymentResult;
  fromXDR(input: string, format: 'hex' | 'base64'): SimplePaymentResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PathPaymentStrictReceiveResultSuccess {
  offers(value?: ClaimAtom[]): ClaimAtom[];
  last(value?: SimplePaymentResult): SimplePaymentResult;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PathPaymentStrictReceiveResultSuccess = createCompatStruct({
  codec: modern.PathPaymentStrictReceiveResultSuccess,
  fields: [
    { name: 'offers', modernName: 'offers', convert: arrayConverter(unionConverter(_ClaimAtom)) },
    { name: 'last', modernName: 'last', convert: structConverter(_SimplePaymentResult) },
  ],
});
export const PathPaymentStrictReceiveResultSuccess = _PathPaymentStrictReceiveResultSuccess as unknown as {
  new(attributes: { offers: ClaimAtom[]; last: SimplePaymentResult }): PathPaymentStrictReceiveResultSuccess;
  read(io: Buffer): PathPaymentStrictReceiveResultSuccess;
  write(value: PathPaymentStrictReceiveResultSuccess, io: Buffer): void;
  isValid(value: PathPaymentStrictReceiveResultSuccess): boolean;
  toXDR(value: PathPaymentStrictReceiveResultSuccess): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PathPaymentStrictReceiveResultSuccess;
  fromXDR(input: string, format: 'hex' | 'base64'): PathPaymentStrictReceiveResultSuccess;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PathPaymentStrictReceiveResult {
  switch(): PathPaymentStrictReceiveResultCode;
  success(value?: PathPaymentStrictReceiveResultSuccess): PathPaymentStrictReceiveResultSuccess;
  noIssuer(value?: Asset): Asset;
  value(): PathPaymentStrictReceiveResultSuccess | Asset | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PathPaymentStrictReceiveResult = createCompatUnion({
  codec: modern.PathPaymentStrictReceiveResult,
  switchEnum: _PathPaymentStrictReceiveResultCode,
  arms: [
    { switchValues: ['pathPaymentStrictReceiveSuccess'], modern: 'Success', arm: 'success', convert: id },
    { switchValues: ['pathPaymentStrictReceiveMalformed', 'pathPaymentStrictReceiveUnderfunded', 'pathPaymentStrictReceiveSrcNoTrust', 'pathPaymentStrictReceiveSrcNotAuthorized', 'pathPaymentStrictReceiveNoDestination', 'pathPaymentStrictReceiveNoTrust', 'pathPaymentStrictReceiveNotAuthorized', 'pathPaymentStrictReceiveLineFull'], modern: 'Malformed' },
    { switchValues: ['pathPaymentStrictReceiveNoIssuer'], modern: 'NoIssuer', arm: 'noIssuer', convert: unionConverter(_Asset) },
    { switchValues: ['pathPaymentStrictReceiveTooFewOffers', 'pathPaymentStrictReceiveOfferCrossSelf', 'pathPaymentStrictReceiveOverSendmax'], modern: 'TooFewOffers' },
  ],
});
export const PathPaymentStrictReceiveResult = _PathPaymentStrictReceiveResult as unknown as {
  pathPaymentStrictReceiveSuccess(value: PathPaymentStrictReceiveResultSuccess): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveMalformed(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveUnderfunded(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveSrcNoTrust(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveSrcNotAuthorized(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveNoDestination(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveNoTrust(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveNotAuthorized(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveLineFull(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveNoIssuer(value: Asset): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveTooFewOffers(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveOfferCrossSelf(): PathPaymentStrictReceiveResult;
  pathPaymentStrictReceiveOverSendmax(): PathPaymentStrictReceiveResult;
  read(io: Buffer): PathPaymentStrictReceiveResult;
  write(value: PathPaymentStrictReceiveResult, io: Buffer): void;
  isValid(value: PathPaymentStrictReceiveResult): boolean;
  toXDR(value: PathPaymentStrictReceiveResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PathPaymentStrictReceiveResult;
  fromXDR(input: string, format: 'hex' | 'base64'): PathPaymentStrictReceiveResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ManageSellOfferResultCode {
  readonly name: 'manageSellOfferSuccess' | 'manageSellOfferMalformed' | 'manageSellOfferSellNoTrust' | 'manageSellOfferBuyNoTrust' | 'manageSellOfferSellNotAuthorized' | 'manageSellOfferBuyNotAuthorized' | 'manageSellOfferLineFull' | 'manageSellOfferUnderfunded' | 'manageSellOfferCrossSelf' | 'manageSellOfferSellNoIssuer' | 'manageSellOfferBuyNoIssuer' | 'manageSellOfferNotFound' | 'manageSellOfferLowReserve';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10 | -11 | -12;
}
const _ManageSellOfferResultCode = createCompatEnum({
  codec: modern.ManageSellOfferResultCode,
  members: [
    { compat: 'manageSellOfferSuccess', modern: 'Success', value: 0 },
    { compat: 'manageSellOfferMalformed', modern: 'Malformed', value: -1 },
    { compat: 'manageSellOfferSellNoTrust', modern: 'SellNoTrust', value: -2 },
    { compat: 'manageSellOfferBuyNoTrust', modern: 'BuyNoTrust', value: -3 },
    { compat: 'manageSellOfferSellNotAuthorized', modern: 'SellNotAuthorized', value: -4 },
    { compat: 'manageSellOfferBuyNotAuthorized', modern: 'BuyNotAuthorized', value: -5 },
    { compat: 'manageSellOfferLineFull', modern: 'LineFull', value: -6 },
    { compat: 'manageSellOfferUnderfunded', modern: 'Underfunded', value: -7 },
    { compat: 'manageSellOfferCrossSelf', modern: 'CrossSelf', value: -8 },
    { compat: 'manageSellOfferSellNoIssuer', modern: 'SellNoIssuer', value: -9 },
    { compat: 'manageSellOfferBuyNoIssuer', modern: 'BuyNoIssuer', value: -10 },
    { compat: 'manageSellOfferNotFound', modern: 'NotFound', value: -11 },
    { compat: 'manageSellOfferLowReserve', modern: 'LowReserve', value: -12 },
  ],
});
export const ManageSellOfferResultCode = _ManageSellOfferResultCode as unknown as {
  manageSellOfferSuccess(): ManageSellOfferResultCode;
  manageSellOfferMalformed(): ManageSellOfferResultCode;
  manageSellOfferSellNoTrust(): ManageSellOfferResultCode;
  manageSellOfferBuyNoTrust(): ManageSellOfferResultCode;
  manageSellOfferSellNotAuthorized(): ManageSellOfferResultCode;
  manageSellOfferBuyNotAuthorized(): ManageSellOfferResultCode;
  manageSellOfferLineFull(): ManageSellOfferResultCode;
  manageSellOfferUnderfunded(): ManageSellOfferResultCode;
  manageSellOfferCrossSelf(): ManageSellOfferResultCode;
  manageSellOfferSellNoIssuer(): ManageSellOfferResultCode;
  manageSellOfferBuyNoIssuer(): ManageSellOfferResultCode;
  manageSellOfferNotFound(): ManageSellOfferResultCode;
  manageSellOfferLowReserve(): ManageSellOfferResultCode;
};

export interface ManageOfferEffect {
  readonly name: 'manageOfferCreated' | 'manageOfferUpdated' | 'manageOfferDeleted';
  readonly value: 0 | 1 | 2;
}
const _ManageOfferEffect = createCompatEnum({
  codec: modern.ManageOfferEffect,
  members: [
    { compat: 'manageOfferCreated', modern: 'Created', value: 0 },
    { compat: 'manageOfferUpdated', modern: 'Updated', value: 1 },
    { compat: 'manageOfferDeleted', modern: 'Deleted', value: 2 },
  ],
});
export const ManageOfferEffect = _ManageOfferEffect as unknown as {
  manageOfferCreated(): ManageOfferEffect;
  manageOfferUpdated(): ManageOfferEffect;
  manageOfferDeleted(): ManageOfferEffect;
};

export interface OfferEntryExt {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _OfferEntryExt = createCompatUnion({
  codec: modern.OfferEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const OfferEntryExt = _OfferEntryExt as unknown as {
  0(): OfferEntryExt;
  read(io: Buffer): OfferEntryExt;
  write(value: OfferEntryExt, io: Buffer): void;
  isValid(value: OfferEntryExt): boolean;
  toXDR(value: OfferEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): OfferEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): OfferEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface OfferEntry {
  sellerId(value?: AccountId): AccountId;
  offerId(value?: Int64): Int64;
  selling(value?: Asset): Asset;
  buying(value?: Asset): Asset;
  amount(value?: Int64): Int64;
  price(value?: Price): Price;
  flags(value?: Uint32): Uint32;
  ext(value?: OfferEntryExt): OfferEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _OfferEntry = createCompatStruct({
  codec: modern.OfferEntry,
  fields: [
    { name: 'sellerId', modernName: 'sellerID', convert: unionConverter(_PublicKey) },
    { name: 'offerId', modernName: 'offerID', convert: int64Conv },
    { name: 'selling', modernName: 'selling', convert: unionConverter(_Asset) },
    { name: 'buying', modernName: 'buying', convert: unionConverter(_Asset) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
    { name: 'price', modernName: 'price', convert: structConverter(_Price) },
    { name: 'flags', modernName: 'flags', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const OfferEntry = _OfferEntry as unknown as {
  new(attributes: { sellerId: AccountId; offerId: Int64; selling: Asset; buying: Asset; amount: Int64; price: Price; flags: Uint32; ext: OfferEntryExt }): OfferEntry;
  read(io: Buffer): OfferEntry;
  write(value: OfferEntry, io: Buffer): void;
  isValid(value: OfferEntry): boolean;
  toXDR(value: OfferEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): OfferEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): OfferEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ManageOfferSuccessResultOffer {
  switch(): ManageOfferEffect;
  offer(value?: OfferEntry): OfferEntry;
  value(): OfferEntry | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ManageOfferSuccessResultOffer = createCompatUnion({
  codec: modern.ManageOfferSuccessResultOffer,
  switchEnum: _ManageOfferEffect,
  arms: [
    { switchValues: ['manageOfferCreated', 'manageOfferUpdated'], modern: 'Created', arm: 'offer', convert: structConverter(_OfferEntry) },
    { switchValues: ['manageOfferDeleted'], modern: 'Deleted' },
  ],
});
export const ManageOfferSuccessResultOffer = _ManageOfferSuccessResultOffer as unknown as {
  manageOfferCreated(value: OfferEntry): ManageOfferSuccessResultOffer;
  manageOfferUpdated(value: OfferEntry): ManageOfferSuccessResultOffer;
  manageOfferDeleted(): ManageOfferSuccessResultOffer;
  read(io: Buffer): ManageOfferSuccessResultOffer;
  write(value: ManageOfferSuccessResultOffer, io: Buffer): void;
  isValid(value: ManageOfferSuccessResultOffer): boolean;
  toXDR(value: ManageOfferSuccessResultOffer): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ManageOfferSuccessResultOffer;
  fromXDR(input: string, format: 'hex' | 'base64'): ManageOfferSuccessResultOffer;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ManageOfferSuccessResult {
  offersClaimed(value?: ClaimAtom[]): ClaimAtom[];
  offer(value?: ManageOfferSuccessResultOffer): ManageOfferSuccessResultOffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ManageOfferSuccessResult = createCompatStruct({
  codec: modern.ManageOfferSuccessResult,
  fields: [
    { name: 'offersClaimed', modernName: 'offersClaimed', convert: arrayConverter(unionConverter(_ClaimAtom)) },
    { name: 'offer', modernName: 'offer', convert: id },
  ],
});
export const ManageOfferSuccessResult = _ManageOfferSuccessResult as unknown as {
  new(attributes: { offersClaimed: ClaimAtom[]; offer: ManageOfferSuccessResultOffer }): ManageOfferSuccessResult;
  read(io: Buffer): ManageOfferSuccessResult;
  write(value: ManageOfferSuccessResult, io: Buffer): void;
  isValid(value: ManageOfferSuccessResult): boolean;
  toXDR(value: ManageOfferSuccessResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ManageOfferSuccessResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ManageOfferSuccessResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ManageSellOfferResult {
  switch(): ManageSellOfferResultCode;
  success(value?: ManageOfferSuccessResult): ManageOfferSuccessResult;
  value(): ManageOfferSuccessResult | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ManageSellOfferResult = createCompatUnion({
  codec: modern.ManageSellOfferResult,
  switchEnum: _ManageSellOfferResultCode,
  arms: [
    { switchValues: ['manageSellOfferSuccess'], modern: 'Success', arm: 'success', convert: structConverter(_ManageOfferSuccessResult) },
    { switchValues: ['manageSellOfferMalformed', 'manageSellOfferSellNoTrust', 'manageSellOfferBuyNoTrust', 'manageSellOfferSellNotAuthorized', 'manageSellOfferBuyNotAuthorized', 'manageSellOfferLineFull', 'manageSellOfferUnderfunded', 'manageSellOfferCrossSelf', 'manageSellOfferSellNoIssuer', 'manageSellOfferBuyNoIssuer', 'manageSellOfferNotFound', 'manageSellOfferLowReserve'], modern: 'Malformed' },
  ],
});
export const ManageSellOfferResult = _ManageSellOfferResult as unknown as {
  manageSellOfferSuccess(value: ManageOfferSuccessResult): ManageSellOfferResult;
  manageSellOfferMalformed(): ManageSellOfferResult;
  manageSellOfferSellNoTrust(): ManageSellOfferResult;
  manageSellOfferBuyNoTrust(): ManageSellOfferResult;
  manageSellOfferSellNotAuthorized(): ManageSellOfferResult;
  manageSellOfferBuyNotAuthorized(): ManageSellOfferResult;
  manageSellOfferLineFull(): ManageSellOfferResult;
  manageSellOfferUnderfunded(): ManageSellOfferResult;
  manageSellOfferCrossSelf(): ManageSellOfferResult;
  manageSellOfferSellNoIssuer(): ManageSellOfferResult;
  manageSellOfferBuyNoIssuer(): ManageSellOfferResult;
  manageSellOfferNotFound(): ManageSellOfferResult;
  manageSellOfferLowReserve(): ManageSellOfferResult;
  read(io: Buffer): ManageSellOfferResult;
  write(value: ManageSellOfferResult, io: Buffer): void;
  isValid(value: ManageSellOfferResult): boolean;
  toXDR(value: ManageSellOfferResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ManageSellOfferResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ManageSellOfferResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SetOptionsResultCode {
  readonly name: 'setOptionsSuccess' | 'setOptionsLowReserve' | 'setOptionsTooManySigners' | 'setOptionsBadFlags' | 'setOptionsInvalidInflation' | 'setOptionsCantChange' | 'setOptionsUnknownFlag' | 'setOptionsThresholdOutOfRange' | 'setOptionsBadSigner' | 'setOptionsInvalidHomeDomain' | 'setOptionsAuthRevocableRequired';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10;
}
const _SetOptionsResultCode = createCompatEnum({
  codec: modern.SetOptionsResultCode,
  members: [
    { compat: 'setOptionsSuccess', modern: 'Success', value: 0 },
    { compat: 'setOptionsLowReserve', modern: 'LowReserve', value: -1 },
    { compat: 'setOptionsTooManySigners', modern: 'TooManySigners', value: -2 },
    { compat: 'setOptionsBadFlags', modern: 'BadFlags', value: -3 },
    { compat: 'setOptionsInvalidInflation', modern: 'InvalidInflation', value: -4 },
    { compat: 'setOptionsCantChange', modern: 'CantChange', value: -5 },
    { compat: 'setOptionsUnknownFlag', modern: 'UnknownFlag', value: -6 },
    { compat: 'setOptionsThresholdOutOfRange', modern: 'ThresholdOutOfRange', value: -7 },
    { compat: 'setOptionsBadSigner', modern: 'BadSigner', value: -8 },
    { compat: 'setOptionsInvalidHomeDomain', modern: 'InvalidHomeDomain', value: -9 },
    { compat: 'setOptionsAuthRevocableRequired', modern: 'AuthRevocableRequired', value: -10 },
  ],
});
export const SetOptionsResultCode = _SetOptionsResultCode as unknown as {
  setOptionsSuccess(): SetOptionsResultCode;
  setOptionsLowReserve(): SetOptionsResultCode;
  setOptionsTooManySigners(): SetOptionsResultCode;
  setOptionsBadFlags(): SetOptionsResultCode;
  setOptionsInvalidInflation(): SetOptionsResultCode;
  setOptionsCantChange(): SetOptionsResultCode;
  setOptionsUnknownFlag(): SetOptionsResultCode;
  setOptionsThresholdOutOfRange(): SetOptionsResultCode;
  setOptionsBadSigner(): SetOptionsResultCode;
  setOptionsInvalidHomeDomain(): SetOptionsResultCode;
  setOptionsAuthRevocableRequired(): SetOptionsResultCode;
};

export interface SetOptionsResult {
  switch(): SetOptionsResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SetOptionsResult = createCompatUnion({
  codec: modern.SetOptionsResult,
  switchEnum: _SetOptionsResultCode,
  arms: [
    { switchValues: ['setOptionsSuccess'], modern: 'Success' },
    { switchValues: ['setOptionsLowReserve', 'setOptionsTooManySigners', 'setOptionsBadFlags', 'setOptionsInvalidInflation', 'setOptionsCantChange', 'setOptionsUnknownFlag', 'setOptionsThresholdOutOfRange', 'setOptionsBadSigner', 'setOptionsInvalidHomeDomain', 'setOptionsAuthRevocableRequired'], modern: 'LowReserve' },
  ],
});
export const SetOptionsResult = _SetOptionsResult as unknown as {
  setOptionsSuccess(): SetOptionsResult;
  setOptionsLowReserve(): SetOptionsResult;
  setOptionsTooManySigners(): SetOptionsResult;
  setOptionsBadFlags(): SetOptionsResult;
  setOptionsInvalidInflation(): SetOptionsResult;
  setOptionsCantChange(): SetOptionsResult;
  setOptionsUnknownFlag(): SetOptionsResult;
  setOptionsThresholdOutOfRange(): SetOptionsResult;
  setOptionsBadSigner(): SetOptionsResult;
  setOptionsInvalidHomeDomain(): SetOptionsResult;
  setOptionsAuthRevocableRequired(): SetOptionsResult;
  read(io: Buffer): SetOptionsResult;
  write(value: SetOptionsResult, io: Buffer): void;
  isValid(value: SetOptionsResult): boolean;
  toXDR(value: SetOptionsResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SetOptionsResult;
  fromXDR(input: string, format: 'hex' | 'base64'): SetOptionsResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ChangeTrustResultCode {
  readonly name: 'changeTrustSuccess' | 'changeTrustMalformed' | 'changeTrustNoIssuer' | 'changeTrustInvalidLimit' | 'changeTrustLowReserve' | 'changeTrustSelfNotAllowed' | 'changeTrustTrustLineMissing' | 'changeTrustCannotDelete' | 'changeTrustNotAuthMaintainLiabilities';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8;
}
const _ChangeTrustResultCode = createCompatEnum({
  codec: modern.ChangeTrustResultCode,
  members: [
    { compat: 'changeTrustSuccess', modern: 'Success', value: 0 },
    { compat: 'changeTrustMalformed', modern: 'Malformed', value: -1 },
    { compat: 'changeTrustNoIssuer', modern: 'NoIssuer', value: -2 },
    { compat: 'changeTrustInvalidLimit', modern: 'InvalidLimit', value: -3 },
    { compat: 'changeTrustLowReserve', modern: 'LowReserve', value: -4 },
    { compat: 'changeTrustSelfNotAllowed', modern: 'SelfNotAllowed', value: -5 },
    { compat: 'changeTrustTrustLineMissing', modern: 'TrustLineMissing', value: -6 },
    { compat: 'changeTrustCannotDelete', modern: 'CannotDelete', value: -7 },
    { compat: 'changeTrustNotAuthMaintainLiabilities', modern: 'NotAuthMaintainLiabilities', value: -8 },
  ],
});
export const ChangeTrustResultCode = _ChangeTrustResultCode as unknown as {
  changeTrustSuccess(): ChangeTrustResultCode;
  changeTrustMalformed(): ChangeTrustResultCode;
  changeTrustNoIssuer(): ChangeTrustResultCode;
  changeTrustInvalidLimit(): ChangeTrustResultCode;
  changeTrustLowReserve(): ChangeTrustResultCode;
  changeTrustSelfNotAllowed(): ChangeTrustResultCode;
  changeTrustTrustLineMissing(): ChangeTrustResultCode;
  changeTrustCannotDelete(): ChangeTrustResultCode;
  changeTrustNotAuthMaintainLiabilities(): ChangeTrustResultCode;
};

export interface ChangeTrustResult {
  switch(): ChangeTrustResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ChangeTrustResult = createCompatUnion({
  codec: modern.ChangeTrustResult,
  switchEnum: _ChangeTrustResultCode,
  arms: [
    { switchValues: ['changeTrustSuccess'], modern: 'Success' },
    { switchValues: ['changeTrustMalformed', 'changeTrustNoIssuer', 'changeTrustInvalidLimit', 'changeTrustLowReserve', 'changeTrustSelfNotAllowed', 'changeTrustTrustLineMissing', 'changeTrustCannotDelete', 'changeTrustNotAuthMaintainLiabilities'], modern: 'Malformed' },
  ],
});
export const ChangeTrustResult = _ChangeTrustResult as unknown as {
  changeTrustSuccess(): ChangeTrustResult;
  changeTrustMalformed(): ChangeTrustResult;
  changeTrustNoIssuer(): ChangeTrustResult;
  changeTrustInvalidLimit(): ChangeTrustResult;
  changeTrustLowReserve(): ChangeTrustResult;
  changeTrustSelfNotAllowed(): ChangeTrustResult;
  changeTrustTrustLineMissing(): ChangeTrustResult;
  changeTrustCannotDelete(): ChangeTrustResult;
  changeTrustNotAuthMaintainLiabilities(): ChangeTrustResult;
  read(io: Buffer): ChangeTrustResult;
  write(value: ChangeTrustResult, io: Buffer): void;
  isValid(value: ChangeTrustResult): boolean;
  toXDR(value: ChangeTrustResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ChangeTrustResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ChangeTrustResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AllowTrustResultCode {
  readonly name: 'allowTrustSuccess' | 'allowTrustMalformed' | 'allowTrustNoTrustLine' | 'allowTrustTrustNotRequired' | 'allowTrustCantRevoke' | 'allowTrustSelfNotAllowed' | 'allowTrustLowReserve';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6;
}
const _AllowTrustResultCode = createCompatEnum({
  codec: modern.AllowTrustResultCode,
  members: [
    { compat: 'allowTrustSuccess', modern: 'Success', value: 0 },
    { compat: 'allowTrustMalformed', modern: 'Malformed', value: -1 },
    { compat: 'allowTrustNoTrustLine', modern: 'NoTrustLine', value: -2 },
    { compat: 'allowTrustTrustNotRequired', modern: 'TrustNotRequired', value: -3 },
    { compat: 'allowTrustCantRevoke', modern: 'CantRevoke', value: -4 },
    { compat: 'allowTrustSelfNotAllowed', modern: 'SelfNotAllowed', value: -5 },
    { compat: 'allowTrustLowReserve', modern: 'LowReserve', value: -6 },
  ],
});
export const AllowTrustResultCode = _AllowTrustResultCode as unknown as {
  allowTrustSuccess(): AllowTrustResultCode;
  allowTrustMalformed(): AllowTrustResultCode;
  allowTrustNoTrustLine(): AllowTrustResultCode;
  allowTrustTrustNotRequired(): AllowTrustResultCode;
  allowTrustCantRevoke(): AllowTrustResultCode;
  allowTrustSelfNotAllowed(): AllowTrustResultCode;
  allowTrustLowReserve(): AllowTrustResultCode;
};

export interface AllowTrustResult {
  switch(): AllowTrustResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AllowTrustResult = createCompatUnion({
  codec: modern.AllowTrustResult,
  switchEnum: _AllowTrustResultCode,
  arms: [
    { switchValues: ['allowTrustSuccess'], modern: 'Success' },
    { switchValues: ['allowTrustMalformed', 'allowTrustNoTrustLine', 'allowTrustTrustNotRequired', 'allowTrustCantRevoke', 'allowTrustSelfNotAllowed', 'allowTrustLowReserve'], modern: 'Malformed' },
  ],
});
export const AllowTrustResult = _AllowTrustResult as unknown as {
  allowTrustSuccess(): AllowTrustResult;
  allowTrustMalformed(): AllowTrustResult;
  allowTrustNoTrustLine(): AllowTrustResult;
  allowTrustTrustNotRequired(): AllowTrustResult;
  allowTrustCantRevoke(): AllowTrustResult;
  allowTrustSelfNotAllowed(): AllowTrustResult;
  allowTrustLowReserve(): AllowTrustResult;
  read(io: Buffer): AllowTrustResult;
  write(value: AllowTrustResult, io: Buffer): void;
  isValid(value: AllowTrustResult): boolean;
  toXDR(value: AllowTrustResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AllowTrustResult;
  fromXDR(input: string, format: 'hex' | 'base64'): AllowTrustResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AccountMergeResultCode {
  readonly name: 'accountMergeSuccess' | 'accountMergeMalformed' | 'accountMergeNoAccount' | 'accountMergeImmutableSet' | 'accountMergeHasSubEntries' | 'accountMergeSeqnumTooFar' | 'accountMergeDestFull' | 'accountMergeIsSponsor';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7;
}
const _AccountMergeResultCode = createCompatEnum({
  codec: modern.AccountMergeResultCode,
  members: [
    { compat: 'accountMergeSuccess', modern: 'Success', value: 0 },
    { compat: 'accountMergeMalformed', modern: 'Malformed', value: -1 },
    { compat: 'accountMergeNoAccount', modern: 'NoAccount', value: -2 },
    { compat: 'accountMergeImmutableSet', modern: 'ImmutableSet', value: -3 },
    { compat: 'accountMergeHasSubEntries', modern: 'HasSubEntries', value: -4 },
    { compat: 'accountMergeSeqnumTooFar', modern: 'SeqnumTooFar', value: -5 },
    { compat: 'accountMergeDestFull', modern: 'DestFull', value: -6 },
    { compat: 'accountMergeIsSponsor', modern: 'IsSponsor', value: -7 },
  ],
});
export const AccountMergeResultCode = _AccountMergeResultCode as unknown as {
  accountMergeSuccess(): AccountMergeResultCode;
  accountMergeMalformed(): AccountMergeResultCode;
  accountMergeNoAccount(): AccountMergeResultCode;
  accountMergeImmutableSet(): AccountMergeResultCode;
  accountMergeHasSubEntries(): AccountMergeResultCode;
  accountMergeSeqnumTooFar(): AccountMergeResultCode;
  accountMergeDestFull(): AccountMergeResultCode;
  accountMergeIsSponsor(): AccountMergeResultCode;
};

export interface AccountMergeResult {
  switch(): AccountMergeResultCode;
  sourceAccountBalance(value?: Int64): Int64;
  value(): Int64 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AccountMergeResult = createCompatUnion({
  codec: modern.AccountMergeResult,
  switchEnum: _AccountMergeResultCode,
  arms: [
    { switchValues: ['accountMergeSuccess'], modern: 'Success', arm: 'sourceAccountBalance', convert: int64Conv },
    { switchValues: ['accountMergeMalformed', 'accountMergeNoAccount', 'accountMergeImmutableSet', 'accountMergeHasSubEntries', 'accountMergeSeqnumTooFar', 'accountMergeDestFull', 'accountMergeIsSponsor'], modern: 'Malformed' },
  ],
});
export const AccountMergeResult = _AccountMergeResult as unknown as {
  accountMergeSuccess(value: Int64): AccountMergeResult;
  accountMergeMalformed(): AccountMergeResult;
  accountMergeNoAccount(): AccountMergeResult;
  accountMergeImmutableSet(): AccountMergeResult;
  accountMergeHasSubEntries(): AccountMergeResult;
  accountMergeSeqnumTooFar(): AccountMergeResult;
  accountMergeDestFull(): AccountMergeResult;
  accountMergeIsSponsor(): AccountMergeResult;
  read(io: Buffer): AccountMergeResult;
  write(value: AccountMergeResult, io: Buffer): void;
  isValid(value: AccountMergeResult): boolean;
  toXDR(value: AccountMergeResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AccountMergeResult;
  fromXDR(input: string, format: 'hex' | 'base64'): AccountMergeResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InflationResultCode {
  readonly name: 'inflationSuccess' | 'inflationNotTime';
  readonly value: 0 | -1;
}
const _InflationResultCode = createCompatEnum({
  codec: modern.InflationResultCode,
  members: [
    { compat: 'inflationSuccess', modern: 'Success', value: 0 },
    { compat: 'inflationNotTime', modern: 'NotTime', value: -1 },
  ],
});
export const InflationResultCode = _InflationResultCode as unknown as {
  inflationSuccess(): InflationResultCode;
  inflationNotTime(): InflationResultCode;
};

export interface InflationPayout {
  destination(value?: AccountId): AccountId;
  amount(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InflationPayout = createCompatStruct({
  codec: modern.InflationPayout,
  fields: [
    { name: 'destination', modernName: 'destination', convert: unionConverter(_PublicKey) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
  ],
});
export const InflationPayout = _InflationPayout as unknown as {
  new(attributes: { destination: AccountId; amount: Int64 }): InflationPayout;
  read(io: Buffer): InflationPayout;
  write(value: InflationPayout, io: Buffer): void;
  isValid(value: InflationPayout): boolean;
  toXDR(value: InflationPayout): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InflationPayout;
  fromXDR(input: string, format: 'hex' | 'base64'): InflationPayout;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InflationResult {
  switch(): InflationResultCode;
  payouts(value?: InflationPayout[]): InflationPayout[];
  value(): InflationPayout[] | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InflationResult = createCompatUnion({
  codec: modern.InflationResult,
  switchEnum: _InflationResultCode,
  arms: [
    { switchValues: ['inflationSuccess'], modern: 'Success', arm: 'payouts', convert: arrayConverter(structConverter(_InflationPayout)) },
    { switchValues: ['inflationNotTime'], modern: 'NotTime' },
  ],
});
export const InflationResult = _InflationResult as unknown as {
  inflationSuccess(value: InflationPayout[]): InflationResult;
  inflationNotTime(): InflationResult;
  read(io: Buffer): InflationResult;
  write(value: InflationResult, io: Buffer): void;
  isValid(value: InflationResult): boolean;
  toXDR(value: InflationResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InflationResult;
  fromXDR(input: string, format: 'hex' | 'base64'): InflationResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ManageDataResultCode {
  readonly name: 'manageDataSuccess' | 'manageDataNotSupportedYet' | 'manageDataNameNotFound' | 'manageDataLowReserve' | 'manageDataInvalidName';
  readonly value: 0 | -1 | -2 | -3 | -4;
}
const _ManageDataResultCode = createCompatEnum({
  codec: modern.ManageDataResultCode,
  members: [
    { compat: 'manageDataSuccess', modern: 'Success', value: 0 },
    { compat: 'manageDataNotSupportedYet', modern: 'NotSupportedYet', value: -1 },
    { compat: 'manageDataNameNotFound', modern: 'NameNotFound', value: -2 },
    { compat: 'manageDataLowReserve', modern: 'LowReserve', value: -3 },
    { compat: 'manageDataInvalidName', modern: 'InvalidName', value: -4 },
  ],
});
export const ManageDataResultCode = _ManageDataResultCode as unknown as {
  manageDataSuccess(): ManageDataResultCode;
  manageDataNotSupportedYet(): ManageDataResultCode;
  manageDataNameNotFound(): ManageDataResultCode;
  manageDataLowReserve(): ManageDataResultCode;
  manageDataInvalidName(): ManageDataResultCode;
};

export interface ManageDataResult {
  switch(): ManageDataResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ManageDataResult = createCompatUnion({
  codec: modern.ManageDataResult,
  switchEnum: _ManageDataResultCode,
  arms: [
    { switchValues: ['manageDataSuccess'], modern: 'Success' },
    { switchValues: ['manageDataNotSupportedYet', 'manageDataNameNotFound', 'manageDataLowReserve', 'manageDataInvalidName'], modern: 'NotSupportedYet' },
  ],
});
export const ManageDataResult = _ManageDataResult as unknown as {
  manageDataSuccess(): ManageDataResult;
  manageDataNotSupportedYet(): ManageDataResult;
  manageDataNameNotFound(): ManageDataResult;
  manageDataLowReserve(): ManageDataResult;
  manageDataInvalidName(): ManageDataResult;
  read(io: Buffer): ManageDataResult;
  write(value: ManageDataResult, io: Buffer): void;
  isValid(value: ManageDataResult): boolean;
  toXDR(value: ManageDataResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ManageDataResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ManageDataResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface BumpSequenceResultCode {
  readonly name: 'bumpSequenceSuccess' | 'bumpSequenceBadSeq';
  readonly value: 0 | -1;
}
const _BumpSequenceResultCode = createCompatEnum({
  codec: modern.BumpSequenceResultCode,
  members: [
    { compat: 'bumpSequenceSuccess', modern: 'Success', value: 0 },
    { compat: 'bumpSequenceBadSeq', modern: 'BadSeq', value: -1 },
  ],
});
export const BumpSequenceResultCode = _BumpSequenceResultCode as unknown as {
  bumpSequenceSuccess(): BumpSequenceResultCode;
  bumpSequenceBadSeq(): BumpSequenceResultCode;
};

export interface BumpSequenceResult {
  switch(): BumpSequenceResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _BumpSequenceResult = createCompatUnion({
  codec: modern.BumpSequenceResult,
  switchEnum: _BumpSequenceResultCode,
  arms: [
    { switchValues: ['bumpSequenceSuccess'], modern: 'Success' },
    { switchValues: ['bumpSequenceBadSeq'], modern: 'BadSeq' },
  ],
});
export const BumpSequenceResult = _BumpSequenceResult as unknown as {
  bumpSequenceSuccess(): BumpSequenceResult;
  bumpSequenceBadSeq(): BumpSequenceResult;
  read(io: Buffer): BumpSequenceResult;
  write(value: BumpSequenceResult, io: Buffer): void;
  isValid(value: BumpSequenceResult): boolean;
  toXDR(value: BumpSequenceResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): BumpSequenceResult;
  fromXDR(input: string, format: 'hex' | 'base64'): BumpSequenceResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ManageBuyOfferResultCode {
  readonly name: 'manageBuyOfferSuccess' | 'manageBuyOfferMalformed' | 'manageBuyOfferSellNoTrust' | 'manageBuyOfferBuyNoTrust' | 'manageBuyOfferSellNotAuthorized' | 'manageBuyOfferBuyNotAuthorized' | 'manageBuyOfferLineFull' | 'manageBuyOfferUnderfunded' | 'manageBuyOfferCrossSelf' | 'manageBuyOfferSellNoIssuer' | 'manageBuyOfferBuyNoIssuer' | 'manageBuyOfferNotFound' | 'manageBuyOfferLowReserve';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10 | -11 | -12;
}
const _ManageBuyOfferResultCode = createCompatEnum({
  codec: modern.ManageBuyOfferResultCode,
  members: [
    { compat: 'manageBuyOfferSuccess', modern: 'Success', value: 0 },
    { compat: 'manageBuyOfferMalformed', modern: 'Malformed', value: -1 },
    { compat: 'manageBuyOfferSellNoTrust', modern: 'SellNoTrust', value: -2 },
    { compat: 'manageBuyOfferBuyNoTrust', modern: 'BuyNoTrust', value: -3 },
    { compat: 'manageBuyOfferSellNotAuthorized', modern: 'SellNotAuthorized', value: -4 },
    { compat: 'manageBuyOfferBuyNotAuthorized', modern: 'BuyNotAuthorized', value: -5 },
    { compat: 'manageBuyOfferLineFull', modern: 'LineFull', value: -6 },
    { compat: 'manageBuyOfferUnderfunded', modern: 'Underfunded', value: -7 },
    { compat: 'manageBuyOfferCrossSelf', modern: 'CrossSelf', value: -8 },
    { compat: 'manageBuyOfferSellNoIssuer', modern: 'SellNoIssuer', value: -9 },
    { compat: 'manageBuyOfferBuyNoIssuer', modern: 'BuyNoIssuer', value: -10 },
    { compat: 'manageBuyOfferNotFound', modern: 'NotFound', value: -11 },
    { compat: 'manageBuyOfferLowReserve', modern: 'LowReserve', value: -12 },
  ],
});
export const ManageBuyOfferResultCode = _ManageBuyOfferResultCode as unknown as {
  manageBuyOfferSuccess(): ManageBuyOfferResultCode;
  manageBuyOfferMalformed(): ManageBuyOfferResultCode;
  manageBuyOfferSellNoTrust(): ManageBuyOfferResultCode;
  manageBuyOfferBuyNoTrust(): ManageBuyOfferResultCode;
  manageBuyOfferSellNotAuthorized(): ManageBuyOfferResultCode;
  manageBuyOfferBuyNotAuthorized(): ManageBuyOfferResultCode;
  manageBuyOfferLineFull(): ManageBuyOfferResultCode;
  manageBuyOfferUnderfunded(): ManageBuyOfferResultCode;
  manageBuyOfferCrossSelf(): ManageBuyOfferResultCode;
  manageBuyOfferSellNoIssuer(): ManageBuyOfferResultCode;
  manageBuyOfferBuyNoIssuer(): ManageBuyOfferResultCode;
  manageBuyOfferNotFound(): ManageBuyOfferResultCode;
  manageBuyOfferLowReserve(): ManageBuyOfferResultCode;
};

export interface ManageBuyOfferResult {
  switch(): ManageBuyOfferResultCode;
  success(value?: ManageOfferSuccessResult): ManageOfferSuccessResult;
  value(): ManageOfferSuccessResult | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ManageBuyOfferResult = createCompatUnion({
  codec: modern.ManageBuyOfferResult,
  switchEnum: _ManageBuyOfferResultCode,
  arms: [
    { switchValues: ['manageBuyOfferSuccess'], modern: 'Success', arm: 'success', convert: structConverter(_ManageOfferSuccessResult) },
    { switchValues: ['manageBuyOfferMalformed', 'manageBuyOfferSellNoTrust', 'manageBuyOfferBuyNoTrust', 'manageBuyOfferSellNotAuthorized', 'manageBuyOfferBuyNotAuthorized', 'manageBuyOfferLineFull', 'manageBuyOfferUnderfunded', 'manageBuyOfferCrossSelf', 'manageBuyOfferSellNoIssuer', 'manageBuyOfferBuyNoIssuer', 'manageBuyOfferNotFound', 'manageBuyOfferLowReserve'], modern: 'Malformed' },
  ],
});
export const ManageBuyOfferResult = _ManageBuyOfferResult as unknown as {
  manageBuyOfferSuccess(value: ManageOfferSuccessResult): ManageBuyOfferResult;
  manageBuyOfferMalformed(): ManageBuyOfferResult;
  manageBuyOfferSellNoTrust(): ManageBuyOfferResult;
  manageBuyOfferBuyNoTrust(): ManageBuyOfferResult;
  manageBuyOfferSellNotAuthorized(): ManageBuyOfferResult;
  manageBuyOfferBuyNotAuthorized(): ManageBuyOfferResult;
  manageBuyOfferLineFull(): ManageBuyOfferResult;
  manageBuyOfferUnderfunded(): ManageBuyOfferResult;
  manageBuyOfferCrossSelf(): ManageBuyOfferResult;
  manageBuyOfferSellNoIssuer(): ManageBuyOfferResult;
  manageBuyOfferBuyNoIssuer(): ManageBuyOfferResult;
  manageBuyOfferNotFound(): ManageBuyOfferResult;
  manageBuyOfferLowReserve(): ManageBuyOfferResult;
  read(io: Buffer): ManageBuyOfferResult;
  write(value: ManageBuyOfferResult, io: Buffer): void;
  isValid(value: ManageBuyOfferResult): boolean;
  toXDR(value: ManageBuyOfferResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ManageBuyOfferResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ManageBuyOfferResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PathPaymentStrictSendResultCode {
  readonly name: 'pathPaymentStrictSendSuccess' | 'pathPaymentStrictSendMalformed' | 'pathPaymentStrictSendUnderfunded' | 'pathPaymentStrictSendSrcNoTrust' | 'pathPaymentStrictSendSrcNotAuthorized' | 'pathPaymentStrictSendNoDestination' | 'pathPaymentStrictSendNoTrust' | 'pathPaymentStrictSendNotAuthorized' | 'pathPaymentStrictSendLineFull' | 'pathPaymentStrictSendNoIssuer' | 'pathPaymentStrictSendTooFewOffers' | 'pathPaymentStrictSendOfferCrossSelf' | 'pathPaymentStrictSendUnderDestmin';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10 | -11 | -12;
}
const _PathPaymentStrictSendResultCode = createCompatEnum({
  codec: modern.PathPaymentStrictSendResultCode,
  members: [
    { compat: 'pathPaymentStrictSendSuccess', modern: 'Success', value: 0 },
    { compat: 'pathPaymentStrictSendMalformed', modern: 'Malformed', value: -1 },
    { compat: 'pathPaymentStrictSendUnderfunded', modern: 'Underfunded', value: -2 },
    { compat: 'pathPaymentStrictSendSrcNoTrust', modern: 'SrcNoTrust', value: -3 },
    { compat: 'pathPaymentStrictSendSrcNotAuthorized', modern: 'SrcNotAuthorized', value: -4 },
    { compat: 'pathPaymentStrictSendNoDestination', modern: 'NoDestination', value: -5 },
    { compat: 'pathPaymentStrictSendNoTrust', modern: 'NoTrust', value: -6 },
    { compat: 'pathPaymentStrictSendNotAuthorized', modern: 'NotAuthorized', value: -7 },
    { compat: 'pathPaymentStrictSendLineFull', modern: 'LineFull', value: -8 },
    { compat: 'pathPaymentStrictSendNoIssuer', modern: 'NoIssuer', value: -9 },
    { compat: 'pathPaymentStrictSendTooFewOffers', modern: 'TooFewOffers', value: -10 },
    { compat: 'pathPaymentStrictSendOfferCrossSelf', modern: 'OfferCrossSelf', value: -11 },
    { compat: 'pathPaymentStrictSendUnderDestmin', modern: 'UnderDestmin', value: -12 },
  ],
});
export const PathPaymentStrictSendResultCode = _PathPaymentStrictSendResultCode as unknown as {
  pathPaymentStrictSendSuccess(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendMalformed(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendUnderfunded(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendSrcNoTrust(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendSrcNotAuthorized(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendNoDestination(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendNoTrust(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendNotAuthorized(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendLineFull(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendNoIssuer(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendTooFewOffers(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendOfferCrossSelf(): PathPaymentStrictSendResultCode;
  pathPaymentStrictSendUnderDestmin(): PathPaymentStrictSendResultCode;
};

export interface PathPaymentStrictSendResultSuccess {
  offers(value?: ClaimAtom[]): ClaimAtom[];
  last(value?: SimplePaymentResult): SimplePaymentResult;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PathPaymentStrictSendResultSuccess = createCompatStruct({
  codec: modern.PathPaymentStrictSendResultSuccess,
  fields: [
    { name: 'offers', modernName: 'offers', convert: arrayConverter(unionConverter(_ClaimAtom)) },
    { name: 'last', modernName: 'last', convert: structConverter(_SimplePaymentResult) },
  ],
});
export const PathPaymentStrictSendResultSuccess = _PathPaymentStrictSendResultSuccess as unknown as {
  new(attributes: { offers: ClaimAtom[]; last: SimplePaymentResult }): PathPaymentStrictSendResultSuccess;
  read(io: Buffer): PathPaymentStrictSendResultSuccess;
  write(value: PathPaymentStrictSendResultSuccess, io: Buffer): void;
  isValid(value: PathPaymentStrictSendResultSuccess): boolean;
  toXDR(value: PathPaymentStrictSendResultSuccess): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PathPaymentStrictSendResultSuccess;
  fromXDR(input: string, format: 'hex' | 'base64'): PathPaymentStrictSendResultSuccess;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PathPaymentStrictSendResult {
  switch(): PathPaymentStrictSendResultCode;
  success(value?: PathPaymentStrictSendResultSuccess): PathPaymentStrictSendResultSuccess;
  noIssuer(value?: Asset): Asset;
  value(): PathPaymentStrictSendResultSuccess | Asset | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PathPaymentStrictSendResult = createCompatUnion({
  codec: modern.PathPaymentStrictSendResult,
  switchEnum: _PathPaymentStrictSendResultCode,
  arms: [
    { switchValues: ['pathPaymentStrictSendSuccess'], modern: 'Success', arm: 'success', convert: id },
    { switchValues: ['pathPaymentStrictSendMalformed', 'pathPaymentStrictSendUnderfunded', 'pathPaymentStrictSendSrcNoTrust', 'pathPaymentStrictSendSrcNotAuthorized', 'pathPaymentStrictSendNoDestination', 'pathPaymentStrictSendNoTrust', 'pathPaymentStrictSendNotAuthorized', 'pathPaymentStrictSendLineFull'], modern: 'Malformed' },
    { switchValues: ['pathPaymentStrictSendNoIssuer'], modern: 'NoIssuer', arm: 'noIssuer', convert: unionConverter(_Asset) },
    { switchValues: ['pathPaymentStrictSendTooFewOffers', 'pathPaymentStrictSendOfferCrossSelf', 'pathPaymentStrictSendUnderDestmin'], modern: 'TooFewOffers' },
  ],
});
export const PathPaymentStrictSendResult = _PathPaymentStrictSendResult as unknown as {
  pathPaymentStrictSendSuccess(value: PathPaymentStrictSendResultSuccess): PathPaymentStrictSendResult;
  pathPaymentStrictSendMalformed(): PathPaymentStrictSendResult;
  pathPaymentStrictSendUnderfunded(): PathPaymentStrictSendResult;
  pathPaymentStrictSendSrcNoTrust(): PathPaymentStrictSendResult;
  pathPaymentStrictSendSrcNotAuthorized(): PathPaymentStrictSendResult;
  pathPaymentStrictSendNoDestination(): PathPaymentStrictSendResult;
  pathPaymentStrictSendNoTrust(): PathPaymentStrictSendResult;
  pathPaymentStrictSendNotAuthorized(): PathPaymentStrictSendResult;
  pathPaymentStrictSendLineFull(): PathPaymentStrictSendResult;
  pathPaymentStrictSendNoIssuer(value: Asset): PathPaymentStrictSendResult;
  pathPaymentStrictSendTooFewOffers(): PathPaymentStrictSendResult;
  pathPaymentStrictSendOfferCrossSelf(): PathPaymentStrictSendResult;
  pathPaymentStrictSendUnderDestmin(): PathPaymentStrictSendResult;
  read(io: Buffer): PathPaymentStrictSendResult;
  write(value: PathPaymentStrictSendResult, io: Buffer): void;
  isValid(value: PathPaymentStrictSendResult): boolean;
  toXDR(value: PathPaymentStrictSendResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PathPaymentStrictSendResult;
  fromXDR(input: string, format: 'hex' | 'base64'): PathPaymentStrictSendResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface CreateClaimableBalanceResultCode {
  readonly name: 'createClaimableBalanceSuccess' | 'createClaimableBalanceMalformed' | 'createClaimableBalanceLowReserve' | 'createClaimableBalanceNoTrust' | 'createClaimableBalanceNotAuthorized' | 'createClaimableBalanceUnderfunded';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5;
}
const _CreateClaimableBalanceResultCode = createCompatEnum({
  codec: modern.CreateClaimableBalanceResultCode,
  members: [
    { compat: 'createClaimableBalanceSuccess', modern: 'Success', value: 0 },
    { compat: 'createClaimableBalanceMalformed', modern: 'Malformed', value: -1 },
    { compat: 'createClaimableBalanceLowReserve', modern: 'LowReserve', value: -2 },
    { compat: 'createClaimableBalanceNoTrust', modern: 'NoTrust', value: -3 },
    { compat: 'createClaimableBalanceNotAuthorized', modern: 'NotAuthorized', value: -4 },
    { compat: 'createClaimableBalanceUnderfunded', modern: 'Underfunded', value: -5 },
  ],
});
export const CreateClaimableBalanceResultCode = _CreateClaimableBalanceResultCode as unknown as {
  createClaimableBalanceSuccess(): CreateClaimableBalanceResultCode;
  createClaimableBalanceMalformed(): CreateClaimableBalanceResultCode;
  createClaimableBalanceLowReserve(): CreateClaimableBalanceResultCode;
  createClaimableBalanceNoTrust(): CreateClaimableBalanceResultCode;
  createClaimableBalanceNotAuthorized(): CreateClaimableBalanceResultCode;
  createClaimableBalanceUnderfunded(): CreateClaimableBalanceResultCode;
};

export interface CreateClaimableBalanceResult {
  switch(): CreateClaimableBalanceResultCode;
  balanceId(value?: ClaimableBalanceId): ClaimableBalanceId;
  value(): ClaimableBalanceId | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _CreateClaimableBalanceResult = createCompatUnion({
  codec: modern.CreateClaimableBalanceResult,
  switchEnum: _CreateClaimableBalanceResultCode,
  arms: [
    { switchValues: ['createClaimableBalanceSuccess'], modern: 'Success', arm: 'balanceId', convert: unionConverter(_ClaimableBalanceId) },
    { switchValues: ['createClaimableBalanceMalformed', 'createClaimableBalanceLowReserve', 'createClaimableBalanceNoTrust', 'createClaimableBalanceNotAuthorized', 'createClaimableBalanceUnderfunded'], modern: 'Malformed' },
  ],
});
export const CreateClaimableBalanceResult = _CreateClaimableBalanceResult as unknown as {
  createClaimableBalanceSuccess(value: ClaimableBalanceId): CreateClaimableBalanceResult;
  createClaimableBalanceMalformed(): CreateClaimableBalanceResult;
  createClaimableBalanceLowReserve(): CreateClaimableBalanceResult;
  createClaimableBalanceNoTrust(): CreateClaimableBalanceResult;
  createClaimableBalanceNotAuthorized(): CreateClaimableBalanceResult;
  createClaimableBalanceUnderfunded(): CreateClaimableBalanceResult;
  read(io: Buffer): CreateClaimableBalanceResult;
  write(value: CreateClaimableBalanceResult, io: Buffer): void;
  isValid(value: CreateClaimableBalanceResult): boolean;
  toXDR(value: CreateClaimableBalanceResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): CreateClaimableBalanceResult;
  fromXDR(input: string, format: 'hex' | 'base64'): CreateClaimableBalanceResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimClaimableBalanceResultCode {
  readonly name: 'claimClaimableBalanceSuccess' | 'claimClaimableBalanceDoesNotExist' | 'claimClaimableBalanceCannotClaim' | 'claimClaimableBalanceLineFull' | 'claimClaimableBalanceNoTrust' | 'claimClaimableBalanceNotAuthorized';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5;
}
const _ClaimClaimableBalanceResultCode = createCompatEnum({
  codec: modern.ClaimClaimableBalanceResultCode,
  members: [
    { compat: 'claimClaimableBalanceSuccess', modern: 'Success', value: 0 },
    { compat: 'claimClaimableBalanceDoesNotExist', modern: 'DoesNotExist', value: -1 },
    { compat: 'claimClaimableBalanceCannotClaim', modern: 'CannotClaim', value: -2 },
    { compat: 'claimClaimableBalanceLineFull', modern: 'LineFull', value: -3 },
    { compat: 'claimClaimableBalanceNoTrust', modern: 'NoTrust', value: -4 },
    { compat: 'claimClaimableBalanceNotAuthorized', modern: 'NotAuthorized', value: -5 },
  ],
});
export const ClaimClaimableBalanceResultCode = _ClaimClaimableBalanceResultCode as unknown as {
  claimClaimableBalanceSuccess(): ClaimClaimableBalanceResultCode;
  claimClaimableBalanceDoesNotExist(): ClaimClaimableBalanceResultCode;
  claimClaimableBalanceCannotClaim(): ClaimClaimableBalanceResultCode;
  claimClaimableBalanceLineFull(): ClaimClaimableBalanceResultCode;
  claimClaimableBalanceNoTrust(): ClaimClaimableBalanceResultCode;
  claimClaimableBalanceNotAuthorized(): ClaimClaimableBalanceResultCode;
};

export interface ClaimClaimableBalanceResult {
  switch(): ClaimClaimableBalanceResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimClaimableBalanceResult = createCompatUnion({
  codec: modern.ClaimClaimableBalanceResult,
  switchEnum: _ClaimClaimableBalanceResultCode,
  arms: [
    { switchValues: ['claimClaimableBalanceSuccess'], modern: 'Success' },
    { switchValues: ['claimClaimableBalanceDoesNotExist', 'claimClaimableBalanceCannotClaim', 'claimClaimableBalanceLineFull', 'claimClaimableBalanceNoTrust', 'claimClaimableBalanceNotAuthorized'], modern: 'DoesNotExist' },
  ],
});
export const ClaimClaimableBalanceResult = _ClaimClaimableBalanceResult as unknown as {
  claimClaimableBalanceSuccess(): ClaimClaimableBalanceResult;
  claimClaimableBalanceDoesNotExist(): ClaimClaimableBalanceResult;
  claimClaimableBalanceCannotClaim(): ClaimClaimableBalanceResult;
  claimClaimableBalanceLineFull(): ClaimClaimableBalanceResult;
  claimClaimableBalanceNoTrust(): ClaimClaimableBalanceResult;
  claimClaimableBalanceNotAuthorized(): ClaimClaimableBalanceResult;
  read(io: Buffer): ClaimClaimableBalanceResult;
  write(value: ClaimClaimableBalanceResult, io: Buffer): void;
  isValid(value: ClaimClaimableBalanceResult): boolean;
  toXDR(value: ClaimClaimableBalanceResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimClaimableBalanceResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimClaimableBalanceResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface BeginSponsoringFutureReservesResultCode {
  readonly name: 'beginSponsoringFutureReservesSuccess' | 'beginSponsoringFutureReservesMalformed' | 'beginSponsoringFutureReservesAlreadySponsored' | 'beginSponsoringFutureReservesRecursive';
  readonly value: 0 | -1 | -2 | -3;
}
const _BeginSponsoringFutureReservesResultCode = createCompatEnum({
  codec: modern.BeginSponsoringFutureReservesResultCode,
  members: [
    { compat: 'beginSponsoringFutureReservesSuccess', modern: 'Success', value: 0 },
    { compat: 'beginSponsoringFutureReservesMalformed', modern: 'Malformed', value: -1 },
    { compat: 'beginSponsoringFutureReservesAlreadySponsored', modern: 'AlreadySponsored', value: -2 },
    { compat: 'beginSponsoringFutureReservesRecursive', modern: 'Recursive', value: -3 },
  ],
});
export const BeginSponsoringFutureReservesResultCode = _BeginSponsoringFutureReservesResultCode as unknown as {
  beginSponsoringFutureReservesSuccess(): BeginSponsoringFutureReservesResultCode;
  beginSponsoringFutureReservesMalformed(): BeginSponsoringFutureReservesResultCode;
  beginSponsoringFutureReservesAlreadySponsored(): BeginSponsoringFutureReservesResultCode;
  beginSponsoringFutureReservesRecursive(): BeginSponsoringFutureReservesResultCode;
};

export interface BeginSponsoringFutureReservesResult {
  switch(): BeginSponsoringFutureReservesResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _BeginSponsoringFutureReservesResult = createCompatUnion({
  codec: modern.BeginSponsoringFutureReservesResult,
  switchEnum: _BeginSponsoringFutureReservesResultCode,
  arms: [
    { switchValues: ['beginSponsoringFutureReservesSuccess'], modern: 'Success' },
    { switchValues: ['beginSponsoringFutureReservesMalformed', 'beginSponsoringFutureReservesAlreadySponsored', 'beginSponsoringFutureReservesRecursive'], modern: 'Malformed' },
  ],
});
export const BeginSponsoringFutureReservesResult = _BeginSponsoringFutureReservesResult as unknown as {
  beginSponsoringFutureReservesSuccess(): BeginSponsoringFutureReservesResult;
  beginSponsoringFutureReservesMalformed(): BeginSponsoringFutureReservesResult;
  beginSponsoringFutureReservesAlreadySponsored(): BeginSponsoringFutureReservesResult;
  beginSponsoringFutureReservesRecursive(): BeginSponsoringFutureReservesResult;
  read(io: Buffer): BeginSponsoringFutureReservesResult;
  write(value: BeginSponsoringFutureReservesResult, io: Buffer): void;
  isValid(value: BeginSponsoringFutureReservesResult): boolean;
  toXDR(value: BeginSponsoringFutureReservesResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): BeginSponsoringFutureReservesResult;
  fromXDR(input: string, format: 'hex' | 'base64'): BeginSponsoringFutureReservesResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface EndSponsoringFutureReservesResultCode {
  readonly name: 'endSponsoringFutureReservesSuccess' | 'endSponsoringFutureReservesNotSponsored';
  readonly value: 0 | -1;
}
const _EndSponsoringFutureReservesResultCode = createCompatEnum({
  codec: modern.EndSponsoringFutureReservesResultCode,
  members: [
    { compat: 'endSponsoringFutureReservesSuccess', modern: 'Success', value: 0 },
    { compat: 'endSponsoringFutureReservesNotSponsored', modern: 'NotSponsored', value: -1 },
  ],
});
export const EndSponsoringFutureReservesResultCode = _EndSponsoringFutureReservesResultCode as unknown as {
  endSponsoringFutureReservesSuccess(): EndSponsoringFutureReservesResultCode;
  endSponsoringFutureReservesNotSponsored(): EndSponsoringFutureReservesResultCode;
};

export interface EndSponsoringFutureReservesResult {
  switch(): EndSponsoringFutureReservesResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _EndSponsoringFutureReservesResult = createCompatUnion({
  codec: modern.EndSponsoringFutureReservesResult,
  switchEnum: _EndSponsoringFutureReservesResultCode,
  arms: [
    { switchValues: ['endSponsoringFutureReservesSuccess'], modern: 'Success' },
    { switchValues: ['endSponsoringFutureReservesNotSponsored'], modern: 'NotSponsored' },
  ],
});
export const EndSponsoringFutureReservesResult = _EndSponsoringFutureReservesResult as unknown as {
  endSponsoringFutureReservesSuccess(): EndSponsoringFutureReservesResult;
  endSponsoringFutureReservesNotSponsored(): EndSponsoringFutureReservesResult;
  read(io: Buffer): EndSponsoringFutureReservesResult;
  write(value: EndSponsoringFutureReservesResult, io: Buffer): void;
  isValid(value: EndSponsoringFutureReservesResult): boolean;
  toXDR(value: EndSponsoringFutureReservesResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): EndSponsoringFutureReservesResult;
  fromXDR(input: string, format: 'hex' | 'base64'): EndSponsoringFutureReservesResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface RevokeSponsorshipResultCode {
  readonly name: 'revokeSponsorshipSuccess' | 'revokeSponsorshipDoesNotExist' | 'revokeSponsorshipNotSponsor' | 'revokeSponsorshipLowReserve' | 'revokeSponsorshipOnlyTransferable' | 'revokeSponsorshipMalformed';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5;
}
const _RevokeSponsorshipResultCode = createCompatEnum({
  codec: modern.RevokeSponsorshipResultCode,
  members: [
    { compat: 'revokeSponsorshipSuccess', modern: 'Success', value: 0 },
    { compat: 'revokeSponsorshipDoesNotExist', modern: 'DoesNotExist', value: -1 },
    { compat: 'revokeSponsorshipNotSponsor', modern: 'NotSponsor', value: -2 },
    { compat: 'revokeSponsorshipLowReserve', modern: 'LowReserve', value: -3 },
    { compat: 'revokeSponsorshipOnlyTransferable', modern: 'OnlyTransferable', value: -4 },
    { compat: 'revokeSponsorshipMalformed', modern: 'Malformed', value: -5 },
  ],
});
export const RevokeSponsorshipResultCode = _RevokeSponsorshipResultCode as unknown as {
  revokeSponsorshipSuccess(): RevokeSponsorshipResultCode;
  revokeSponsorshipDoesNotExist(): RevokeSponsorshipResultCode;
  revokeSponsorshipNotSponsor(): RevokeSponsorshipResultCode;
  revokeSponsorshipLowReserve(): RevokeSponsorshipResultCode;
  revokeSponsorshipOnlyTransferable(): RevokeSponsorshipResultCode;
  revokeSponsorshipMalformed(): RevokeSponsorshipResultCode;
};

export interface RevokeSponsorshipResult {
  switch(): RevokeSponsorshipResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _RevokeSponsorshipResult = createCompatUnion({
  codec: modern.RevokeSponsorshipResult,
  switchEnum: _RevokeSponsorshipResultCode,
  arms: [
    { switchValues: ['revokeSponsorshipSuccess'], modern: 'Success' },
    { switchValues: ['revokeSponsorshipDoesNotExist', 'revokeSponsorshipNotSponsor', 'revokeSponsorshipLowReserve', 'revokeSponsorshipOnlyTransferable', 'revokeSponsorshipMalformed'], modern: 'DoesNotExist' },
  ],
});
export const RevokeSponsorshipResult = _RevokeSponsorshipResult as unknown as {
  revokeSponsorshipSuccess(): RevokeSponsorshipResult;
  revokeSponsorshipDoesNotExist(): RevokeSponsorshipResult;
  revokeSponsorshipNotSponsor(): RevokeSponsorshipResult;
  revokeSponsorshipLowReserve(): RevokeSponsorshipResult;
  revokeSponsorshipOnlyTransferable(): RevokeSponsorshipResult;
  revokeSponsorshipMalformed(): RevokeSponsorshipResult;
  read(io: Buffer): RevokeSponsorshipResult;
  write(value: RevokeSponsorshipResult, io: Buffer): void;
  isValid(value: RevokeSponsorshipResult): boolean;
  toXDR(value: RevokeSponsorshipResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): RevokeSponsorshipResult;
  fromXDR(input: string, format: 'hex' | 'base64'): RevokeSponsorshipResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClawbackResultCode {
  readonly name: 'clawbackSuccess' | 'clawbackMalformed' | 'clawbackNotClawbackEnabled' | 'clawbackNoTrust' | 'clawbackUnderfunded';
  readonly value: 0 | -1 | -2 | -3 | -4;
}
const _ClawbackResultCode = createCompatEnum({
  codec: modern.ClawbackResultCode,
  members: [
    { compat: 'clawbackSuccess', modern: 'Success', value: 0 },
    { compat: 'clawbackMalformed', modern: 'Malformed', value: -1 },
    { compat: 'clawbackNotClawbackEnabled', modern: 'NotClawbackEnabled', value: -2 },
    { compat: 'clawbackNoTrust', modern: 'NoTrust', value: -3 },
    { compat: 'clawbackUnderfunded', modern: 'Underfunded', value: -4 },
  ],
});
export const ClawbackResultCode = _ClawbackResultCode as unknown as {
  clawbackSuccess(): ClawbackResultCode;
  clawbackMalformed(): ClawbackResultCode;
  clawbackNotClawbackEnabled(): ClawbackResultCode;
  clawbackNoTrust(): ClawbackResultCode;
  clawbackUnderfunded(): ClawbackResultCode;
};

export interface ClawbackResult {
  switch(): ClawbackResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClawbackResult = createCompatUnion({
  codec: modern.ClawbackResult,
  switchEnum: _ClawbackResultCode,
  arms: [
    { switchValues: ['clawbackSuccess'], modern: 'Success' },
    { switchValues: ['clawbackMalformed', 'clawbackNotClawbackEnabled', 'clawbackNoTrust', 'clawbackUnderfunded'], modern: 'Malformed' },
  ],
});
export const ClawbackResult = _ClawbackResult as unknown as {
  clawbackSuccess(): ClawbackResult;
  clawbackMalformed(): ClawbackResult;
  clawbackNotClawbackEnabled(): ClawbackResult;
  clawbackNoTrust(): ClawbackResult;
  clawbackUnderfunded(): ClawbackResult;
  read(io: Buffer): ClawbackResult;
  write(value: ClawbackResult, io: Buffer): void;
  isValid(value: ClawbackResult): boolean;
  toXDR(value: ClawbackResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClawbackResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ClawbackResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClawbackClaimableBalanceResultCode {
  readonly name: 'clawbackClaimableBalanceSuccess' | 'clawbackClaimableBalanceDoesNotExist' | 'clawbackClaimableBalanceNotIssuer' | 'clawbackClaimableBalanceNotClawbackEnabled';
  readonly value: 0 | -1 | -2 | -3;
}
const _ClawbackClaimableBalanceResultCode = createCompatEnum({
  codec: modern.ClawbackClaimableBalanceResultCode,
  members: [
    { compat: 'clawbackClaimableBalanceSuccess', modern: 'Success', value: 0 },
    { compat: 'clawbackClaimableBalanceDoesNotExist', modern: 'DoesNotExist', value: -1 },
    { compat: 'clawbackClaimableBalanceNotIssuer', modern: 'NotIssuer', value: -2 },
    { compat: 'clawbackClaimableBalanceNotClawbackEnabled', modern: 'NotClawbackEnabled', value: -3 },
  ],
});
export const ClawbackClaimableBalanceResultCode = _ClawbackClaimableBalanceResultCode as unknown as {
  clawbackClaimableBalanceSuccess(): ClawbackClaimableBalanceResultCode;
  clawbackClaimableBalanceDoesNotExist(): ClawbackClaimableBalanceResultCode;
  clawbackClaimableBalanceNotIssuer(): ClawbackClaimableBalanceResultCode;
  clawbackClaimableBalanceNotClawbackEnabled(): ClawbackClaimableBalanceResultCode;
};

export interface ClawbackClaimableBalanceResult {
  switch(): ClawbackClaimableBalanceResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClawbackClaimableBalanceResult = createCompatUnion({
  codec: modern.ClawbackClaimableBalanceResult,
  switchEnum: _ClawbackClaimableBalanceResultCode,
  arms: [
    { switchValues: ['clawbackClaimableBalanceSuccess'], modern: 'Success' },
    { switchValues: ['clawbackClaimableBalanceDoesNotExist', 'clawbackClaimableBalanceNotIssuer', 'clawbackClaimableBalanceNotClawbackEnabled'], modern: 'DoesNotExist' },
  ],
});
export const ClawbackClaimableBalanceResult = _ClawbackClaimableBalanceResult as unknown as {
  clawbackClaimableBalanceSuccess(): ClawbackClaimableBalanceResult;
  clawbackClaimableBalanceDoesNotExist(): ClawbackClaimableBalanceResult;
  clawbackClaimableBalanceNotIssuer(): ClawbackClaimableBalanceResult;
  clawbackClaimableBalanceNotClawbackEnabled(): ClawbackClaimableBalanceResult;
  read(io: Buffer): ClawbackClaimableBalanceResult;
  write(value: ClawbackClaimableBalanceResult, io: Buffer): void;
  isValid(value: ClawbackClaimableBalanceResult): boolean;
  toXDR(value: ClawbackClaimableBalanceResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClawbackClaimableBalanceResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ClawbackClaimableBalanceResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SetTrustLineFlagsResultCode {
  readonly name: 'setTrustLineFlagsSuccess' | 'setTrustLineFlagsMalformed' | 'setTrustLineFlagsNoTrustLine' | 'setTrustLineFlagsCantRevoke' | 'setTrustLineFlagsInvalidState' | 'setTrustLineFlagsLowReserve';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5;
}
const _SetTrustLineFlagsResultCode = createCompatEnum({
  codec: modern.SetTrustLineFlagsResultCode,
  members: [
    { compat: 'setTrustLineFlagsSuccess', modern: 'Success', value: 0 },
    { compat: 'setTrustLineFlagsMalformed', modern: 'Malformed', value: -1 },
    { compat: 'setTrustLineFlagsNoTrustLine', modern: 'NoTrustLine', value: -2 },
    { compat: 'setTrustLineFlagsCantRevoke', modern: 'CantRevoke', value: -3 },
    { compat: 'setTrustLineFlagsInvalidState', modern: 'InvalidState', value: -4 },
    { compat: 'setTrustLineFlagsLowReserve', modern: 'LowReserve', value: -5 },
  ],
});
export const SetTrustLineFlagsResultCode = _SetTrustLineFlagsResultCode as unknown as {
  setTrustLineFlagsSuccess(): SetTrustLineFlagsResultCode;
  setTrustLineFlagsMalformed(): SetTrustLineFlagsResultCode;
  setTrustLineFlagsNoTrustLine(): SetTrustLineFlagsResultCode;
  setTrustLineFlagsCantRevoke(): SetTrustLineFlagsResultCode;
  setTrustLineFlagsInvalidState(): SetTrustLineFlagsResultCode;
  setTrustLineFlagsLowReserve(): SetTrustLineFlagsResultCode;
};

export interface SetTrustLineFlagsResult {
  switch(): SetTrustLineFlagsResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SetTrustLineFlagsResult = createCompatUnion({
  codec: modern.SetTrustLineFlagsResult,
  switchEnum: _SetTrustLineFlagsResultCode,
  arms: [
    { switchValues: ['setTrustLineFlagsSuccess'], modern: 'Success' },
    { switchValues: ['setTrustLineFlagsMalformed', 'setTrustLineFlagsNoTrustLine', 'setTrustLineFlagsCantRevoke', 'setTrustLineFlagsInvalidState', 'setTrustLineFlagsLowReserve'], modern: 'Malformed' },
  ],
});
export const SetTrustLineFlagsResult = _SetTrustLineFlagsResult as unknown as {
  setTrustLineFlagsSuccess(): SetTrustLineFlagsResult;
  setTrustLineFlagsMalformed(): SetTrustLineFlagsResult;
  setTrustLineFlagsNoTrustLine(): SetTrustLineFlagsResult;
  setTrustLineFlagsCantRevoke(): SetTrustLineFlagsResult;
  setTrustLineFlagsInvalidState(): SetTrustLineFlagsResult;
  setTrustLineFlagsLowReserve(): SetTrustLineFlagsResult;
  read(io: Buffer): SetTrustLineFlagsResult;
  write(value: SetTrustLineFlagsResult, io: Buffer): void;
  isValid(value: SetTrustLineFlagsResult): boolean;
  toXDR(value: SetTrustLineFlagsResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SetTrustLineFlagsResult;
  fromXDR(input: string, format: 'hex' | 'base64'): SetTrustLineFlagsResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolDepositResultCode {
  readonly name: 'liquidityPoolDepositSuccess' | 'liquidityPoolDepositMalformed' | 'liquidityPoolDepositNoTrust' | 'liquidityPoolDepositNotAuthorized' | 'liquidityPoolDepositUnderfunded' | 'liquidityPoolDepositLineFull' | 'liquidityPoolDepositBadPrice' | 'liquidityPoolDepositPoolFull';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7;
}
const _LiquidityPoolDepositResultCode = createCompatEnum({
  codec: modern.LiquidityPoolDepositResultCode,
  members: [
    { compat: 'liquidityPoolDepositSuccess', modern: 'Success', value: 0 },
    { compat: 'liquidityPoolDepositMalformed', modern: 'Malformed', value: -1 },
    { compat: 'liquidityPoolDepositNoTrust', modern: 'NoTrust', value: -2 },
    { compat: 'liquidityPoolDepositNotAuthorized', modern: 'NotAuthorized', value: -3 },
    { compat: 'liquidityPoolDepositUnderfunded', modern: 'Underfunded', value: -4 },
    { compat: 'liquidityPoolDepositLineFull', modern: 'LineFull', value: -5 },
    { compat: 'liquidityPoolDepositBadPrice', modern: 'BadPrice', value: -6 },
    { compat: 'liquidityPoolDepositPoolFull', modern: 'PoolFull', value: -7 },
  ],
});
export const LiquidityPoolDepositResultCode = _LiquidityPoolDepositResultCode as unknown as {
  liquidityPoolDepositSuccess(): LiquidityPoolDepositResultCode;
  liquidityPoolDepositMalformed(): LiquidityPoolDepositResultCode;
  liquidityPoolDepositNoTrust(): LiquidityPoolDepositResultCode;
  liquidityPoolDepositNotAuthorized(): LiquidityPoolDepositResultCode;
  liquidityPoolDepositUnderfunded(): LiquidityPoolDepositResultCode;
  liquidityPoolDepositLineFull(): LiquidityPoolDepositResultCode;
  liquidityPoolDepositBadPrice(): LiquidityPoolDepositResultCode;
  liquidityPoolDepositPoolFull(): LiquidityPoolDepositResultCode;
};

export interface LiquidityPoolDepositResult {
  switch(): LiquidityPoolDepositResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolDepositResult = createCompatUnion({
  codec: modern.LiquidityPoolDepositResult,
  switchEnum: _LiquidityPoolDepositResultCode,
  arms: [
    { switchValues: ['liquidityPoolDepositSuccess'], modern: 'Success' },
    { switchValues: ['liquidityPoolDepositMalformed', 'liquidityPoolDepositNoTrust', 'liquidityPoolDepositNotAuthorized', 'liquidityPoolDepositUnderfunded', 'liquidityPoolDepositLineFull', 'liquidityPoolDepositBadPrice', 'liquidityPoolDepositPoolFull'], modern: 'Malformed' },
  ],
});
export const LiquidityPoolDepositResult = _LiquidityPoolDepositResult as unknown as {
  liquidityPoolDepositSuccess(): LiquidityPoolDepositResult;
  liquidityPoolDepositMalformed(): LiquidityPoolDepositResult;
  liquidityPoolDepositNoTrust(): LiquidityPoolDepositResult;
  liquidityPoolDepositNotAuthorized(): LiquidityPoolDepositResult;
  liquidityPoolDepositUnderfunded(): LiquidityPoolDepositResult;
  liquidityPoolDepositLineFull(): LiquidityPoolDepositResult;
  liquidityPoolDepositBadPrice(): LiquidityPoolDepositResult;
  liquidityPoolDepositPoolFull(): LiquidityPoolDepositResult;
  read(io: Buffer): LiquidityPoolDepositResult;
  write(value: LiquidityPoolDepositResult, io: Buffer): void;
  isValid(value: LiquidityPoolDepositResult): boolean;
  toXDR(value: LiquidityPoolDepositResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolDepositResult;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolDepositResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolWithdrawResultCode {
  readonly name: 'liquidityPoolWithdrawSuccess' | 'liquidityPoolWithdrawMalformed' | 'liquidityPoolWithdrawNoTrust' | 'liquidityPoolWithdrawUnderfunded' | 'liquidityPoolWithdrawLineFull' | 'liquidityPoolWithdrawUnderMinimum';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5;
}
const _LiquidityPoolWithdrawResultCode = createCompatEnum({
  codec: modern.LiquidityPoolWithdrawResultCode,
  members: [
    { compat: 'liquidityPoolWithdrawSuccess', modern: 'Success', value: 0 },
    { compat: 'liquidityPoolWithdrawMalformed', modern: 'Malformed', value: -1 },
    { compat: 'liquidityPoolWithdrawNoTrust', modern: 'NoTrust', value: -2 },
    { compat: 'liquidityPoolWithdrawUnderfunded', modern: 'Underfunded', value: -3 },
    { compat: 'liquidityPoolWithdrawLineFull', modern: 'LineFull', value: -4 },
    { compat: 'liquidityPoolWithdrawUnderMinimum', modern: 'UnderMinimum', value: -5 },
  ],
});
export const LiquidityPoolWithdrawResultCode = _LiquidityPoolWithdrawResultCode as unknown as {
  liquidityPoolWithdrawSuccess(): LiquidityPoolWithdrawResultCode;
  liquidityPoolWithdrawMalformed(): LiquidityPoolWithdrawResultCode;
  liquidityPoolWithdrawNoTrust(): LiquidityPoolWithdrawResultCode;
  liquidityPoolWithdrawUnderfunded(): LiquidityPoolWithdrawResultCode;
  liquidityPoolWithdrawLineFull(): LiquidityPoolWithdrawResultCode;
  liquidityPoolWithdrawUnderMinimum(): LiquidityPoolWithdrawResultCode;
};

export interface LiquidityPoolWithdrawResult {
  switch(): LiquidityPoolWithdrawResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolWithdrawResult = createCompatUnion({
  codec: modern.LiquidityPoolWithdrawResult,
  switchEnum: _LiquidityPoolWithdrawResultCode,
  arms: [
    { switchValues: ['liquidityPoolWithdrawSuccess'], modern: 'Success' },
    { switchValues: ['liquidityPoolWithdrawMalformed', 'liquidityPoolWithdrawNoTrust', 'liquidityPoolWithdrawUnderfunded', 'liquidityPoolWithdrawLineFull', 'liquidityPoolWithdrawUnderMinimum'], modern: 'Malformed' },
  ],
});
export const LiquidityPoolWithdrawResult = _LiquidityPoolWithdrawResult as unknown as {
  liquidityPoolWithdrawSuccess(): LiquidityPoolWithdrawResult;
  liquidityPoolWithdrawMalformed(): LiquidityPoolWithdrawResult;
  liquidityPoolWithdrawNoTrust(): LiquidityPoolWithdrawResult;
  liquidityPoolWithdrawUnderfunded(): LiquidityPoolWithdrawResult;
  liquidityPoolWithdrawLineFull(): LiquidityPoolWithdrawResult;
  liquidityPoolWithdrawUnderMinimum(): LiquidityPoolWithdrawResult;
  read(io: Buffer): LiquidityPoolWithdrawResult;
  write(value: LiquidityPoolWithdrawResult, io: Buffer): void;
  isValid(value: LiquidityPoolWithdrawResult): boolean;
  toXDR(value: LiquidityPoolWithdrawResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolWithdrawResult;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolWithdrawResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InvokeHostFunctionResultCode {
  readonly name: 'invokeHostFunctionSuccess' | 'invokeHostFunctionMalformed' | 'invokeHostFunctionTrapped' | 'invokeHostFunctionResourceLimitExceeded' | 'invokeHostFunctionEntryArchived' | 'invokeHostFunctionInsufficientRefundableFee';
  readonly value: 0 | -1 | -2 | -3 | -4 | -5;
}
const _InvokeHostFunctionResultCode = createCompatEnum({
  codec: modern.InvokeHostFunctionResultCode,
  members: [
    { compat: 'invokeHostFunctionSuccess', modern: 'Success', value: 0 },
    { compat: 'invokeHostFunctionMalformed', modern: 'Malformed', value: -1 },
    { compat: 'invokeHostFunctionTrapped', modern: 'Trapped', value: -2 },
    { compat: 'invokeHostFunctionResourceLimitExceeded', modern: 'ResourceLimitExceeded', value: -3 },
    { compat: 'invokeHostFunctionEntryArchived', modern: 'EntryArchived', value: -4 },
    { compat: 'invokeHostFunctionInsufficientRefundableFee', modern: 'InsufficientRefundableFee', value: -5 },
  ],
});
export const InvokeHostFunctionResultCode = _InvokeHostFunctionResultCode as unknown as {
  invokeHostFunctionSuccess(): InvokeHostFunctionResultCode;
  invokeHostFunctionMalformed(): InvokeHostFunctionResultCode;
  invokeHostFunctionTrapped(): InvokeHostFunctionResultCode;
  invokeHostFunctionResourceLimitExceeded(): InvokeHostFunctionResultCode;
  invokeHostFunctionEntryArchived(): InvokeHostFunctionResultCode;
  invokeHostFunctionInsufficientRefundableFee(): InvokeHostFunctionResultCode;
};

export interface InvokeHostFunctionResult {
  switch(): InvokeHostFunctionResultCode;
  success(value?: Hash): Hash;
  value(): Hash | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InvokeHostFunctionResult = createCompatUnion({
  codec: modern.InvokeHostFunctionResult,
  switchEnum: _InvokeHostFunctionResultCode,
  arms: [
    { switchValues: ['invokeHostFunctionSuccess'], modern: 'Success', arm: 'success', convert: id },
    { switchValues: ['invokeHostFunctionMalformed', 'invokeHostFunctionTrapped', 'invokeHostFunctionResourceLimitExceeded', 'invokeHostFunctionEntryArchived', 'invokeHostFunctionInsufficientRefundableFee'], modern: 'Malformed' },
  ],
});
export const InvokeHostFunctionResult = _InvokeHostFunctionResult as unknown as {
  invokeHostFunctionSuccess(value: Hash): InvokeHostFunctionResult;
  invokeHostFunctionMalformed(): InvokeHostFunctionResult;
  invokeHostFunctionTrapped(): InvokeHostFunctionResult;
  invokeHostFunctionResourceLimitExceeded(): InvokeHostFunctionResult;
  invokeHostFunctionEntryArchived(): InvokeHostFunctionResult;
  invokeHostFunctionInsufficientRefundableFee(): InvokeHostFunctionResult;
  read(io: Buffer): InvokeHostFunctionResult;
  write(value: InvokeHostFunctionResult, io: Buffer): void;
  isValid(value: InvokeHostFunctionResult): boolean;
  toXDR(value: InvokeHostFunctionResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InvokeHostFunctionResult;
  fromXDR(input: string, format: 'hex' | 'base64'): InvokeHostFunctionResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ExtendFootprintTtlResultCode {
  readonly name: 'extendFootprintTtlSuccess' | 'extendFootprintTtlMalformed' | 'extendFootprintTtlResourceLimitExceeded' | 'extendFootprintTtlInsufficientRefundableFee';
  readonly value: 0 | -1 | -2 | -3;
}
const _ExtendFootprintTtlResultCode = createCompatEnum({
  codec: modern.ExtendFootprintTTLResultCode,
  members: [
    { compat: 'extendFootprintTtlSuccess', modern: 'Success', value: 0 },
    { compat: 'extendFootprintTtlMalformed', modern: 'Malformed', value: -1 },
    { compat: 'extendFootprintTtlResourceLimitExceeded', modern: 'ResourceLimitExceeded', value: -2 },
    { compat: 'extendFootprintTtlInsufficientRefundableFee', modern: 'InsufficientRefundableFee', value: -3 },
  ],
});
export const ExtendFootprintTtlResultCode = _ExtendFootprintTtlResultCode as unknown as {
  extendFootprintTtlSuccess(): ExtendFootprintTtlResultCode;
  extendFootprintTtlMalformed(): ExtendFootprintTtlResultCode;
  extendFootprintTtlResourceLimitExceeded(): ExtendFootprintTtlResultCode;
  extendFootprintTtlInsufficientRefundableFee(): ExtendFootprintTtlResultCode;
};

export interface ExtendFootprintTtlResult {
  switch(): ExtendFootprintTtlResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ExtendFootprintTtlResult = createCompatUnion({
  codec: modern.ExtendFootprintTTLResult,
  switchEnum: _ExtendFootprintTtlResultCode,
  arms: [
    { switchValues: ['extendFootprintTtlSuccess'], modern: 'Success' },
    { switchValues: ['extendFootprintTtlMalformed', 'extendFootprintTtlResourceLimitExceeded', 'extendFootprintTtlInsufficientRefundableFee'], modern: 'Malformed' },
  ],
});
export const ExtendFootprintTtlResult = _ExtendFootprintTtlResult as unknown as {
  extendFootprintTtlSuccess(): ExtendFootprintTtlResult;
  extendFootprintTtlMalformed(): ExtendFootprintTtlResult;
  extendFootprintTtlResourceLimitExceeded(): ExtendFootprintTtlResult;
  extendFootprintTtlInsufficientRefundableFee(): ExtendFootprintTtlResult;
  read(io: Buffer): ExtendFootprintTtlResult;
  write(value: ExtendFootprintTtlResult, io: Buffer): void;
  isValid(value: ExtendFootprintTtlResult): boolean;
  toXDR(value: ExtendFootprintTtlResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ExtendFootprintTtlResult;
  fromXDR(input: string, format: 'hex' | 'base64'): ExtendFootprintTtlResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface RestoreFootprintResultCode {
  readonly name: 'restoreFootprintSuccess' | 'restoreFootprintMalformed' | 'restoreFootprintResourceLimitExceeded' | 'restoreFootprintInsufficientRefundableFee';
  readonly value: 0 | -1 | -2 | -3;
}
const _RestoreFootprintResultCode = createCompatEnum({
  codec: modern.RestoreFootprintResultCode,
  members: [
    { compat: 'restoreFootprintSuccess', modern: 'Success', value: 0 },
    { compat: 'restoreFootprintMalformed', modern: 'Malformed', value: -1 },
    { compat: 'restoreFootprintResourceLimitExceeded', modern: 'ResourceLimitExceeded', value: -2 },
    { compat: 'restoreFootprintInsufficientRefundableFee', modern: 'InsufficientRefundableFee', value: -3 },
  ],
});
export const RestoreFootprintResultCode = _RestoreFootprintResultCode as unknown as {
  restoreFootprintSuccess(): RestoreFootprintResultCode;
  restoreFootprintMalformed(): RestoreFootprintResultCode;
  restoreFootprintResourceLimitExceeded(): RestoreFootprintResultCode;
  restoreFootprintInsufficientRefundableFee(): RestoreFootprintResultCode;
};

export interface RestoreFootprintResult {
  switch(): RestoreFootprintResultCode;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _RestoreFootprintResult = createCompatUnion({
  codec: modern.RestoreFootprintResult,
  switchEnum: _RestoreFootprintResultCode,
  arms: [
    { switchValues: ['restoreFootprintSuccess'], modern: 'Success' },
    { switchValues: ['restoreFootprintMalformed', 'restoreFootprintResourceLimitExceeded', 'restoreFootprintInsufficientRefundableFee'], modern: 'Malformed' },
  ],
});
export const RestoreFootprintResult = _RestoreFootprintResult as unknown as {
  restoreFootprintSuccess(): RestoreFootprintResult;
  restoreFootprintMalformed(): RestoreFootprintResult;
  restoreFootprintResourceLimitExceeded(): RestoreFootprintResult;
  restoreFootprintInsufficientRefundableFee(): RestoreFootprintResult;
  read(io: Buffer): RestoreFootprintResult;
  write(value: RestoreFootprintResult, io: Buffer): void;
  isValid(value: RestoreFootprintResult): boolean;
  toXDR(value: RestoreFootprintResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): RestoreFootprintResult;
  fromXDR(input: string, format: 'hex' | 'base64'): RestoreFootprintResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface OperationResultTr {
  switch(): OperationType;
  createAccountResult(value?: CreateAccountResult): CreateAccountResult;
  paymentResult(value?: PaymentResult): PaymentResult;
  pathPaymentStrictReceiveResult(value?: PathPaymentStrictReceiveResult): PathPaymentStrictReceiveResult;
  manageSellOfferResult(value?: ManageSellOfferResult): ManageSellOfferResult;
  createPassiveSellOfferResult(value?: ManageSellOfferResult): ManageSellOfferResult;
  setOptionsResult(value?: SetOptionsResult): SetOptionsResult;
  changeTrustResult(value?: ChangeTrustResult): ChangeTrustResult;
  allowTrustResult(value?: AllowTrustResult): AllowTrustResult;
  accountMergeResult(value?: AccountMergeResult): AccountMergeResult;
  inflationResult(value?: InflationResult): InflationResult;
  manageDataResult(value?: ManageDataResult): ManageDataResult;
  bumpSeqResult(value?: BumpSequenceResult): BumpSequenceResult;
  manageBuyOfferResult(value?: ManageBuyOfferResult): ManageBuyOfferResult;
  pathPaymentStrictSendResult(value?: PathPaymentStrictSendResult): PathPaymentStrictSendResult;
  createClaimableBalanceResult(value?: CreateClaimableBalanceResult): CreateClaimableBalanceResult;
  claimClaimableBalanceResult(value?: ClaimClaimableBalanceResult): ClaimClaimableBalanceResult;
  beginSponsoringFutureReservesResult(value?: BeginSponsoringFutureReservesResult): BeginSponsoringFutureReservesResult;
  endSponsoringFutureReservesResult(value?: EndSponsoringFutureReservesResult): EndSponsoringFutureReservesResult;
  revokeSponsorshipResult(value?: RevokeSponsorshipResult): RevokeSponsorshipResult;
  clawbackResult(value?: ClawbackResult): ClawbackResult;
  clawbackClaimableBalanceResult(value?: ClawbackClaimableBalanceResult): ClawbackClaimableBalanceResult;
  setTrustLineFlagsResult(value?: SetTrustLineFlagsResult): SetTrustLineFlagsResult;
  liquidityPoolDepositResult(value?: LiquidityPoolDepositResult): LiquidityPoolDepositResult;
  liquidityPoolWithdrawResult(value?: LiquidityPoolWithdrawResult): LiquidityPoolWithdrawResult;
  invokeHostFunctionResult(value?: InvokeHostFunctionResult): InvokeHostFunctionResult;
  extendFootprintTtlResult(value?: ExtendFootprintTtlResult): ExtendFootprintTtlResult;
  restoreFootprintResult(value?: RestoreFootprintResult): RestoreFootprintResult;
  value(): CreateAccountResult | PaymentResult | PathPaymentStrictReceiveResult | ManageSellOfferResult | ManageSellOfferResult | SetOptionsResult | ChangeTrustResult | AllowTrustResult | AccountMergeResult | InflationResult | ManageDataResult | BumpSequenceResult | ManageBuyOfferResult | PathPaymentStrictSendResult | CreateClaimableBalanceResult | ClaimClaimableBalanceResult | BeginSponsoringFutureReservesResult | EndSponsoringFutureReservesResult | RevokeSponsorshipResult | ClawbackResult | ClawbackClaimableBalanceResult | SetTrustLineFlagsResult | LiquidityPoolDepositResult | LiquidityPoolWithdrawResult | InvokeHostFunctionResult | ExtendFootprintTtlResult | RestoreFootprintResult;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _OperationResultTr = createCompatUnion({
  codec: modern.OperationResultTr,
  switchEnum: _OperationType,
  arms: [
    { switchValues: ['createAccount'], modern: 'CreateAccount', arm: 'createAccountResult', convert: unionConverter(_CreateAccountResult) },
    { switchValues: ['payment'], modern: 'Payment', arm: 'paymentResult', convert: unionConverter(_PaymentResult) },
    { switchValues: ['pathPaymentStrictReceive'], modern: 'PathPaymentStrictReceive', arm: 'pathPaymentStrictReceiveResult', convert: unionConverter(_PathPaymentStrictReceiveResult) },
    { switchValues: ['manageSellOffer'], modern: 'ManageSellOffer', arm: 'manageSellOfferResult', convert: unionConverter(_ManageSellOfferResult) },
    { switchValues: ['createPassiveSellOffer'], modern: 'CreatePassiveSellOffer', arm: 'createPassiveSellOfferResult', convert: unionConverter(_ManageSellOfferResult) },
    { switchValues: ['setOptions'], modern: 'SetOptions', arm: 'setOptionsResult', convert: unionConverter(_SetOptionsResult) },
    { switchValues: ['changeTrust'], modern: 'ChangeTrust', arm: 'changeTrustResult', convert: unionConverter(_ChangeTrustResult) },
    { switchValues: ['allowTrust'], modern: 'AllowTrust', arm: 'allowTrustResult', convert: unionConverter(_AllowTrustResult) },
    { switchValues: ['accountMerge'], modern: 'AccountMerge', arm: 'accountMergeResult', convert: unionConverter(_AccountMergeResult) },
    { switchValues: ['inflation'], modern: 'Inflation', arm: 'inflationResult', convert: unionConverter(_InflationResult) },
    { switchValues: ['manageData'], modern: 'ManageData', arm: 'manageDataResult', convert: unionConverter(_ManageDataResult) },
    { switchValues: ['bumpSequence'], modern: 'BumpSequence', arm: 'bumpSeqResult', convert: unionConverter(_BumpSequenceResult) },
    { switchValues: ['manageBuyOffer'], modern: 'ManageBuyOffer', arm: 'manageBuyOfferResult', convert: unionConverter(_ManageBuyOfferResult) },
    { switchValues: ['pathPaymentStrictSend'], modern: 'PathPaymentStrictSend', arm: 'pathPaymentStrictSendResult', convert: unionConverter(_PathPaymentStrictSendResult) },
    { switchValues: ['createClaimableBalance'], modern: 'CreateClaimableBalance', arm: 'createClaimableBalanceResult', convert: unionConverter(_CreateClaimableBalanceResult) },
    { switchValues: ['claimClaimableBalance'], modern: 'ClaimClaimableBalance', arm: 'claimClaimableBalanceResult', convert: unionConverter(_ClaimClaimableBalanceResult) },
    { switchValues: ['beginSponsoringFutureReserves'], modern: 'BeginSponsoringFutureReserves', arm: 'beginSponsoringFutureReservesResult', convert: unionConverter(_BeginSponsoringFutureReservesResult) },
    { switchValues: ['endSponsoringFutureReserves'], modern: 'EndSponsoringFutureReserves', arm: 'endSponsoringFutureReservesResult', convert: unionConverter(_EndSponsoringFutureReservesResult) },
    { switchValues: ['revokeSponsorship'], modern: 'RevokeSponsorship', arm: 'revokeSponsorshipResult', convert: unionConverter(_RevokeSponsorshipResult) },
    { switchValues: ['clawback'], modern: 'Clawback', arm: 'clawbackResult', convert: unionConverter(_ClawbackResult) },
    { switchValues: ['clawbackClaimableBalance'], modern: 'ClawbackClaimableBalance', arm: 'clawbackClaimableBalanceResult', convert: unionConverter(_ClawbackClaimableBalanceResult) },
    { switchValues: ['setTrustLineFlags'], modern: 'SetTrustLineFlags', arm: 'setTrustLineFlagsResult', convert: unionConverter(_SetTrustLineFlagsResult) },
    { switchValues: ['liquidityPoolDeposit'], modern: 'LiquidityPoolDeposit', arm: 'liquidityPoolDepositResult', convert: unionConverter(_LiquidityPoolDepositResult) },
    { switchValues: ['liquidityPoolWithdraw'], modern: 'LiquidityPoolWithdraw', arm: 'liquidityPoolWithdrawResult', convert: unionConverter(_LiquidityPoolWithdrawResult) },
    { switchValues: ['invokeHostFunction'], modern: 'InvokeHostFunction', arm: 'invokeHostFunctionResult', convert: unionConverter(_InvokeHostFunctionResult) },
    { switchValues: ['extendFootprintTtl'], modern: 'ExtendFootprintTtl', arm: 'extendFootprintTtlResult', convert: unionConverter(_ExtendFootprintTtlResult) },
    { switchValues: ['restoreFootprint'], modern: 'RestoreFootprint', arm: 'restoreFootprintResult', convert: unionConverter(_RestoreFootprintResult) },
  ],
});
export const OperationResultTr = _OperationResultTr as unknown as {
  createAccount(value: CreateAccountResult): OperationResultTr;
  payment(value: PaymentResult): OperationResultTr;
  pathPaymentStrictReceive(value: PathPaymentStrictReceiveResult): OperationResultTr;
  manageSellOffer(value: ManageSellOfferResult): OperationResultTr;
  createPassiveSellOffer(value: ManageSellOfferResult): OperationResultTr;
  setOptions(value: SetOptionsResult): OperationResultTr;
  changeTrust(value: ChangeTrustResult): OperationResultTr;
  allowTrust(value: AllowTrustResult): OperationResultTr;
  accountMerge(value: AccountMergeResult): OperationResultTr;
  inflation(value: InflationResult): OperationResultTr;
  manageData(value: ManageDataResult): OperationResultTr;
  bumpSequence(value: BumpSequenceResult): OperationResultTr;
  manageBuyOffer(value: ManageBuyOfferResult): OperationResultTr;
  pathPaymentStrictSend(value: PathPaymentStrictSendResult): OperationResultTr;
  createClaimableBalance(value: CreateClaimableBalanceResult): OperationResultTr;
  claimClaimableBalance(value: ClaimClaimableBalanceResult): OperationResultTr;
  beginSponsoringFutureReserves(value: BeginSponsoringFutureReservesResult): OperationResultTr;
  endSponsoringFutureReserves(value: EndSponsoringFutureReservesResult): OperationResultTr;
  revokeSponsorship(value: RevokeSponsorshipResult): OperationResultTr;
  clawback(value: ClawbackResult): OperationResultTr;
  clawbackClaimableBalance(value: ClawbackClaimableBalanceResult): OperationResultTr;
  setTrustLineFlags(value: SetTrustLineFlagsResult): OperationResultTr;
  liquidityPoolDeposit(value: LiquidityPoolDepositResult): OperationResultTr;
  liquidityPoolWithdraw(value: LiquidityPoolWithdrawResult): OperationResultTr;
  invokeHostFunction(value: InvokeHostFunctionResult): OperationResultTr;
  extendFootprintTtl(value: ExtendFootprintTtlResult): OperationResultTr;
  restoreFootprint(value: RestoreFootprintResult): OperationResultTr;
  read(io: Buffer): OperationResultTr;
  write(value: OperationResultTr, io: Buffer): void;
  isValid(value: OperationResultTr): boolean;
  toXDR(value: OperationResultTr): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): OperationResultTr;
  fromXDR(input: string, format: 'hex' | 'base64'): OperationResultTr;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface OperationResult {
  switch(): OperationResultCode;
  tr(value?: OperationResultTr): OperationResultTr;
  value(): OperationResultTr | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _OperationResult = createCompatUnion({
  codec: modern.OperationResult,
  switchEnum: _OperationResultCode,
  arms: [
    { switchValues: ['opInner'], modern: 'OpINNER', arm: 'tr', convert: id },
    { switchValues: ['opBadAuth', 'opNoAccount', 'opNotSupported', 'opTooManySubentries', 'opExceededWorkLimit', 'opTooManySponsoring'], modern: 'OpBADAuth' },
  ],
});
export const OperationResult = _OperationResult as unknown as {
  opInner(value: OperationResultTr): OperationResult;
  opBadAuth(): OperationResult;
  opNoAccount(): OperationResult;
  opNotSupported(): OperationResult;
  opTooManySubentries(): OperationResult;
  opExceededWorkLimit(): OperationResult;
  opTooManySponsoring(): OperationResult;
  read(io: Buffer): OperationResult;
  write(value: OperationResult, io: Buffer): void;
  isValid(value: OperationResult): boolean;
  toXDR(value: OperationResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): OperationResult;
  fromXDR(input: string, format: 'hex' | 'base64'): OperationResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InnerTransactionResultResult {
  switch(): TransactionResultCode;
  results(value?: OperationResult[]): OperationResult[];
  value(): OperationResult[] | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InnerTransactionResultResult = createCompatUnion({
  codec: modern.InnerTransactionResultResult,
  switchEnum: _TransactionResultCode,
  arms: [
    { switchValues: ['txSuccess', 'txFailed'], modern: 'TxSUCCESS', arm: 'results', convert: arrayConverter(unionConverter(_OperationResult)) },
    { switchValues: ['txTooEarly', 'txTooLate', 'txMissingOperation', 'txBadSeq', 'txBadAuth', 'txInsufficientBalance', 'txNoAccount', 'txInsufficientFee', 'txBadAuthExtra', 'txInternalError', 'txNotSupported', 'txBadSponsorship', 'txBadMinSeqAgeOrGap', 'txMalformed', 'txSorobanInvalid'], modern: 'TxTOOEarly' },
  ],
});
export const InnerTransactionResultResult = _InnerTransactionResultResult as unknown as {
  txSuccess(value: OperationResult[]): InnerTransactionResultResult;
  txFailed(value: OperationResult[]): InnerTransactionResultResult;
  txTooEarly(): InnerTransactionResultResult;
  txTooLate(): InnerTransactionResultResult;
  txMissingOperation(): InnerTransactionResultResult;
  txBadSeq(): InnerTransactionResultResult;
  txBadAuth(): InnerTransactionResultResult;
  txInsufficientBalance(): InnerTransactionResultResult;
  txNoAccount(): InnerTransactionResultResult;
  txInsufficientFee(): InnerTransactionResultResult;
  txBadAuthExtra(): InnerTransactionResultResult;
  txInternalError(): InnerTransactionResultResult;
  txNotSupported(): InnerTransactionResultResult;
  txBadSponsorship(): InnerTransactionResultResult;
  txBadMinSeqAgeOrGap(): InnerTransactionResultResult;
  txMalformed(): InnerTransactionResultResult;
  txSorobanInvalid(): InnerTransactionResultResult;
  read(io: Buffer): InnerTransactionResultResult;
  write(value: InnerTransactionResultResult, io: Buffer): void;
  isValid(value: InnerTransactionResultResult): boolean;
  toXDR(value: InnerTransactionResultResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InnerTransactionResultResult;
  fromXDR(input: string, format: 'hex' | 'base64'): InnerTransactionResultResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InnerTransactionResultExt {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InnerTransactionResultExt = createCompatUnion({
  codec: modern.InnerTransactionResultExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const InnerTransactionResultExt = _InnerTransactionResultExt as unknown as {
  0(): InnerTransactionResultExt;
  read(io: Buffer): InnerTransactionResultExt;
  write(value: InnerTransactionResultExt, io: Buffer): void;
  isValid(value: InnerTransactionResultExt): boolean;
  toXDR(value: InnerTransactionResultExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InnerTransactionResultExt;
  fromXDR(input: string, format: 'hex' | 'base64'): InnerTransactionResultExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InnerTransactionResult {
  feeCharged(value?: Int64): Int64;
  result(value?: InnerTransactionResultResult): InnerTransactionResultResult;
  ext(value?: InnerTransactionResultExt): InnerTransactionResultExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InnerTransactionResult = createCompatStruct({
  codec: modern.InnerTransactionResult,
  fields: [
    { name: 'feeCharged', modernName: 'feeCharged', convert: int64Conv },
    { name: 'result', modernName: 'result', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const InnerTransactionResult = _InnerTransactionResult as unknown as {
  new(attributes: { feeCharged: Int64; result: InnerTransactionResultResult; ext: InnerTransactionResultExt }): InnerTransactionResult;
  read(io: Buffer): InnerTransactionResult;
  write(value: InnerTransactionResult, io: Buffer): void;
  isValid(value: InnerTransactionResult): boolean;
  toXDR(value: InnerTransactionResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InnerTransactionResult;
  fromXDR(input: string, format: 'hex' | 'base64'): InnerTransactionResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InnerTransactionResultPair {
  transactionHash(value?: Hash): Hash;
  result(value?: InnerTransactionResult): InnerTransactionResult;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InnerTransactionResultPair = createCompatStruct({
  codec: modern.InnerTransactionResultPair,
  fields: [
    { name: 'transactionHash', modernName: 'transactionHash', convert: id },
    { name: 'result', modernName: 'result', convert: structConverter(_InnerTransactionResult) },
  ],
});
export const InnerTransactionResultPair = _InnerTransactionResultPair as unknown as {
  new(attributes: { transactionHash: Hash; result: InnerTransactionResult }): InnerTransactionResultPair;
  read(io: Buffer): InnerTransactionResultPair;
  write(value: InnerTransactionResultPair, io: Buffer): void;
  isValid(value: InnerTransactionResultPair): boolean;
  toXDR(value: InnerTransactionResultPair): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InnerTransactionResultPair;
  fromXDR(input: string, format: 'hex' | 'base64'): InnerTransactionResultPair;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionResultResult {
  switch(): TransactionResultCode;
  innerResultPair(value?: InnerTransactionResultPair): InnerTransactionResultPair;
  results(value?: OperationResult[]): OperationResult[];
  value(): InnerTransactionResultPair | OperationResult[] | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionResultResult = createCompatUnion({
  codec: modern.TransactionResultResult,
  switchEnum: _TransactionResultCode,
  arms: [
    { switchValues: ['txFeeBumpInnerSuccess', 'txFeeBumpInnerFailed'], modern: 'TxFEEBumpInnerSuccess', arm: 'innerResultPair', convert: structConverter(_InnerTransactionResultPair) },
    { switchValues: ['txSuccess', 'txFailed'], modern: 'TxSUCCESS', arm: 'results', convert: arrayConverter(unionConverter(_OperationResult)) },
    { switchValues: ['txTooEarly', 'txTooLate', 'txMissingOperation', 'txBadSeq', 'txBadAuth', 'txInsufficientBalance', 'txNoAccount', 'txInsufficientFee', 'txBadAuthExtra', 'txInternalError', 'txNotSupported', 'txBadSponsorship', 'txBadMinSeqAgeOrGap', 'txMalformed', 'txSorobanInvalid'], modern: 'TxTOOEarly' },
  ],
});
export const TransactionResultResult = _TransactionResultResult as unknown as {
  txFeeBumpInnerSuccess(value: InnerTransactionResultPair): TransactionResultResult;
  txFeeBumpInnerFailed(value: InnerTransactionResultPair): TransactionResultResult;
  txSuccess(value: OperationResult[]): TransactionResultResult;
  txFailed(value: OperationResult[]): TransactionResultResult;
  txTooEarly(): TransactionResultResult;
  txTooLate(): TransactionResultResult;
  txMissingOperation(): TransactionResultResult;
  txBadSeq(): TransactionResultResult;
  txBadAuth(): TransactionResultResult;
  txInsufficientBalance(): TransactionResultResult;
  txNoAccount(): TransactionResultResult;
  txInsufficientFee(): TransactionResultResult;
  txBadAuthExtra(): TransactionResultResult;
  txInternalError(): TransactionResultResult;
  txNotSupported(): TransactionResultResult;
  txBadSponsorship(): TransactionResultResult;
  txBadMinSeqAgeOrGap(): TransactionResultResult;
  txMalformed(): TransactionResultResult;
  txSorobanInvalid(): TransactionResultResult;
  read(io: Buffer): TransactionResultResult;
  write(value: TransactionResultResult, io: Buffer): void;
  isValid(value: TransactionResultResult): boolean;
  toXDR(value: TransactionResultResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionResultResult;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionResultResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionResultExt {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionResultExt = createCompatUnion({
  codec: modern.TransactionResultExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const TransactionResultExt = _TransactionResultExt as unknown as {
  0(): TransactionResultExt;
  read(io: Buffer): TransactionResultExt;
  write(value: TransactionResultExt, io: Buffer): void;
  isValid(value: TransactionResultExt): boolean;
  toXDR(value: TransactionResultExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionResultExt;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionResultExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionResult {
  feeCharged(value?: Int64): Int64;
  result(value?: TransactionResultResult): TransactionResultResult;
  ext(value?: TransactionResultExt): TransactionResultExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionResult = createCompatStruct({
  codec: modern.TransactionResult,
  fields: [
    { name: 'feeCharged', modernName: 'feeCharged', convert: int64Conv },
    { name: 'result', modernName: 'result', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const TransactionResult = _TransactionResult as unknown as {
  new(attributes: { feeCharged: Int64; result: TransactionResultResult; ext: TransactionResultExt }): TransactionResult;
  read(io: Buffer): TransactionResult;
  write(value: TransactionResult, io: Buffer): void;
  isValid(value: TransactionResult): boolean;
  toXDR(value: TransactionResult): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionResult;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionResult;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionResultPair {
  transactionHash(value?: Hash): Hash;
  result(value?: TransactionResult): TransactionResult;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionResultPair = createCompatStruct({
  codec: modern.TransactionResultPair,
  fields: [
    { name: 'transactionHash', modernName: 'transactionHash', convert: id },
    { name: 'result', modernName: 'result', convert: structConverter(_TransactionResult) },
  ],
});
export const TransactionResultPair = _TransactionResultPair as unknown as {
  new(attributes: { transactionHash: Hash; result: TransactionResult }): TransactionResultPair;
  read(io: Buffer): TransactionResultPair;
  write(value: TransactionResultPair, io: Buffer): void;
  isValid(value: TransactionResultPair): boolean;
  toXDR(value: TransactionResultPair): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionResultPair;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionResultPair;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerEntryChangeType {
  readonly name: 'ledgerEntryCreated' | 'ledgerEntryUpdated' | 'ledgerEntryRemoved' | 'ledgerEntryState' | 'ledgerEntryRestored';
  readonly value: 0 | 1 | 2 | 3 | 4;
}
const _LedgerEntryChangeType = createCompatEnum({
  codec: modern.LedgerEntryChangeType,
  members: [
    { compat: 'ledgerEntryCreated', modern: 'Created', value: 0 },
    { compat: 'ledgerEntryUpdated', modern: 'Updated', value: 1 },
    { compat: 'ledgerEntryRemoved', modern: 'Removed', value: 2 },
    { compat: 'ledgerEntryState', modern: 'State', value: 3 },
    { compat: 'ledgerEntryRestored', modern: 'Restored', value: 4 },
  ],
});
export const LedgerEntryChangeType = _LedgerEntryChangeType as unknown as {
  ledgerEntryCreated(): LedgerEntryChangeType;
  ledgerEntryUpdated(): LedgerEntryChangeType;
  ledgerEntryRemoved(): LedgerEntryChangeType;
  ledgerEntryState(): LedgerEntryChangeType;
  ledgerEntryRestored(): LedgerEntryChangeType;
};

export type Thresholds = Buffer;
export const Thresholds = createCompatTypedef({ codec: modern.Thresholds, convert: id });

export const MAX_SIGNERS = 20;

export interface Liabilities {
  buying(value?: Int64): Int64;
  selling(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Liabilities = createCompatStruct({
  codec: modern.Liabilities,
  fields: [
    { name: 'buying', modernName: 'buying', convert: int64Conv },
    { name: 'selling', modernName: 'selling', convert: int64Conv },
  ],
});
export const Liabilities = _Liabilities as unknown as {
  new(attributes: { buying: Int64; selling: Int64 }): Liabilities;
  read(io: Buffer): Liabilities;
  write(value: Liabilities, io: Buffer): void;
  isValid(value: Liabilities): boolean;
  toXDR(value: Liabilities): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Liabilities;
  fromXDR(input: string, format: 'hex' | 'base64'): Liabilities;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type SponsorshipDescriptor = null | AccountId;
export const SponsorshipDescriptor = createCompatTypedef({ codec: modern.SponsorshipDescriptor, convert: optionConverter(unionConverter(_PublicKey)) });

export interface AccountEntryExtensionV3 {
  ext(value?: ExtensionPoint): ExtensionPoint;
  seqLedger(value?: Uint32): Uint32;
  seqTime(value?: TimePoint): TimePoint;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AccountEntryExtensionV3 = createCompatStruct({
  codec: modern.AccountEntryExtensionV3,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'seqLedger', modernName: 'seqLedger', convert: id },
    { name: 'seqTime', modernName: 'seqTime', convert: uint64Conv },
  ],
});
export const AccountEntryExtensionV3 = _AccountEntryExtensionV3 as unknown as {
  new(attributes: { ext: ExtensionPoint; seqLedger: Uint32; seqTime: TimePoint }): AccountEntryExtensionV3;
  read(io: Buffer): AccountEntryExtensionV3;
  write(value: AccountEntryExtensionV3, io: Buffer): void;
  isValid(value: AccountEntryExtensionV3): boolean;
  toXDR(value: AccountEntryExtensionV3): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AccountEntryExtensionV3;
  fromXDR(input: string, format: 'hex' | 'base64'): AccountEntryExtensionV3;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AccountEntryExtensionV2Ext {
  switch(): number;
  v3(value?: AccountEntryExtensionV3): AccountEntryExtensionV3;
  value(): AccountEntryExtensionV3 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AccountEntryExtensionV2Ext = createCompatUnion({
  codec: modern.AccountEntryExtensionV2Ext,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [3], modern: 3, arm: 'v3', convert: structConverter(_AccountEntryExtensionV3) },
  ],
});
export const AccountEntryExtensionV2Ext = _AccountEntryExtensionV2Ext as unknown as {
  0(): AccountEntryExtensionV2Ext;
  3(value: AccountEntryExtensionV3): AccountEntryExtensionV2Ext;
  read(io: Buffer): AccountEntryExtensionV2Ext;
  write(value: AccountEntryExtensionV2Ext, io: Buffer): void;
  isValid(value: AccountEntryExtensionV2Ext): boolean;
  toXDR(value: AccountEntryExtensionV2Ext): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AccountEntryExtensionV2Ext;
  fromXDR(input: string, format: 'hex' | 'base64'): AccountEntryExtensionV2Ext;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AccountEntryExtensionV2 {
  numSponsored(value?: Uint32): Uint32;
  numSponsoring(value?: Uint32): Uint32;
  signerSponsoringIDs(value?: SponsorshipDescriptor[]): SponsorshipDescriptor[];
  ext(value?: AccountEntryExtensionV2Ext): AccountEntryExtensionV2Ext;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AccountEntryExtensionV2 = createCompatStruct({
  codec: modern.AccountEntryExtensionV2,
  fields: [
    { name: 'numSponsored', modernName: 'numSponsored', convert: id },
    { name: 'numSponsoring', modernName: 'numSponsoring', convert: id },
    { name: 'signerSponsoringIDs', modernName: 'signerSponsoringIDs', convert: arrayConverter(optionConverter(unionConverter(_PublicKey))) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const AccountEntryExtensionV2 = _AccountEntryExtensionV2 as unknown as {
  new(attributes: { numSponsored: Uint32; numSponsoring: Uint32; signerSponsoringIDs: SponsorshipDescriptor[]; ext: AccountEntryExtensionV2Ext }): AccountEntryExtensionV2;
  read(io: Buffer): AccountEntryExtensionV2;
  write(value: AccountEntryExtensionV2, io: Buffer): void;
  isValid(value: AccountEntryExtensionV2): boolean;
  toXDR(value: AccountEntryExtensionV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AccountEntryExtensionV2;
  fromXDR(input: string, format: 'hex' | 'base64'): AccountEntryExtensionV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AccountEntryExtensionV1Ext {
  switch(): number;
  v2(value?: AccountEntryExtensionV2): AccountEntryExtensionV2;
  value(): AccountEntryExtensionV2 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AccountEntryExtensionV1Ext = createCompatUnion({
  codec: modern.AccountEntryExtensionV1Ext,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [2], modern: 2, arm: 'v2', convert: structConverter(_AccountEntryExtensionV2) },
  ],
});
export const AccountEntryExtensionV1Ext = _AccountEntryExtensionV1Ext as unknown as {
  0(): AccountEntryExtensionV1Ext;
  2(value: AccountEntryExtensionV2): AccountEntryExtensionV1Ext;
  read(io: Buffer): AccountEntryExtensionV1Ext;
  write(value: AccountEntryExtensionV1Ext, io: Buffer): void;
  isValid(value: AccountEntryExtensionV1Ext): boolean;
  toXDR(value: AccountEntryExtensionV1Ext): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AccountEntryExtensionV1Ext;
  fromXDR(input: string, format: 'hex' | 'base64'): AccountEntryExtensionV1Ext;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AccountEntryExtensionV1 {
  liabilities(value?: Liabilities): Liabilities;
  ext(value?: AccountEntryExtensionV1Ext): AccountEntryExtensionV1Ext;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AccountEntryExtensionV1 = createCompatStruct({
  codec: modern.AccountEntryExtensionV1,
  fields: [
    { name: 'liabilities', modernName: 'liabilities', convert: structConverter(_Liabilities) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const AccountEntryExtensionV1 = _AccountEntryExtensionV1 as unknown as {
  new(attributes: { liabilities: Liabilities; ext: AccountEntryExtensionV1Ext }): AccountEntryExtensionV1;
  read(io: Buffer): AccountEntryExtensionV1;
  write(value: AccountEntryExtensionV1, io: Buffer): void;
  isValid(value: AccountEntryExtensionV1): boolean;
  toXDR(value: AccountEntryExtensionV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AccountEntryExtensionV1;
  fromXDR(input: string, format: 'hex' | 'base64'): AccountEntryExtensionV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AccountEntryExt {
  switch(): number;
  v1(value?: AccountEntryExtensionV1): AccountEntryExtensionV1;
  value(): AccountEntryExtensionV1 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AccountEntryExt = createCompatUnion({
  codec: modern.AccountEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_AccountEntryExtensionV1) },
  ],
});
export const AccountEntryExt = _AccountEntryExt as unknown as {
  0(): AccountEntryExt;
  1(value: AccountEntryExtensionV1): AccountEntryExt;
  read(io: Buffer): AccountEntryExt;
  write(value: AccountEntryExt, io: Buffer): void;
  isValid(value: AccountEntryExt): boolean;
  toXDR(value: AccountEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AccountEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): AccountEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AccountEntry {
  accountId(value?: AccountId): AccountId;
  balance(value?: Int64): Int64;
  seqNum(value?: SequenceNumber): SequenceNumber;
  numSubEntries(value?: Uint32): Uint32;
  inflationDest(value?: null | AccountId): null | AccountId;
  flags(value?: Uint32): Uint32;
  homeDomain(value?: String32): String32;
  thresholds(value?: Thresholds): Thresholds;
  signers(value?: Signer[]): Signer[];
  ext(value?: AccountEntryExt): AccountEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AccountEntry = createCompatStruct({
  codec: modern.AccountEntry,
  fields: [
    { name: 'accountId', modernName: 'accountID', convert: unionConverter(_PublicKey) },
    { name: 'balance', modernName: 'balance', convert: int64Conv },
    { name: 'seqNum', modernName: 'seqNum', convert: int64Conv },
    { name: 'numSubEntries', modernName: 'numSubEntries', convert: id },
    { name: 'inflationDest', modernName: 'inflationDest', convert: optionConverter(unionConverter(_PublicKey)) },
    { name: 'flags', modernName: 'flags', convert: id },
    { name: 'homeDomain', modernName: 'homeDomain', convert: id },
    { name: 'thresholds', modernName: 'thresholds', convert: id },
    { name: 'signers', modernName: 'signers', convert: arrayConverter(structConverter(_Signer)) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const AccountEntry = _AccountEntry as unknown as {
  new(attributes: { accountId: AccountId; balance: Int64; seqNum: SequenceNumber; numSubEntries: Uint32; inflationDest: null | AccountId; flags: Uint32; homeDomain: String32; thresholds: Thresholds; signers: Signer[]; ext: AccountEntryExt }): AccountEntry;
  read(io: Buffer): AccountEntry;
  write(value: AccountEntry, io: Buffer): void;
  isValid(value: AccountEntry): boolean;
  toXDR(value: AccountEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AccountEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): AccountEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TrustLineEntryExtensionV2Ext {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TrustLineEntryExtensionV2Ext = createCompatUnion({
  codec: modern.TrustLineEntryExtensionV2Ext,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const TrustLineEntryExtensionV2Ext = _TrustLineEntryExtensionV2Ext as unknown as {
  0(): TrustLineEntryExtensionV2Ext;
  read(io: Buffer): TrustLineEntryExtensionV2Ext;
  write(value: TrustLineEntryExtensionV2Ext, io: Buffer): void;
  isValid(value: TrustLineEntryExtensionV2Ext): boolean;
  toXDR(value: TrustLineEntryExtensionV2Ext): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TrustLineEntryExtensionV2Ext;
  fromXDR(input: string, format: 'hex' | 'base64'): TrustLineEntryExtensionV2Ext;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TrustLineEntryExtensionV2 {
  liquidityPoolUseCount(value?: Int32): Int32;
  ext(value?: TrustLineEntryExtensionV2Ext): TrustLineEntryExtensionV2Ext;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TrustLineEntryExtensionV2 = createCompatStruct({
  codec: modern.TrustLineEntryExtensionV2,
  fields: [
    { name: 'liquidityPoolUseCount', modernName: 'liquidityPoolUseCount', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const TrustLineEntryExtensionV2 = _TrustLineEntryExtensionV2 as unknown as {
  new(attributes: { liquidityPoolUseCount: Int32; ext: TrustLineEntryExtensionV2Ext }): TrustLineEntryExtensionV2;
  read(io: Buffer): TrustLineEntryExtensionV2;
  write(value: TrustLineEntryExtensionV2, io: Buffer): void;
  isValid(value: TrustLineEntryExtensionV2): boolean;
  toXDR(value: TrustLineEntryExtensionV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TrustLineEntryExtensionV2;
  fromXDR(input: string, format: 'hex' | 'base64'): TrustLineEntryExtensionV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TrustLineEntryV1Ext {
  switch(): number;
  v2(value?: TrustLineEntryExtensionV2): TrustLineEntryExtensionV2;
  value(): TrustLineEntryExtensionV2 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TrustLineEntryV1Ext = createCompatUnion({
  codec: modern.TrustLineEntryV1Ext,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [2], modern: 2, arm: 'v2', convert: structConverter(_TrustLineEntryExtensionV2) },
  ],
});
export const TrustLineEntryV1Ext = _TrustLineEntryV1Ext as unknown as {
  0(): TrustLineEntryV1Ext;
  2(value: TrustLineEntryExtensionV2): TrustLineEntryV1Ext;
  read(io: Buffer): TrustLineEntryV1Ext;
  write(value: TrustLineEntryV1Ext, io: Buffer): void;
  isValid(value: TrustLineEntryV1Ext): boolean;
  toXDR(value: TrustLineEntryV1Ext): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TrustLineEntryV1Ext;
  fromXDR(input: string, format: 'hex' | 'base64'): TrustLineEntryV1Ext;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TrustLineEntryV1 {
  liabilities(value?: Liabilities): Liabilities;
  ext(value?: TrustLineEntryV1Ext): TrustLineEntryV1Ext;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TrustLineEntryV1 = createCompatStruct({
  codec: modern.TrustLineEntryV1,
  fields: [
    { name: 'liabilities', modernName: 'liabilities', convert: structConverter(_Liabilities) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const TrustLineEntryV1 = _TrustLineEntryV1 as unknown as {
  new(attributes: { liabilities: Liabilities; ext: TrustLineEntryV1Ext }): TrustLineEntryV1;
  read(io: Buffer): TrustLineEntryV1;
  write(value: TrustLineEntryV1, io: Buffer): void;
  isValid(value: TrustLineEntryV1): boolean;
  toXDR(value: TrustLineEntryV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TrustLineEntryV1;
  fromXDR(input: string, format: 'hex' | 'base64'): TrustLineEntryV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TrustLineEntryExt {
  switch(): number;
  v1(value?: TrustLineEntryV1): TrustLineEntryV1;
  value(): TrustLineEntryV1 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TrustLineEntryExt = createCompatUnion({
  codec: modern.TrustLineEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'v1', convert: id },
  ],
});
export const TrustLineEntryExt = _TrustLineEntryExt as unknown as {
  0(): TrustLineEntryExt;
  1(value: TrustLineEntryV1): TrustLineEntryExt;
  read(io: Buffer): TrustLineEntryExt;
  write(value: TrustLineEntryExt, io: Buffer): void;
  isValid(value: TrustLineEntryExt): boolean;
  toXDR(value: TrustLineEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TrustLineEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): TrustLineEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TrustLineEntry {
  accountId(value?: AccountId): AccountId;
  asset(value?: TrustLineAsset): TrustLineAsset;
  balance(value?: Int64): Int64;
  limit(value?: Int64): Int64;
  flags(value?: Uint32): Uint32;
  ext(value?: TrustLineEntryExt): TrustLineEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TrustLineEntry = createCompatStruct({
  codec: modern.TrustLineEntry,
  fields: [
    { name: 'accountId', modernName: 'accountID', convert: unionConverter(_PublicKey) },
    { name: 'asset', modernName: 'asset', convert: unionConverter(_TrustLineAsset) },
    { name: 'balance', modernName: 'balance', convert: int64Conv },
    { name: 'limit', modernName: 'limit', convert: int64Conv },
    { name: 'flags', modernName: 'flags', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const TrustLineEntry = _TrustLineEntry as unknown as {
  new(attributes: { accountId: AccountId; asset: TrustLineAsset; balance: Int64; limit: Int64; flags: Uint32; ext: TrustLineEntryExt }): TrustLineEntry;
  read(io: Buffer): TrustLineEntry;
  write(value: TrustLineEntry, io: Buffer): void;
  isValid(value: TrustLineEntry): boolean;
  toXDR(value: TrustLineEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TrustLineEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): TrustLineEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface DataEntryExt {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _DataEntryExt = createCompatUnion({
  codec: modern.DataEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const DataEntryExt = _DataEntryExt as unknown as {
  0(): DataEntryExt;
  read(io: Buffer): DataEntryExt;
  write(value: DataEntryExt, io: Buffer): void;
  isValid(value: DataEntryExt): boolean;
  toXDR(value: DataEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): DataEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): DataEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface DataEntry {
  accountId(value?: AccountId): AccountId;
  dataName(value?: String64): String64;
  dataValue(value?: DataValue): DataValue;
  ext(value?: DataEntryExt): DataEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _DataEntry = createCompatStruct({
  codec: modern.DataEntry,
  fields: [
    { name: 'accountId', modernName: 'accountID', convert: unionConverter(_PublicKey) },
    { name: 'dataName', modernName: 'dataName', convert: id },
    { name: 'dataValue', modernName: 'dataValue', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const DataEntry = _DataEntry as unknown as {
  new(attributes: { accountId: AccountId; dataName: String64; dataValue: DataValue; ext: DataEntryExt }): DataEntry;
  read(io: Buffer): DataEntry;
  write(value: DataEntry, io: Buffer): void;
  isValid(value: DataEntry): boolean;
  toXDR(value: DataEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): DataEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): DataEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimableBalanceEntryExtensionV1Ext {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimableBalanceEntryExtensionV1Ext = createCompatUnion({
  codec: modern.ClaimableBalanceEntryExtensionV1Ext,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const ClaimableBalanceEntryExtensionV1Ext = _ClaimableBalanceEntryExtensionV1Ext as unknown as {
  0(): ClaimableBalanceEntryExtensionV1Ext;
  read(io: Buffer): ClaimableBalanceEntryExtensionV1Ext;
  write(value: ClaimableBalanceEntryExtensionV1Ext, io: Buffer): void;
  isValid(value: ClaimableBalanceEntryExtensionV1Ext): boolean;
  toXDR(value: ClaimableBalanceEntryExtensionV1Ext): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimableBalanceEntryExtensionV1Ext;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimableBalanceEntryExtensionV1Ext;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimableBalanceEntryExtensionV1 {
  ext(value?: ClaimableBalanceEntryExtensionV1Ext): ClaimableBalanceEntryExtensionV1Ext;
  flags(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimableBalanceEntryExtensionV1 = createCompatStruct({
  codec: modern.ClaimableBalanceEntryExtensionV1,
  fields: [
    { name: 'ext', modernName: 'ext', convert: id },
    { name: 'flags', modernName: 'flags', convert: id },
  ],
});
export const ClaimableBalanceEntryExtensionV1 = _ClaimableBalanceEntryExtensionV1 as unknown as {
  new(attributes: { ext: ClaimableBalanceEntryExtensionV1Ext; flags: Uint32 }): ClaimableBalanceEntryExtensionV1;
  read(io: Buffer): ClaimableBalanceEntryExtensionV1;
  write(value: ClaimableBalanceEntryExtensionV1, io: Buffer): void;
  isValid(value: ClaimableBalanceEntryExtensionV1): boolean;
  toXDR(value: ClaimableBalanceEntryExtensionV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimableBalanceEntryExtensionV1;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimableBalanceEntryExtensionV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimableBalanceEntryExt {
  switch(): number;
  v1(value?: ClaimableBalanceEntryExtensionV1): ClaimableBalanceEntryExtensionV1;
  value(): ClaimableBalanceEntryExtensionV1 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimableBalanceEntryExt = createCompatUnion({
  codec: modern.ClaimableBalanceEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_ClaimableBalanceEntryExtensionV1) },
  ],
});
export const ClaimableBalanceEntryExt = _ClaimableBalanceEntryExt as unknown as {
  0(): ClaimableBalanceEntryExt;
  1(value: ClaimableBalanceEntryExtensionV1): ClaimableBalanceEntryExt;
  read(io: Buffer): ClaimableBalanceEntryExt;
  write(value: ClaimableBalanceEntryExt, io: Buffer): void;
  isValid(value: ClaimableBalanceEntryExt): boolean;
  toXDR(value: ClaimableBalanceEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimableBalanceEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimableBalanceEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ClaimableBalanceEntry {
  balanceId(value?: ClaimableBalanceId): ClaimableBalanceId;
  claimants(value?: Claimant[]): Claimant[];
  asset(value?: Asset): Asset;
  amount(value?: Int64): Int64;
  ext(value?: ClaimableBalanceEntryExt): ClaimableBalanceEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ClaimableBalanceEntry = createCompatStruct({
  codec: modern.ClaimableBalanceEntry,
  fields: [
    { name: 'balanceId', modernName: 'balanceID', convert: unionConverter(_ClaimableBalanceId) },
    { name: 'claimants', modernName: 'claimants', convert: arrayConverter(unionConverter(_Claimant)) },
    { name: 'asset', modernName: 'asset', convert: unionConverter(_Asset) },
    { name: 'amount', modernName: 'amount', convert: int64Conv },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const ClaimableBalanceEntry = _ClaimableBalanceEntry as unknown as {
  new(attributes: { balanceId: ClaimableBalanceId; claimants: Claimant[]; asset: Asset; amount: Int64; ext: ClaimableBalanceEntryExt }): ClaimableBalanceEntry;
  read(io: Buffer): ClaimableBalanceEntry;
  write(value: ClaimableBalanceEntry, io: Buffer): void;
  isValid(value: ClaimableBalanceEntry): boolean;
  toXDR(value: ClaimableBalanceEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ClaimableBalanceEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ClaimableBalanceEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolEntryConstantProduct {
  params(value?: LiquidityPoolConstantProductParameters): LiquidityPoolConstantProductParameters;
  reserveA(value?: Int64): Int64;
  reserveB(value?: Int64): Int64;
  totalPoolShares(value?: Int64): Int64;
  poolSharesTrustLineCount(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolEntryConstantProduct = createCompatStruct({
  codec: modern.LiquidityPoolEntryConstantProduct,
  fields: [
    { name: 'params', modernName: 'params', convert: structConverter(_LiquidityPoolConstantProductParameters) },
    { name: 'reserveA', modernName: 'reserveA', convert: int64Conv },
    { name: 'reserveB', modernName: 'reserveB', convert: int64Conv },
    { name: 'totalPoolShares', modernName: 'totalPoolShares', convert: int64Conv },
    { name: 'poolSharesTrustLineCount', modernName: 'poolSharesTrustLineCount', convert: int64Conv },
  ],
});
export const LiquidityPoolEntryConstantProduct = _LiquidityPoolEntryConstantProduct as unknown as {
  new(attributes: { params: LiquidityPoolConstantProductParameters; reserveA: Int64; reserveB: Int64; totalPoolShares: Int64; poolSharesTrustLineCount: Int64 }): LiquidityPoolEntryConstantProduct;
  read(io: Buffer): LiquidityPoolEntryConstantProduct;
  write(value: LiquidityPoolEntryConstantProduct, io: Buffer): void;
  isValid(value: LiquidityPoolEntryConstantProduct): boolean;
  toXDR(value: LiquidityPoolEntryConstantProduct): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolEntryConstantProduct;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolEntryConstantProduct;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolEntryBody {
  switch(): LiquidityPoolType;
  constantProduct(value?: LiquidityPoolEntryConstantProduct): LiquidityPoolEntryConstantProduct;
  value(): LiquidityPoolEntryConstantProduct;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolEntryBody = createCompatUnion({
  codec: modern.LiquidityPoolEntryBody,
  switchEnum: _LiquidityPoolType,
  arms: [
    { switchValues: ['liquidityPoolConstantProduct'], modern: 'LiquidityPoolConstantProduct', arm: 'constantProduct', convert: id },
  ],
});
export const LiquidityPoolEntryBody = _LiquidityPoolEntryBody as unknown as {
  liquidityPoolConstantProduct(value: LiquidityPoolEntryConstantProduct): LiquidityPoolEntryBody;
  read(io: Buffer): LiquidityPoolEntryBody;
  write(value: LiquidityPoolEntryBody, io: Buffer): void;
  isValid(value: LiquidityPoolEntryBody): boolean;
  toXDR(value: LiquidityPoolEntryBody): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolEntryBody;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolEntryBody;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LiquidityPoolEntry {
  liquidityPoolId(value?: PoolId): PoolId;
  body(value?: LiquidityPoolEntryBody): LiquidityPoolEntryBody;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LiquidityPoolEntry = createCompatStruct({
  codec: modern.LiquidityPoolEntry,
  fields: [
    { name: 'liquidityPoolId', modernName: 'liquidityPoolID', convert: id },
    { name: 'body', modernName: 'body', convert: id },
  ],
});
export const LiquidityPoolEntry = _LiquidityPoolEntry as unknown as {
  new(attributes: { liquidityPoolId: PoolId; body: LiquidityPoolEntryBody }): LiquidityPoolEntry;
  read(io: Buffer): LiquidityPoolEntry;
  write(value: LiquidityPoolEntry, io: Buffer): void;
  isValid(value: LiquidityPoolEntry): boolean;
  toXDR(value: LiquidityPoolEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LiquidityPoolEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): LiquidityPoolEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractDataEntry {
  ext(value?: ExtensionPoint): ExtensionPoint;
  contract(value?: ScAddress): ScAddress;
  key(value?: ScVal): ScVal;
  durability(value?: ContractDataDurability): ContractDataDurability;
  val(value?: ScVal): ScVal;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractDataEntry = createCompatStruct({
  codec: modern.ContractDataEntry,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'contract', modernName: 'contract', convert: unionConverter(_ScAddress) },
    { name: 'key', modernName: 'key', convert: lazyConverter(() => unionConverter(_ScVal)) },
    { name: 'durability', modernName: 'durability', convert: enumConverter(_ContractDataDurability) },
    { name: 'val', modernName: 'val', convert: lazyConverter(() => unionConverter(_ScVal)) },
  ],
});
export const ContractDataEntry = _ContractDataEntry as unknown as {
  new(attributes: { ext: ExtensionPoint; contract: ScAddress; key: ScVal; durability: ContractDataDurability; val: ScVal }): ContractDataEntry;
  read(io: Buffer): ContractDataEntry;
  write(value: ContractDataEntry, io: Buffer): void;
  isValid(value: ContractDataEntry): boolean;
  toXDR(value: ContractDataEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractDataEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractDataEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractCodeCostInputs {
  ext(value?: ExtensionPoint): ExtensionPoint;
  nInstructions(value?: Uint32): Uint32;
  nFunctions(value?: Uint32): Uint32;
  nGlobals(value?: Uint32): Uint32;
  nTableEntries(value?: Uint32): Uint32;
  nTypes(value?: Uint32): Uint32;
  nDataSegments(value?: Uint32): Uint32;
  nElemSegments(value?: Uint32): Uint32;
  nImports(value?: Uint32): Uint32;
  nExports(value?: Uint32): Uint32;
  nDataSegmentBytes(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractCodeCostInputs = createCompatStruct({
  codec: modern.ContractCodeCostInputs,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'nInstructions', modernName: 'nInstructions', convert: id },
    { name: 'nFunctions', modernName: 'nFunctions', convert: id },
    { name: 'nGlobals', modernName: 'nGlobals', convert: id },
    { name: 'nTableEntries', modernName: 'nTableEntries', convert: id },
    { name: 'nTypes', modernName: 'nTypes', convert: id },
    { name: 'nDataSegments', modernName: 'nDataSegments', convert: id },
    { name: 'nElemSegments', modernName: 'nElemSegments', convert: id },
    { name: 'nImports', modernName: 'nImports', convert: id },
    { name: 'nExports', modernName: 'nExports', convert: id },
    { name: 'nDataSegmentBytes', modernName: 'nDataSegmentBytes', convert: id },
  ],
});
export const ContractCodeCostInputs = _ContractCodeCostInputs as unknown as {
  new(attributes: { ext: ExtensionPoint; nInstructions: Uint32; nFunctions: Uint32; nGlobals: Uint32; nTableEntries: Uint32; nTypes: Uint32; nDataSegments: Uint32; nElemSegments: Uint32; nImports: Uint32; nExports: Uint32; nDataSegmentBytes: Uint32 }): ContractCodeCostInputs;
  read(io: Buffer): ContractCodeCostInputs;
  write(value: ContractCodeCostInputs, io: Buffer): void;
  isValid(value: ContractCodeCostInputs): boolean;
  toXDR(value: ContractCodeCostInputs): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractCodeCostInputs;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractCodeCostInputs;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractCodeEntryV1 {
  ext(value?: ExtensionPoint): ExtensionPoint;
  costInputs(value?: ContractCodeCostInputs): ContractCodeCostInputs;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractCodeEntryV1 = createCompatStruct({
  codec: modern.ContractCodeEntryV1,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'costInputs', modernName: 'costInputs', convert: structConverter(_ContractCodeCostInputs) },
  ],
});
export const ContractCodeEntryV1 = _ContractCodeEntryV1 as unknown as {
  new(attributes: { ext: ExtensionPoint; costInputs: ContractCodeCostInputs }): ContractCodeEntryV1;
  read(io: Buffer): ContractCodeEntryV1;
  write(value: ContractCodeEntryV1, io: Buffer): void;
  isValid(value: ContractCodeEntryV1): boolean;
  toXDR(value: ContractCodeEntryV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractCodeEntryV1;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractCodeEntryV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractCodeEntryExt {
  switch(): number;
  v1(value?: ContractCodeEntryV1): ContractCodeEntryV1;
  value(): ContractCodeEntryV1 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractCodeEntryExt = createCompatUnion({
  codec: modern.ContractCodeEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'v1', convert: id },
  ],
});
export const ContractCodeEntryExt = _ContractCodeEntryExt as unknown as {
  0(): ContractCodeEntryExt;
  1(value: ContractCodeEntryV1): ContractCodeEntryExt;
  read(io: Buffer): ContractCodeEntryExt;
  write(value: ContractCodeEntryExt, io: Buffer): void;
  isValid(value: ContractCodeEntryExt): boolean;
  toXDR(value: ContractCodeEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractCodeEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractCodeEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractCodeEntry {
  ext(value?: ContractCodeEntryExt): ContractCodeEntryExt;
  hash(value?: Hash): Hash;
  code(value?: Buffer): Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractCodeEntry = createCompatStruct({
  codec: modern.ContractCodeEntry,
  fields: [
    { name: 'ext', modernName: 'ext', convert: id },
    { name: 'hash', modernName: 'hash', convert: id },
    { name: 'code', modernName: 'code', convert: id },
  ],
});
export const ContractCodeEntry = _ContractCodeEntry as unknown as {
  new(attributes: { ext: ContractCodeEntryExt; hash: Hash; code: Buffer }): ContractCodeEntry;
  read(io: Buffer): ContractCodeEntry;
  write(value: ContractCodeEntry, io: Buffer): void;
  isValid(value: ContractCodeEntry): boolean;
  toXDR(value: ContractCodeEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractCodeEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractCodeEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TtlEntry {
  keyHash(value?: Hash): Hash;
  liveUntilLedgerSeq(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TtlEntry = createCompatStruct({
  codec: modern.TTLEntry,
  fields: [
    { name: 'keyHash', modernName: 'keyHash', convert: id },
    { name: 'liveUntilLedgerSeq', modernName: 'liveUntilLedgerSeq', convert: id },
  ],
});
export const TtlEntry = _TtlEntry as unknown as {
  new(attributes: { keyHash: Hash; liveUntilLedgerSeq: Uint32 }): TtlEntry;
  read(io: Buffer): TtlEntry;
  write(value: TtlEntry, io: Buffer): void;
  isValid(value: TtlEntry): boolean;
  toXDR(value: TtlEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TtlEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): TtlEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerEntryData {
  switch(): LedgerEntryType;
  account(value?: AccountEntry): AccountEntry;
  trustLine(value?: TrustLineEntry): TrustLineEntry;
  offer(value?: OfferEntry): OfferEntry;
  data(value?: DataEntry): DataEntry;
  claimableBalance(value?: ClaimableBalanceEntry): ClaimableBalanceEntry;
  liquidityPool(value?: LiquidityPoolEntry): LiquidityPoolEntry;
  contractData(value?: ContractDataEntry): ContractDataEntry;
  contractCode(value?: ContractCodeEntry): ContractCodeEntry;
  configSetting(value?: ConfigSettingEntry): ConfigSettingEntry;
  ttl(value?: TtlEntry): TtlEntry;
  value(): AccountEntry | TrustLineEntry | OfferEntry | DataEntry | ClaimableBalanceEntry | LiquidityPoolEntry | ContractDataEntry | ContractCodeEntry | ConfigSettingEntry | TtlEntry;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerEntryData = createCompatUnion({
  codec: modern.LedgerEntryData,
  switchEnum: _LedgerEntryType,
  arms: [
    { switchValues: ['account'], modern: 'Account', arm: 'account', convert: structConverter(_AccountEntry) },
    { switchValues: ['trustline'], modern: 'Trustline', arm: 'trustLine', convert: structConverter(_TrustLineEntry) },
    { switchValues: ['offer'], modern: 'Offer', arm: 'offer', convert: structConverter(_OfferEntry) },
    { switchValues: ['data'], modern: 'Data', arm: 'data', convert: structConverter(_DataEntry) },
    { switchValues: ['claimableBalance'], modern: 'ClaimableBalance', arm: 'claimableBalance', convert: structConverter(_ClaimableBalanceEntry) },
    { switchValues: ['liquidityPool'], modern: 'LiquidityPool', arm: 'liquidityPool', convert: structConverter(_LiquidityPoolEntry) },
    { switchValues: ['contractData'], modern: 'ContractData', arm: 'contractData', convert: structConverter(_ContractDataEntry) },
    { switchValues: ['contractCode'], modern: 'ContractCode', arm: 'contractCode', convert: structConverter(_ContractCodeEntry) },
    { switchValues: ['configSetting'], modern: 'ConfigSetting', arm: 'configSetting', convert: unionConverter(_ConfigSettingEntry) },
    { switchValues: ['ttl'], modern: 'Ttl', arm: 'ttl', convert: structConverter(_TtlEntry) },
  ],
});
export const LedgerEntryData = _LedgerEntryData as unknown as {
  account(value: AccountEntry): LedgerEntryData;
  trustline(value: TrustLineEntry): LedgerEntryData;
  offer(value: OfferEntry): LedgerEntryData;
  data(value: DataEntry): LedgerEntryData;
  claimableBalance(value: ClaimableBalanceEntry): LedgerEntryData;
  liquidityPool(value: LiquidityPoolEntry): LedgerEntryData;
  contractData(value: ContractDataEntry): LedgerEntryData;
  contractCode(value: ContractCodeEntry): LedgerEntryData;
  configSetting(value: ConfigSettingEntry): LedgerEntryData;
  ttl(value: TtlEntry): LedgerEntryData;
  read(io: Buffer): LedgerEntryData;
  write(value: LedgerEntryData, io: Buffer): void;
  isValid(value: LedgerEntryData): boolean;
  toXDR(value: LedgerEntryData): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerEntryData;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerEntryData;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerEntryExtensionV1Ext {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerEntryExtensionV1Ext = createCompatUnion({
  codec: modern.LedgerEntryExtensionV1Ext,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const LedgerEntryExtensionV1Ext = _LedgerEntryExtensionV1Ext as unknown as {
  0(): LedgerEntryExtensionV1Ext;
  read(io: Buffer): LedgerEntryExtensionV1Ext;
  write(value: LedgerEntryExtensionV1Ext, io: Buffer): void;
  isValid(value: LedgerEntryExtensionV1Ext): boolean;
  toXDR(value: LedgerEntryExtensionV1Ext): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerEntryExtensionV1Ext;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerEntryExtensionV1Ext;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerEntryExtensionV1 {
  sponsoringId(value?: SponsorshipDescriptor): SponsorshipDescriptor;
  ext(value?: LedgerEntryExtensionV1Ext): LedgerEntryExtensionV1Ext;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerEntryExtensionV1 = createCompatStruct({
  codec: modern.LedgerEntryExtensionV1,
  fields: [
    { name: 'sponsoringId', modernName: 'sponsoringID', convert: optionConverter(unionConverter(_PublicKey)) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const LedgerEntryExtensionV1 = _LedgerEntryExtensionV1 as unknown as {
  new(attributes: { sponsoringId: SponsorshipDescriptor; ext: LedgerEntryExtensionV1Ext }): LedgerEntryExtensionV1;
  read(io: Buffer): LedgerEntryExtensionV1;
  write(value: LedgerEntryExtensionV1, io: Buffer): void;
  isValid(value: LedgerEntryExtensionV1): boolean;
  toXDR(value: LedgerEntryExtensionV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerEntryExtensionV1;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerEntryExtensionV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerEntryExt {
  switch(): number;
  v1(value?: LedgerEntryExtensionV1): LedgerEntryExtensionV1;
  value(): LedgerEntryExtensionV1 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerEntryExt = createCompatUnion({
  codec: modern.LedgerEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_LedgerEntryExtensionV1) },
  ],
});
export const LedgerEntryExt = _LedgerEntryExt as unknown as {
  0(): LedgerEntryExt;
  1(value: LedgerEntryExtensionV1): LedgerEntryExt;
  read(io: Buffer): LedgerEntryExt;
  write(value: LedgerEntryExt, io: Buffer): void;
  isValid(value: LedgerEntryExt): boolean;
  toXDR(value: LedgerEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerEntry {
  lastModifiedLedgerSeq(value?: Uint32): Uint32;
  data(value?: LedgerEntryData): LedgerEntryData;
  ext(value?: LedgerEntryExt): LedgerEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerEntry = createCompatStruct({
  codec: modern.LedgerEntry,
  fields: [
    { name: 'lastModifiedLedgerSeq', modernName: 'lastModifiedLedgerSeq', convert: id },
    { name: 'data', modernName: 'data', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const LedgerEntry = _LedgerEntry as unknown as {
  new(attributes: { lastModifiedLedgerSeq: Uint32; data: LedgerEntryData; ext: LedgerEntryExt }): LedgerEntry;
  read(io: Buffer): LedgerEntry;
  write(value: LedgerEntry, io: Buffer): void;
  isValid(value: LedgerEntry): boolean;
  toXDR(value: LedgerEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerEntryChange {
  switch(): LedgerEntryChangeType;
  created(value?: LedgerEntry): LedgerEntry;
  updated(value?: LedgerEntry): LedgerEntry;
  removed(value?: LedgerKey): LedgerKey;
  state(value?: LedgerEntry): LedgerEntry;
  restored(value?: LedgerEntry): LedgerEntry;
  value(): LedgerEntry | LedgerEntry | LedgerKey | LedgerEntry | LedgerEntry;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerEntryChange = createCompatUnion({
  codec: modern.LedgerEntryChange,
  switchEnum: _LedgerEntryChangeType,
  arms: [
    { switchValues: ['ledgerEntryCreated'], modern: 'Created', arm: 'created', convert: structConverter(_LedgerEntry) },
    { switchValues: ['ledgerEntryUpdated'], modern: 'Updated', arm: 'updated', convert: structConverter(_LedgerEntry) },
    { switchValues: ['ledgerEntryRemoved'], modern: 'Removed', arm: 'removed', convert: unionConverter(_LedgerKey) },
    { switchValues: ['ledgerEntryState'], modern: 'State', arm: 'state', convert: structConverter(_LedgerEntry) },
    { switchValues: ['ledgerEntryRestored'], modern: 'Restored', arm: 'restored', convert: structConverter(_LedgerEntry) },
  ],
});
export const LedgerEntryChange = _LedgerEntryChange as unknown as {
  ledgerEntryCreated(value: LedgerEntry): LedgerEntryChange;
  ledgerEntryUpdated(value: LedgerEntry): LedgerEntryChange;
  ledgerEntryRemoved(value: LedgerKey): LedgerEntryChange;
  ledgerEntryState(value: LedgerEntry): LedgerEntryChange;
  ledgerEntryRestored(value: LedgerEntry): LedgerEntryChange;
  read(io: Buffer): LedgerEntryChange;
  write(value: LedgerEntryChange, io: Buffer): void;
  isValid(value: LedgerEntryChange): boolean;
  toXDR(value: LedgerEntryChange): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerEntryChange;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerEntryChange;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type LedgerEntryChanges = LedgerEntryChange[];
export const LedgerEntryChanges = createCompatTypedef({ codec: modern.LedgerEntryChanges, convert: arrayConverter(unionConverter(_LedgerEntryChange)) });

export interface OperationMeta {
  changes(value?: LedgerEntryChanges): LedgerEntryChanges;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _OperationMeta = createCompatStruct({
  codec: modern.OperationMeta,
  fields: [
    { name: 'changes', modernName: 'changes', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
  ],
});
export const OperationMeta = _OperationMeta as unknown as {
  new(attributes: { changes: LedgerEntryChanges }): OperationMeta;
  read(io: Buffer): OperationMeta;
  write(value: OperationMeta, io: Buffer): void;
  isValid(value: OperationMeta): boolean;
  toXDR(value: OperationMeta): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): OperationMeta;
  fromXDR(input: string, format: 'hex' | 'base64'): OperationMeta;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionMetaV1 {
  txChanges(value?: LedgerEntryChanges): LedgerEntryChanges;
  operations(value?: OperationMeta[]): OperationMeta[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionMetaV1 = createCompatStruct({
  codec: modern.TransactionMetaV1,
  fields: [
    { name: 'txChanges', modernName: 'txChanges', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'operations', modernName: 'operations', convert: arrayConverter(structConverter(_OperationMeta)) },
  ],
});
export const TransactionMetaV1 = _TransactionMetaV1 as unknown as {
  new(attributes: { txChanges: LedgerEntryChanges; operations: OperationMeta[] }): TransactionMetaV1;
  read(io: Buffer): TransactionMetaV1;
  write(value: TransactionMetaV1, io: Buffer): void;
  isValid(value: TransactionMetaV1): boolean;
  toXDR(value: TransactionMetaV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionMetaV1;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionMetaV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionMetaV2 {
  txChangesBefore(value?: LedgerEntryChanges): LedgerEntryChanges;
  operations(value?: OperationMeta[]): OperationMeta[];
  txChangesAfter(value?: LedgerEntryChanges): LedgerEntryChanges;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionMetaV2 = createCompatStruct({
  codec: modern.TransactionMetaV2,
  fields: [
    { name: 'txChangesBefore', modernName: 'txChangesBefore', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'operations', modernName: 'operations', convert: arrayConverter(structConverter(_OperationMeta)) },
    { name: 'txChangesAfter', modernName: 'txChangesAfter', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
  ],
});
export const TransactionMetaV2 = _TransactionMetaV2 as unknown as {
  new(attributes: { txChangesBefore: LedgerEntryChanges; operations: OperationMeta[]; txChangesAfter: LedgerEntryChanges }): TransactionMetaV2;
  read(io: Buffer): TransactionMetaV2;
  write(value: TransactionMetaV2, io: Buffer): void;
  isValid(value: TransactionMetaV2): boolean;
  toXDR(value: TransactionMetaV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionMetaV2;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionMetaV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanTransactionMetaExtV1 {
  ext(value?: ExtensionPoint): ExtensionPoint;
  totalNonRefundableResourceFeeCharged(value?: Int64): Int64;
  totalRefundableResourceFeeCharged(value?: Int64): Int64;
  rentFeeCharged(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanTransactionMetaExtV1 = createCompatStruct({
  codec: modern.SorobanTransactionMetaExtV1,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'totalNonRefundableResourceFeeCharged', modernName: 'totalNonRefundableResourceFeeCharged', convert: int64Conv },
    { name: 'totalRefundableResourceFeeCharged', modernName: 'totalRefundableResourceFeeCharged', convert: int64Conv },
    { name: 'rentFeeCharged', modernName: 'rentFeeCharged', convert: int64Conv },
  ],
});
export const SorobanTransactionMetaExtV1 = _SorobanTransactionMetaExtV1 as unknown as {
  new(attributes: { ext: ExtensionPoint; totalNonRefundableResourceFeeCharged: Int64; totalRefundableResourceFeeCharged: Int64; rentFeeCharged: Int64 }): SorobanTransactionMetaExtV1;
  read(io: Buffer): SorobanTransactionMetaExtV1;
  write(value: SorobanTransactionMetaExtV1, io: Buffer): void;
  isValid(value: SorobanTransactionMetaExtV1): boolean;
  toXDR(value: SorobanTransactionMetaExtV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanTransactionMetaExtV1;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanTransactionMetaExtV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanTransactionMetaExt {
  switch(): number;
  v1(value?: SorobanTransactionMetaExtV1): SorobanTransactionMetaExtV1;
  value(): SorobanTransactionMetaExtV1 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanTransactionMetaExt = createCompatUnion({
  codec: modern.SorobanTransactionMetaExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_SorobanTransactionMetaExtV1) },
  ],
});
export const SorobanTransactionMetaExt = _SorobanTransactionMetaExt as unknown as {
  0(): SorobanTransactionMetaExt;
  1(value: SorobanTransactionMetaExtV1): SorobanTransactionMetaExt;
  read(io: Buffer): SorobanTransactionMetaExt;
  write(value: SorobanTransactionMetaExt, io: Buffer): void;
  isValid(value: SorobanTransactionMetaExt): boolean;
  toXDR(value: SorobanTransactionMetaExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanTransactionMetaExt;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanTransactionMetaExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractEventType {
  readonly name: 'system' | 'contract' | 'diagnostic';
  readonly value: 0 | 1 | 2;
}
const _ContractEventType = createCompatEnum({
  codec: modern.ContractEventType,
  members: [
    { compat: 'system', modern: 'System', value: 0 },
    { compat: 'contract', modern: 'Contract', value: 1 },
    { compat: 'diagnostic', modern: 'Diagnostic', value: 2 },
  ],
});
export const ContractEventType = _ContractEventType as unknown as {
  system(): ContractEventType;
  contract(): ContractEventType;
  diagnostic(): ContractEventType;
};

export interface ContractEventV0 {
  topics(value?: ScVal[]): ScVal[];
  data(value?: ScVal): ScVal;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractEventV0 = createCompatStruct({
  codec: modern.ContractEventV0,
  fields: [
    { name: 'topics', modernName: 'topics', convert: arrayConverter(lazyConverter(() => unionConverter(_ScVal))) },
    { name: 'data', modernName: 'data', convert: lazyConverter(() => unionConverter(_ScVal)) },
  ],
});
export const ContractEventV0 = _ContractEventV0 as unknown as {
  new(attributes: { topics: ScVal[]; data: ScVal }): ContractEventV0;
  read(io: Buffer): ContractEventV0;
  write(value: ContractEventV0, io: Buffer): void;
  isValid(value: ContractEventV0): boolean;
  toXDR(value: ContractEventV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractEventV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractEventV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractEventBody {
  switch(): number;
  v0(value?: ContractEventV0): ContractEventV0;
  value(): ContractEventV0;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractEventBody = createCompatUnion({
  codec: modern.ContractEventBody,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0, arm: 'v0', convert: id },
  ],
});
export const ContractEventBody = _ContractEventBody as unknown as {
  0(value: ContractEventV0): ContractEventBody;
  read(io: Buffer): ContractEventBody;
  write(value: ContractEventBody, io: Buffer): void;
  isValid(value: ContractEventBody): boolean;
  toXDR(value: ContractEventBody): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractEventBody;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractEventBody;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ContractEvent {
  ext(value?: ExtensionPoint): ExtensionPoint;
  contractId(value?: null | ContractId): null | ContractId;
  type(value?: ContractEventType): ContractEventType;
  body(value?: ContractEventBody): ContractEventBody;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ContractEvent = createCompatStruct({
  codec: modern.ContractEvent,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'contractId', modernName: 'contractID', convert: optionConverter(id) },
    { name: 'type', modernName: 'type', convert: enumConverter(_ContractEventType) },
    { name: 'body', modernName: 'body', convert: id },
  ],
});
export const ContractEvent = _ContractEvent as unknown as {
  new(attributes: { ext: ExtensionPoint; contractId: null | ContractId; type: ContractEventType; body: ContractEventBody }): ContractEvent;
  read(io: Buffer): ContractEvent;
  write(value: ContractEvent, io: Buffer): void;
  isValid(value: ContractEvent): boolean;
  toXDR(value: ContractEvent): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ContractEvent;
  fromXDR(input: string, format: 'hex' | 'base64'): ContractEvent;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface DiagnosticEvent {
  inSuccessfulContractCall(value?: boolean): boolean;
  event(value?: ContractEvent): ContractEvent;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _DiagnosticEvent = createCompatStruct({
  codec: modern.DiagnosticEvent,
  fields: [
    { name: 'inSuccessfulContractCall', modernName: 'inSuccessfulContractCall', convert: id },
    { name: 'event', modernName: 'event', convert: structConverter(_ContractEvent) },
  ],
});
export const DiagnosticEvent = _DiagnosticEvent as unknown as {
  new(attributes: { inSuccessfulContractCall: boolean; event: ContractEvent }): DiagnosticEvent;
  read(io: Buffer): DiagnosticEvent;
  write(value: DiagnosticEvent, io: Buffer): void;
  isValid(value: DiagnosticEvent): boolean;
  toXDR(value: DiagnosticEvent): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): DiagnosticEvent;
  fromXDR(input: string, format: 'hex' | 'base64'): DiagnosticEvent;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanTransactionMeta {
  ext(value?: SorobanTransactionMetaExt): SorobanTransactionMetaExt;
  events(value?: ContractEvent[]): ContractEvent[];
  returnValue(value?: ScVal): ScVal;
  diagnosticEvents(value?: DiagnosticEvent[]): DiagnosticEvent[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanTransactionMeta = createCompatStruct({
  codec: modern.SorobanTransactionMeta,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_SorobanTransactionMetaExt) },
    { name: 'events', modernName: 'events', convert: arrayConverter(structConverter(_ContractEvent)) },
    { name: 'returnValue', modernName: 'returnValue', convert: lazyConverter(() => unionConverter(_ScVal)) },
    { name: 'diagnosticEvents', modernName: 'diagnosticEvents', convert: arrayConverter(structConverter(_DiagnosticEvent)) },
  ],
});
export const SorobanTransactionMeta = _SorobanTransactionMeta as unknown as {
  new(attributes: { ext: SorobanTransactionMetaExt; events: ContractEvent[]; returnValue: ScVal; diagnosticEvents: DiagnosticEvent[] }): SorobanTransactionMeta;
  read(io: Buffer): SorobanTransactionMeta;
  write(value: SorobanTransactionMeta, io: Buffer): void;
  isValid(value: SorobanTransactionMeta): boolean;
  toXDR(value: SorobanTransactionMeta): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanTransactionMeta;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanTransactionMeta;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionMetaV3 {
  ext(value?: ExtensionPoint): ExtensionPoint;
  txChangesBefore(value?: LedgerEntryChanges): LedgerEntryChanges;
  operations(value?: OperationMeta[]): OperationMeta[];
  txChangesAfter(value?: LedgerEntryChanges): LedgerEntryChanges;
  sorobanMeta(value?: null | SorobanTransactionMeta): null | SorobanTransactionMeta;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionMetaV3 = createCompatStruct({
  codec: modern.TransactionMetaV3,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'txChangesBefore', modernName: 'txChangesBefore', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'operations', modernName: 'operations', convert: arrayConverter(structConverter(_OperationMeta)) },
    { name: 'txChangesAfter', modernName: 'txChangesAfter', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'sorobanMeta', modernName: 'sorobanMeta', convert: optionConverter(structConverter(_SorobanTransactionMeta)) },
  ],
});
export const TransactionMetaV3 = _TransactionMetaV3 as unknown as {
  new(attributes: { ext: ExtensionPoint; txChangesBefore: LedgerEntryChanges; operations: OperationMeta[]; txChangesAfter: LedgerEntryChanges; sorobanMeta: null | SorobanTransactionMeta }): TransactionMetaV3;
  read(io: Buffer): TransactionMetaV3;
  write(value: TransactionMetaV3, io: Buffer): void;
  isValid(value: TransactionMetaV3): boolean;
  toXDR(value: TransactionMetaV3): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionMetaV3;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionMetaV3;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface OperationMetaV2 {
  ext(value?: ExtensionPoint): ExtensionPoint;
  changes(value?: LedgerEntryChanges): LedgerEntryChanges;
  events(value?: ContractEvent[]): ContractEvent[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _OperationMetaV2 = createCompatStruct({
  codec: modern.OperationMetaV2,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'changes', modernName: 'changes', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'events', modernName: 'events', convert: arrayConverter(structConverter(_ContractEvent)) },
  ],
});
export const OperationMetaV2 = _OperationMetaV2 as unknown as {
  new(attributes: { ext: ExtensionPoint; changes: LedgerEntryChanges; events: ContractEvent[] }): OperationMetaV2;
  read(io: Buffer): OperationMetaV2;
  write(value: OperationMetaV2, io: Buffer): void;
  isValid(value: OperationMetaV2): boolean;
  toXDR(value: OperationMetaV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): OperationMetaV2;
  fromXDR(input: string, format: 'hex' | 'base64'): OperationMetaV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SorobanTransactionMetaV2 {
  ext(value?: SorobanTransactionMetaExt): SorobanTransactionMetaExt;
  returnValue(value?: null | ScVal): null | ScVal;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SorobanTransactionMetaV2 = createCompatStruct({
  codec: modern.SorobanTransactionMetaV2,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_SorobanTransactionMetaExt) },
    { name: 'returnValue', modernName: 'returnValue', convert: optionConverter(lazyConverter(() => unionConverter(_ScVal))) },
  ],
});
export const SorobanTransactionMetaV2 = _SorobanTransactionMetaV2 as unknown as {
  new(attributes: { ext: SorobanTransactionMetaExt; returnValue: null | ScVal }): SorobanTransactionMetaV2;
  read(io: Buffer): SorobanTransactionMetaV2;
  write(value: SorobanTransactionMetaV2, io: Buffer): void;
  isValid(value: SorobanTransactionMetaV2): boolean;
  toXDR(value: SorobanTransactionMetaV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SorobanTransactionMetaV2;
  fromXDR(input: string, format: 'hex' | 'base64'): SorobanTransactionMetaV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionEventStage {
  readonly name: 'transactionEventStageBeforeAllTxes' | 'transactionEventStageAfterTx' | 'transactionEventStageAfterAllTxes';
  readonly value: 0 | 1 | 2;
}
const _TransactionEventStage = createCompatEnum({
  codec: modern.TransactionEventStage,
  members: [
    { compat: 'transactionEventStageBeforeAllTxes', modern: 'BeforeAllTxs', value: 0 },
    { compat: 'transactionEventStageAfterTx', modern: 'AfterTx', value: 1 },
    { compat: 'transactionEventStageAfterAllTxes', modern: 'AfterAllTxs', value: 2 },
  ],
});
export const TransactionEventStage = _TransactionEventStage as unknown as {
  transactionEventStageBeforeAllTxes(): TransactionEventStage;
  transactionEventStageAfterTx(): TransactionEventStage;
  transactionEventStageAfterAllTxes(): TransactionEventStage;
};

export interface TransactionEvent {
  stage(value?: TransactionEventStage): TransactionEventStage;
  event(value?: ContractEvent): ContractEvent;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionEvent = createCompatStruct({
  codec: modern.TransactionEvent,
  fields: [
    { name: 'stage', modernName: 'stage', convert: enumConverter(_TransactionEventStage) },
    { name: 'event', modernName: 'event', convert: structConverter(_ContractEvent) },
  ],
});
export const TransactionEvent = _TransactionEvent as unknown as {
  new(attributes: { stage: TransactionEventStage; event: ContractEvent }): TransactionEvent;
  read(io: Buffer): TransactionEvent;
  write(value: TransactionEvent, io: Buffer): void;
  isValid(value: TransactionEvent): boolean;
  toXDR(value: TransactionEvent): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionEvent;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionEvent;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionMetaV4 {
  ext(value?: ExtensionPoint): ExtensionPoint;
  txChangesBefore(value?: LedgerEntryChanges): LedgerEntryChanges;
  operations(value?: OperationMetaV2[]): OperationMetaV2[];
  txChangesAfter(value?: LedgerEntryChanges): LedgerEntryChanges;
  sorobanMeta(value?: null | SorobanTransactionMetaV2): null | SorobanTransactionMetaV2;
  events(value?: TransactionEvent[]): TransactionEvent[];
  diagnosticEvents(value?: DiagnosticEvent[]): DiagnosticEvent[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionMetaV4 = createCompatStruct({
  codec: modern.TransactionMetaV4,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'txChangesBefore', modernName: 'txChangesBefore', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'operations', modernName: 'operations', convert: arrayConverter(structConverter(_OperationMetaV2)) },
    { name: 'txChangesAfter', modernName: 'txChangesAfter', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'sorobanMeta', modernName: 'sorobanMeta', convert: optionConverter(structConverter(_SorobanTransactionMetaV2)) },
    { name: 'events', modernName: 'events', convert: arrayConverter(structConverter(_TransactionEvent)) },
    { name: 'diagnosticEvents', modernName: 'diagnosticEvents', convert: arrayConverter(structConverter(_DiagnosticEvent)) },
  ],
});
export const TransactionMetaV4 = _TransactionMetaV4 as unknown as {
  new(attributes: { ext: ExtensionPoint; txChangesBefore: LedgerEntryChanges; operations: OperationMetaV2[]; txChangesAfter: LedgerEntryChanges; sorobanMeta: null | SorobanTransactionMetaV2; events: TransactionEvent[]; diagnosticEvents: DiagnosticEvent[] }): TransactionMetaV4;
  read(io: Buffer): TransactionMetaV4;
  write(value: TransactionMetaV4, io: Buffer): void;
  isValid(value: TransactionMetaV4): boolean;
  toXDR(value: TransactionMetaV4): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionMetaV4;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionMetaV4;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionMeta {
  switch(): number;
  operations(value?: OperationMeta[]): OperationMeta[];
  v1(value?: TransactionMetaV1): TransactionMetaV1;
  v2(value?: TransactionMetaV2): TransactionMetaV2;
  v3(value?: TransactionMetaV3): TransactionMetaV3;
  v4(value?: TransactionMetaV4): TransactionMetaV4;
  value(): OperationMeta[] | TransactionMetaV1 | TransactionMetaV2 | TransactionMetaV3 | TransactionMetaV4;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionMeta = createCompatUnion({
  codec: modern.TransactionMeta,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0, arm: 'operations', convert: arrayConverter(structConverter(_OperationMeta)) },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_TransactionMetaV1) },
    { switchValues: [2], modern: 2, arm: 'v2', convert: structConverter(_TransactionMetaV2) },
    { switchValues: [3], modern: 3, arm: 'v3', convert: structConverter(_TransactionMetaV3) },
    { switchValues: [4], modern: 4, arm: 'v4', convert: structConverter(_TransactionMetaV4) },
  ],
});
export const TransactionMeta = _TransactionMeta as unknown as {
  0(value: OperationMeta[]): TransactionMeta;
  1(value: TransactionMetaV1): TransactionMeta;
  2(value: TransactionMetaV2): TransactionMeta;
  3(value: TransactionMetaV3): TransactionMeta;
  4(value: TransactionMetaV4): TransactionMeta;
  read(io: Buffer): TransactionMeta;
  write(value: TransactionMeta, io: Buffer): void;
  isValid(value: TransactionMeta): boolean;
  toXDR(value: TransactionMeta): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionMeta;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionMeta;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionResultMeta {
  result(value?: TransactionResultPair): TransactionResultPair;
  feeProcessing(value?: LedgerEntryChanges): LedgerEntryChanges;
  txApplyProcessing(value?: TransactionMeta): TransactionMeta;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionResultMeta = createCompatStruct({
  codec: modern.TransactionResultMeta,
  fields: [
    { name: 'result', modernName: 'result', convert: structConverter(_TransactionResultPair) },
    { name: 'feeProcessing', modernName: 'feeProcessing', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'txApplyProcessing', modernName: 'txApplyProcessing', convert: unionConverter(_TransactionMeta) },
  ],
});
export const TransactionResultMeta = _TransactionResultMeta as unknown as {
  new(attributes: { result: TransactionResultPair; feeProcessing: LedgerEntryChanges; txApplyProcessing: TransactionMeta }): TransactionResultMeta;
  read(io: Buffer): TransactionResultMeta;
  write(value: TransactionResultMeta, io: Buffer): void;
  isValid(value: TransactionResultMeta): boolean;
  toXDR(value: TransactionResultMeta): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionResultMeta;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionResultMeta;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerUpgradeType {
  readonly name: 'ledgerUpgradeVersion' | 'ledgerUpgradeBaseFee' | 'ledgerUpgradeMaxTxSetSize' | 'ledgerUpgradeBaseReserve' | 'ledgerUpgradeFlags' | 'ledgerUpgradeConfig' | 'ledgerUpgradeMaxSorobanTxSetSize';
  readonly value: 1 | 2 | 3 | 4 | 5 | 6 | 7;
}
const _LedgerUpgradeType = createCompatEnum({
  codec: modern.LedgerUpgradeType,
  members: [
    { compat: 'ledgerUpgradeVersion', modern: 'Version', value: 1 },
    { compat: 'ledgerUpgradeBaseFee', modern: 'BaseFee', value: 2 },
    { compat: 'ledgerUpgradeMaxTxSetSize', modern: 'MaxTxSetSize', value: 3 },
    { compat: 'ledgerUpgradeBaseReserve', modern: 'BaseReserve', value: 4 },
    { compat: 'ledgerUpgradeFlags', modern: 'Flags', value: 5 },
    { compat: 'ledgerUpgradeConfig', modern: 'Config', value: 6 },
    { compat: 'ledgerUpgradeMaxSorobanTxSetSize', modern: 'MaxSorobanTxSetSize', value: 7 },
  ],
});
export const LedgerUpgradeType = _LedgerUpgradeType as unknown as {
  ledgerUpgradeVersion(): LedgerUpgradeType;
  ledgerUpgradeBaseFee(): LedgerUpgradeType;
  ledgerUpgradeMaxTxSetSize(): LedgerUpgradeType;
  ledgerUpgradeBaseReserve(): LedgerUpgradeType;
  ledgerUpgradeFlags(): LedgerUpgradeType;
  ledgerUpgradeConfig(): LedgerUpgradeType;
  ledgerUpgradeMaxSorobanTxSetSize(): LedgerUpgradeType;
};

export interface ConfigUpgradeSetKey {
  contractId(value?: ContractId): ContractId;
  contentHash(value?: Hash): Hash;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigUpgradeSetKey = createCompatStruct({
  codec: modern.ConfigUpgradeSetKey,
  fields: [
    { name: 'contractId', modernName: 'contractID', convert: id },
    { name: 'contentHash', modernName: 'contentHash', convert: id },
  ],
});
export const ConfigUpgradeSetKey = _ConfigUpgradeSetKey as unknown as {
  new(attributes: { contractId: ContractId; contentHash: Hash }): ConfigUpgradeSetKey;
  read(io: Buffer): ConfigUpgradeSetKey;
  write(value: ConfigUpgradeSetKey, io: Buffer): void;
  isValid(value: ConfigUpgradeSetKey): boolean;
  toXDR(value: ConfigUpgradeSetKey): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigUpgradeSetKey;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigUpgradeSetKey;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerUpgrade {
  switch(): LedgerUpgradeType;
  newLedgerVersion(value?: Uint32): Uint32;
  newBaseFee(value?: Uint32): Uint32;
  newMaxTxSetSize(value?: Uint32): Uint32;
  newBaseReserve(value?: Uint32): Uint32;
  newFlags(value?: Uint32): Uint32;
  newConfig(value?: ConfigUpgradeSetKey): ConfigUpgradeSetKey;
  newMaxSorobanTxSetSize(value?: Uint32): Uint32;
  value(): Uint32 | Uint32 | Uint32 | Uint32 | Uint32 | ConfigUpgradeSetKey | Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerUpgrade = createCompatUnion({
  codec: modern.LedgerUpgrade,
  switchEnum: _LedgerUpgradeType,
  arms: [
    { switchValues: ['ledgerUpgradeVersion'], modern: 'Version', arm: 'newLedgerVersion', convert: id },
    { switchValues: ['ledgerUpgradeBaseFee'], modern: 'BaseFee', arm: 'newBaseFee', convert: id },
    { switchValues: ['ledgerUpgradeMaxTxSetSize'], modern: 'MaxTxSetSize', arm: 'newMaxTxSetSize', convert: id },
    { switchValues: ['ledgerUpgradeBaseReserve'], modern: 'BaseReserve', arm: 'newBaseReserve', convert: id },
    { switchValues: ['ledgerUpgradeFlags'], modern: 'Flags', arm: 'newFlags', convert: id },
    { switchValues: ['ledgerUpgradeConfig'], modern: 'Config', arm: 'newConfig', convert: structConverter(_ConfigUpgradeSetKey) },
    { switchValues: ['ledgerUpgradeMaxSorobanTxSetSize'], modern: 'MaxSorobanTxSetSize', arm: 'newMaxSorobanTxSetSize', convert: id },
  ],
});
export const LedgerUpgrade = _LedgerUpgrade as unknown as {
  ledgerUpgradeVersion(value: Uint32): LedgerUpgrade;
  ledgerUpgradeBaseFee(value: Uint32): LedgerUpgrade;
  ledgerUpgradeMaxTxSetSize(value: Uint32): LedgerUpgrade;
  ledgerUpgradeBaseReserve(value: Uint32): LedgerUpgrade;
  ledgerUpgradeFlags(value: Uint32): LedgerUpgrade;
  ledgerUpgradeConfig(value: ConfigUpgradeSetKey): LedgerUpgrade;
  ledgerUpgradeMaxSorobanTxSetSize(value: Uint32): LedgerUpgrade;
  read(io: Buffer): LedgerUpgrade;
  write(value: LedgerUpgrade, io: Buffer): void;
  isValid(value: LedgerUpgrade): boolean;
  toXDR(value: LedgerUpgrade): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerUpgrade;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerUpgrade;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface UpgradeEntryMeta {
  upgrade(value?: LedgerUpgrade): LedgerUpgrade;
  changes(value?: LedgerEntryChanges): LedgerEntryChanges;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _UpgradeEntryMeta = createCompatStruct({
  codec: modern.UpgradeEntryMeta,
  fields: [
    { name: 'upgrade', modernName: 'upgrade', convert: unionConverter(_LedgerUpgrade) },
    { name: 'changes', modernName: 'changes', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
  ],
});
export const UpgradeEntryMeta = _UpgradeEntryMeta as unknown as {
  new(attributes: { upgrade: LedgerUpgrade; changes: LedgerEntryChanges }): UpgradeEntryMeta;
  read(io: Buffer): UpgradeEntryMeta;
  write(value: UpgradeEntryMeta, io: Buffer): void;
  isValid(value: UpgradeEntryMeta): boolean;
  toXDR(value: UpgradeEntryMeta): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): UpgradeEntryMeta;
  fromXDR(input: string, format: 'hex' | 'base64'): UpgradeEntryMeta;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpQuorumSet {
  threshold(value?: Uint32): Uint32;
  validators(value?: NodeId[]): NodeId[];
  innerSets(value?: ScpQuorumSet[]): ScpQuorumSet[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpQuorumSet = createCompatStruct({
  codec: modern.SCPQuorumSet,
  fields: [
    { name: 'threshold', modernName: 'threshold', convert: id },
    { name: 'validators', modernName: 'validators', convert: arrayConverter(unionConverter(_PublicKey)) },
    { name: 'innerSets', modernName: 'innerSets', convert: arrayConverter(lazyConverter(() => structConverter(_ScpQuorumSet))) },
  ],
});
export const ScpQuorumSet = _ScpQuorumSet as unknown as {
  new(attributes: { threshold: Uint32; validators: NodeId[]; innerSets: ScpQuorumSet[] }): ScpQuorumSet;
  read(io: Buffer): ScpQuorumSet;
  write(value: ScpQuorumSet, io: Buffer): void;
  isValid(value: ScpQuorumSet): boolean;
  toXDR(value: ScpQuorumSet): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpQuorumSet;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpQuorumSet;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpStatementType {
  readonly name: 'scpStPrepare' | 'scpStConfirm' | 'scpStExternalize' | 'scpStNominate';
  readonly value: 0 | 1 | 2 | 3;
}
const _ScpStatementType = createCompatEnum({
  codec: modern.SCPStatementType,
  members: [
    { compat: 'scpStPrepare', modern: 'Prepare', value: 0 },
    { compat: 'scpStConfirm', modern: 'Confirm', value: 1 },
    { compat: 'scpStExternalize', modern: 'Externalize', value: 2 },
    { compat: 'scpStNominate', modern: 'Nominate', value: 3 },
  ],
});
export const ScpStatementType = _ScpStatementType as unknown as {
  scpStPrepare(): ScpStatementType;
  scpStConfirm(): ScpStatementType;
  scpStExternalize(): ScpStatementType;
  scpStNominate(): ScpStatementType;
};

export type Value = Buffer;
export const Value = createCompatTypedef({ codec: modern.Value, convert: id });

export interface ScpBallot {
  counter(value?: Uint32): Uint32;
  value(value?: Value): Value;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpBallot = createCompatStruct({
  codec: modern.SCPBallot,
  fields: [
    { name: 'counter', modernName: 'counter', convert: id },
    { name: 'value', modernName: 'value', convert: id },
  ],
});
export const ScpBallot = _ScpBallot as unknown as {
  new(attributes: { counter: Uint32; value: Value }): ScpBallot;
  read(io: Buffer): ScpBallot;
  write(value: ScpBallot, io: Buffer): void;
  isValid(value: ScpBallot): boolean;
  toXDR(value: ScpBallot): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpBallot;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpBallot;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpStatementPrepare {
  quorumSetHash(value?: Hash): Hash;
  ballot(value?: ScpBallot): ScpBallot;
  prepared(value?: null | ScpBallot): null | ScpBallot;
  preparedPrime(value?: null | ScpBallot): null | ScpBallot;
  nC(value?: Uint32): Uint32;
  nH(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpStatementPrepare = createCompatStruct({
  codec: modern.SCPStatementPrepare,
  fields: [
    { name: 'quorumSetHash', modernName: 'quorumSetHash', convert: id },
    { name: 'ballot', modernName: 'ballot', convert: structConverter(_ScpBallot) },
    { name: 'prepared', modernName: 'prepared', convert: optionConverter(structConverter(_ScpBallot)) },
    { name: 'preparedPrime', modernName: 'preparedPrime', convert: optionConverter(structConverter(_ScpBallot)) },
    { name: 'nC', modernName: 'nC', convert: id },
    { name: 'nH', modernName: 'nH', convert: id },
  ],
});
export const ScpStatementPrepare = _ScpStatementPrepare as unknown as {
  new(attributes: { quorumSetHash: Hash; ballot: ScpBallot; prepared: null | ScpBallot; preparedPrime: null | ScpBallot; nC: Uint32; nH: Uint32 }): ScpStatementPrepare;
  read(io: Buffer): ScpStatementPrepare;
  write(value: ScpStatementPrepare, io: Buffer): void;
  isValid(value: ScpStatementPrepare): boolean;
  toXDR(value: ScpStatementPrepare): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpStatementPrepare;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpStatementPrepare;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpStatementConfirm {
  ballot(value?: ScpBallot): ScpBallot;
  nPrepared(value?: Uint32): Uint32;
  nCommit(value?: Uint32): Uint32;
  nH(value?: Uint32): Uint32;
  quorumSetHash(value?: Hash): Hash;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpStatementConfirm = createCompatStruct({
  codec: modern.SCPStatementConfirm,
  fields: [
    { name: 'ballot', modernName: 'ballot', convert: structConverter(_ScpBallot) },
    { name: 'nPrepared', modernName: 'nPrepared', convert: id },
    { name: 'nCommit', modernName: 'nCommit', convert: id },
    { name: 'nH', modernName: 'nH', convert: id },
    { name: 'quorumSetHash', modernName: 'quorumSetHash', convert: id },
  ],
});
export const ScpStatementConfirm = _ScpStatementConfirm as unknown as {
  new(attributes: { ballot: ScpBallot; nPrepared: Uint32; nCommit: Uint32; nH: Uint32; quorumSetHash: Hash }): ScpStatementConfirm;
  read(io: Buffer): ScpStatementConfirm;
  write(value: ScpStatementConfirm, io: Buffer): void;
  isValid(value: ScpStatementConfirm): boolean;
  toXDR(value: ScpStatementConfirm): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpStatementConfirm;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpStatementConfirm;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpStatementExternalize {
  commit(value?: ScpBallot): ScpBallot;
  nH(value?: Uint32): Uint32;
  commitQuorumSetHash(value?: Hash): Hash;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpStatementExternalize = createCompatStruct({
  codec: modern.SCPStatementExternalize,
  fields: [
    { name: 'commit', modernName: 'commit', convert: structConverter(_ScpBallot) },
    { name: 'nH', modernName: 'nH', convert: id },
    { name: 'commitQuorumSetHash', modernName: 'commitQuorumSetHash', convert: id },
  ],
});
export const ScpStatementExternalize = _ScpStatementExternalize as unknown as {
  new(attributes: { commit: ScpBallot; nH: Uint32; commitQuorumSetHash: Hash }): ScpStatementExternalize;
  read(io: Buffer): ScpStatementExternalize;
  write(value: ScpStatementExternalize, io: Buffer): void;
  isValid(value: ScpStatementExternalize): boolean;
  toXDR(value: ScpStatementExternalize): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpStatementExternalize;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpStatementExternalize;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpNomination {
  quorumSetHash(value?: Hash): Hash;
  votes(value?: Value[]): Value[];
  accepted(value?: Value[]): Value[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpNomination = createCompatStruct({
  codec: modern.SCPNomination,
  fields: [
    { name: 'quorumSetHash', modernName: 'quorumSetHash', convert: id },
    { name: 'votes', modernName: 'votes', convert: arrayConverter(id) },
    { name: 'accepted', modernName: 'accepted', convert: arrayConverter(id) },
  ],
});
export const ScpNomination = _ScpNomination as unknown as {
  new(attributes: { quorumSetHash: Hash; votes: Value[]; accepted: Value[] }): ScpNomination;
  read(io: Buffer): ScpNomination;
  write(value: ScpNomination, io: Buffer): void;
  isValid(value: ScpNomination): boolean;
  toXDR(value: ScpNomination): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpNomination;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpNomination;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpStatementPledges {
  switch(): ScpStatementType;
  prepare(value?: ScpStatementPrepare): ScpStatementPrepare;
  confirm(value?: ScpStatementConfirm): ScpStatementConfirm;
  externalize(value?: ScpStatementExternalize): ScpStatementExternalize;
  nominate(value?: ScpNomination): ScpNomination;
  value(): ScpStatementPrepare | ScpStatementConfirm | ScpStatementExternalize | ScpNomination;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpStatementPledges = createCompatUnion({
  codec: modern.SCPStatementPledges,
  switchEnum: _ScpStatementType,
  arms: [
    { switchValues: ['scpStPrepare'], modern: 'Prepare', arm: 'prepare', convert: id },
    { switchValues: ['scpStConfirm'], modern: 'Confirm', arm: 'confirm', convert: id },
    { switchValues: ['scpStExternalize'], modern: 'Externalize', arm: 'externalize', convert: id },
    { switchValues: ['scpStNominate'], modern: 'Nominate', arm: 'nominate', convert: structConverter(_ScpNomination) },
  ],
});
export const ScpStatementPledges = _ScpStatementPledges as unknown as {
  scpStPrepare(value: ScpStatementPrepare): ScpStatementPledges;
  scpStConfirm(value: ScpStatementConfirm): ScpStatementPledges;
  scpStExternalize(value: ScpStatementExternalize): ScpStatementPledges;
  scpStNominate(value: ScpNomination): ScpStatementPledges;
  read(io: Buffer): ScpStatementPledges;
  write(value: ScpStatementPledges, io: Buffer): void;
  isValid(value: ScpStatementPledges): boolean;
  toXDR(value: ScpStatementPledges): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpStatementPledges;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpStatementPledges;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpStatement {
  nodeId(value?: NodeId): NodeId;
  slotIndex(value?: Uint64): Uint64;
  pledges(value?: ScpStatementPledges): ScpStatementPledges;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpStatement = createCompatStruct({
  codec: modern.SCPStatement,
  fields: [
    { name: 'nodeId', modernName: 'nodeID', convert: unionConverter(_PublicKey) },
    { name: 'slotIndex', modernName: 'slotIndex', convert: uint64Conv },
    { name: 'pledges', modernName: 'pledges', convert: id },
  ],
});
export const ScpStatement = _ScpStatement as unknown as {
  new(attributes: { nodeId: NodeId; slotIndex: Uint64; pledges: ScpStatementPledges }): ScpStatement;
  read(io: Buffer): ScpStatement;
  write(value: ScpStatement, io: Buffer): void;
  isValid(value: ScpStatement): boolean;
  toXDR(value: ScpStatement): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpStatement;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpStatement;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpEnvelope {
  statement(value?: ScpStatement): ScpStatement;
  signature(value?: Signature): Signature;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpEnvelope = createCompatStruct({
  codec: modern.SCPEnvelope,
  fields: [
    { name: 'statement', modernName: 'statement', convert: structConverter(_ScpStatement) },
    { name: 'signature', modernName: 'signature', convert: id },
  ],
});
export const ScpEnvelope = _ScpEnvelope as unknown as {
  new(attributes: { statement: ScpStatement; signature: Signature }): ScpEnvelope;
  read(io: Buffer): ScpEnvelope;
  write(value: ScpEnvelope, io: Buffer): void;
  isValid(value: ScpEnvelope): boolean;
  toXDR(value: ScpEnvelope): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpEnvelope;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpEnvelope;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerScpMessages {
  ledgerSeq(value?: Uint32): Uint32;
  messages(value?: ScpEnvelope[]): ScpEnvelope[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerScpMessages = createCompatStruct({
  codec: modern.LedgerSCPMessages,
  fields: [
    { name: 'ledgerSeq', modernName: 'ledgerSeq', convert: id },
    { name: 'messages', modernName: 'messages', convert: arrayConverter(structConverter(_ScpEnvelope)) },
  ],
});
export const LedgerScpMessages = _LedgerScpMessages as unknown as {
  new(attributes: { ledgerSeq: Uint32; messages: ScpEnvelope[] }): LedgerScpMessages;
  read(io: Buffer): LedgerScpMessages;
  write(value: LedgerScpMessages, io: Buffer): void;
  isValid(value: LedgerScpMessages): boolean;
  toXDR(value: LedgerScpMessages): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerScpMessages;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerScpMessages;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpHistoryEntryV0 {
  quorumSets(value?: ScpQuorumSet[]): ScpQuorumSet[];
  ledgerMessages(value?: LedgerScpMessages): LedgerScpMessages;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpHistoryEntryV0 = createCompatStruct({
  codec: modern.SCPHistoryEntryV0,
  fields: [
    { name: 'quorumSets', modernName: 'quorumSets', convert: arrayConverter(lazyConverter(() => structConverter(_ScpQuorumSet))) },
    { name: 'ledgerMessages', modernName: 'ledgerMessages', convert: structConverter(_LedgerScpMessages) },
  ],
});
export const ScpHistoryEntryV0 = _ScpHistoryEntryV0 as unknown as {
  new(attributes: { quorumSets: ScpQuorumSet[]; ledgerMessages: LedgerScpMessages }): ScpHistoryEntryV0;
  read(io: Buffer): ScpHistoryEntryV0;
  write(value: ScpHistoryEntryV0, io: Buffer): void;
  isValid(value: ScpHistoryEntryV0): boolean;
  toXDR(value: ScpHistoryEntryV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpHistoryEntryV0;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpHistoryEntryV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ScpHistoryEntry {
  switch(): number;
  v0(value?: ScpHistoryEntryV0): ScpHistoryEntryV0;
  value(): ScpHistoryEntryV0;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ScpHistoryEntry = createCompatUnion({
  codec: modern.SCPHistoryEntry,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0, arm: 'v0', convert: structConverter(_ScpHistoryEntryV0) },
  ],
});
export const ScpHistoryEntry = _ScpHistoryEntry as unknown as {
  0(value: ScpHistoryEntryV0): ScpHistoryEntry;
  read(io: Buffer): ScpHistoryEntry;
  write(value: ScpHistoryEntry, io: Buffer): void;
  isValid(value: ScpHistoryEntry): boolean;
  toXDR(value: ScpHistoryEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ScpHistoryEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): ScpHistoryEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerCloseMetaV0 {
  ledgerHeader(value?: LedgerHeaderHistoryEntry): LedgerHeaderHistoryEntry;
  txSet(value?: TransactionSet): TransactionSet;
  txProcessing(value?: TransactionResultMeta[]): TransactionResultMeta[];
  upgradesProcessing(value?: UpgradeEntryMeta[]): UpgradeEntryMeta[];
  scpInfo(value?: ScpHistoryEntry[]): ScpHistoryEntry[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerCloseMetaV0 = createCompatStruct({
  codec: modern.LedgerCloseMetaV0,
  fields: [
    { name: 'ledgerHeader', modernName: 'ledgerHeader', convert: structConverter(_LedgerHeaderHistoryEntry) },
    { name: 'txSet', modernName: 'txSet', convert: structConverter(_TransactionSet) },
    { name: 'txProcessing', modernName: 'txProcessing', convert: arrayConverter(structConverter(_TransactionResultMeta)) },
    { name: 'upgradesProcessing', modernName: 'upgradesProcessing', convert: arrayConverter(structConverter(_UpgradeEntryMeta)) },
    { name: 'scpInfo', modernName: 'scpInfo', convert: arrayConverter(unionConverter(_ScpHistoryEntry)) },
  ],
});
export const LedgerCloseMetaV0 = _LedgerCloseMetaV0 as unknown as {
  new(attributes: { ledgerHeader: LedgerHeaderHistoryEntry; txSet: TransactionSet; txProcessing: TransactionResultMeta[]; upgradesProcessing: UpgradeEntryMeta[]; scpInfo: ScpHistoryEntry[] }): LedgerCloseMetaV0;
  read(io: Buffer): LedgerCloseMetaV0;
  write(value: LedgerCloseMetaV0, io: Buffer): void;
  isValid(value: LedgerCloseMetaV0): boolean;
  toXDR(value: LedgerCloseMetaV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerCloseMetaV0;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerCloseMetaV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerCloseMetaExtV1 {
  ext(value?: ExtensionPoint): ExtensionPoint;
  sorobanFeeWrite1Kb(value?: Int64): Int64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerCloseMetaExtV1 = createCompatStruct({
  codec: modern.LedgerCloseMetaExtV1,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'sorobanFeeWrite1Kb', modernName: 'sorobanFeeWrite1KB', convert: int64Conv },
  ],
});
export const LedgerCloseMetaExtV1 = _LedgerCloseMetaExtV1 as unknown as {
  new(attributes: { ext: ExtensionPoint; sorobanFeeWrite1Kb: Int64 }): LedgerCloseMetaExtV1;
  read(io: Buffer): LedgerCloseMetaExtV1;
  write(value: LedgerCloseMetaExtV1, io: Buffer): void;
  isValid(value: LedgerCloseMetaExtV1): boolean;
  toXDR(value: LedgerCloseMetaExtV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerCloseMetaExtV1;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerCloseMetaExtV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerCloseMetaExt {
  switch(): number;
  v1(value?: LedgerCloseMetaExtV1): LedgerCloseMetaExtV1;
  value(): LedgerCloseMetaExtV1 | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerCloseMetaExt = createCompatUnion({
  codec: modern.LedgerCloseMetaExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_LedgerCloseMetaExtV1) },
  ],
});
export const LedgerCloseMetaExt = _LedgerCloseMetaExt as unknown as {
  0(): LedgerCloseMetaExt;
  1(value: LedgerCloseMetaExtV1): LedgerCloseMetaExt;
  read(io: Buffer): LedgerCloseMetaExt;
  write(value: LedgerCloseMetaExt, io: Buffer): void;
  isValid(value: LedgerCloseMetaExt): boolean;
  toXDR(value: LedgerCloseMetaExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerCloseMetaExt;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerCloseMetaExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TxSetComponentType {
  readonly name: 'txsetCompTxsMaybeDiscountedFee';
  readonly value: 0;
}
const _TxSetComponentType = createCompatEnum({
  codec: modern.TxSetComponentType,
  members: [
    { compat: 'txsetCompTxsMaybeDiscountedFee', modern: 'TxsetCompTxsMaybeDiscountedFee', value: 0 },
  ],
});
export const TxSetComponentType = _TxSetComponentType as unknown as {
  txsetCompTxsMaybeDiscountedFee(): TxSetComponentType;
};

export interface TxSetComponentTxsMaybeDiscountedFee {
  baseFee(value?: null | Int64): null | Int64;
  txes(value?: TransactionEnvelope[]): TransactionEnvelope[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TxSetComponentTxsMaybeDiscountedFee = createCompatStruct({
  codec: modern.TxSetComponentTxsMaybeDiscountedFee,
  fields: [
    { name: 'baseFee', modernName: 'baseFee', convert: optionConverter(int64Conv) },
    { name: 'txes', modernName: 'txs', convert: arrayConverter(unionConverter(_TransactionEnvelope)) },
  ],
});
export const TxSetComponentTxsMaybeDiscountedFee = _TxSetComponentTxsMaybeDiscountedFee as unknown as {
  new(attributes: { baseFee: null | Int64; txes: TransactionEnvelope[] }): TxSetComponentTxsMaybeDiscountedFee;
  read(io: Buffer): TxSetComponentTxsMaybeDiscountedFee;
  write(value: TxSetComponentTxsMaybeDiscountedFee, io: Buffer): void;
  isValid(value: TxSetComponentTxsMaybeDiscountedFee): boolean;
  toXDR(value: TxSetComponentTxsMaybeDiscountedFee): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TxSetComponentTxsMaybeDiscountedFee;
  fromXDR(input: string, format: 'hex' | 'base64'): TxSetComponentTxsMaybeDiscountedFee;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TxSetComponent {
  switch(): TxSetComponentType;
  txsMaybeDiscountedFee(value?: TxSetComponentTxsMaybeDiscountedFee): TxSetComponentTxsMaybeDiscountedFee;
  value(): TxSetComponentTxsMaybeDiscountedFee;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TxSetComponent = createCompatUnion({
  codec: modern.TxSetComponent,
  switchEnum: _TxSetComponentType,
  arms: [
    { switchValues: ['txsetCompTxsMaybeDiscountedFee'], modern: 'TxsetCompTxsMaybeDiscountedFee', arm: 'txsMaybeDiscountedFee', convert: id },
  ],
});
export const TxSetComponent = _TxSetComponent as unknown as {
  txsetCompTxsMaybeDiscountedFee(value: TxSetComponentTxsMaybeDiscountedFee): TxSetComponent;
  read(io: Buffer): TxSetComponent;
  write(value: TxSetComponent, io: Buffer): void;
  isValid(value: TxSetComponent): boolean;
  toXDR(value: TxSetComponent): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TxSetComponent;
  fromXDR(input: string, format: 'hex' | 'base64'): TxSetComponent;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type DependentTxCluster = TransactionEnvelope[];
export const DependentTxCluster = createCompatTypedef({ codec: modern.DependentTxCluster, convert: arrayConverter(unionConverter(_TransactionEnvelope)) });

export type ParallelTxExecutionStage = DependentTxCluster[];
export const ParallelTxExecutionStage = createCompatTypedef({ codec: modern.ParallelTxExecutionStage, convert: arrayConverter(arrayConverter(unionConverter(_TransactionEnvelope))) });

export interface ParallelTxsComponent {
  baseFee(value?: null | Int64): null | Int64;
  executionStages(value?: ParallelTxExecutionStage[]): ParallelTxExecutionStage[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ParallelTxsComponent = createCompatStruct({
  codec: modern.ParallelTxsComponent,
  fields: [
    { name: 'baseFee', modernName: 'baseFee', convert: optionConverter(int64Conv) },
    { name: 'executionStages', modernName: 'executionStages', convert: arrayConverter(arrayConverter(arrayConverter(unionConverter(_TransactionEnvelope)))) },
  ],
});
export const ParallelTxsComponent = _ParallelTxsComponent as unknown as {
  new(attributes: { baseFee: null | Int64; executionStages: ParallelTxExecutionStage[] }): ParallelTxsComponent;
  read(io: Buffer): ParallelTxsComponent;
  write(value: ParallelTxsComponent, io: Buffer): void;
  isValid(value: ParallelTxsComponent): boolean;
  toXDR(value: ParallelTxsComponent): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ParallelTxsComponent;
  fromXDR(input: string, format: 'hex' | 'base64'): ParallelTxsComponent;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionPhase {
  switch(): number;
  v0Components(value?: TxSetComponent[]): TxSetComponent[];
  parallelTxsComponent(value?: ParallelTxsComponent): ParallelTxsComponent;
  value(): TxSetComponent[] | ParallelTxsComponent;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionPhase = createCompatUnion({
  codec: modern.TransactionPhase,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0, arm: 'v0Components', convert: arrayConverter(unionConverter(_TxSetComponent)) },
    { switchValues: [1], modern: 1, arm: 'parallelTxsComponent', convert: structConverter(_ParallelTxsComponent) },
  ],
});
export const TransactionPhase = _TransactionPhase as unknown as {
  0(value: TxSetComponent[]): TransactionPhase;
  1(value: ParallelTxsComponent): TransactionPhase;
  read(io: Buffer): TransactionPhase;
  write(value: TransactionPhase, io: Buffer): void;
  isValid(value: TransactionPhase): boolean;
  toXDR(value: TransactionPhase): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionPhase;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionPhase;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionSetV1 {
  previousLedgerHash(value?: Hash): Hash;
  phases(value?: TransactionPhase[]): TransactionPhase[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionSetV1 = createCompatStruct({
  codec: modern.TransactionSetV1,
  fields: [
    { name: 'previousLedgerHash', modernName: 'previousLedgerHash', convert: id },
    { name: 'phases', modernName: 'phases', convert: arrayConverter(unionConverter(_TransactionPhase)) },
  ],
});
export const TransactionSetV1 = _TransactionSetV1 as unknown as {
  new(attributes: { previousLedgerHash: Hash; phases: TransactionPhase[] }): TransactionSetV1;
  read(io: Buffer): TransactionSetV1;
  write(value: TransactionSetV1, io: Buffer): void;
  isValid(value: TransactionSetV1): boolean;
  toXDR(value: TransactionSetV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionSetV1;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionSetV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface GeneralizedTransactionSet {
  switch(): number;
  v1TxSet(value?: TransactionSetV1): TransactionSetV1;
  value(): TransactionSetV1;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _GeneralizedTransactionSet = createCompatUnion({
  codec: modern.GeneralizedTransactionSet,
  switchEnum: null,
  arms: [
    { switchValues: [1], modern: 1, arm: 'v1TxSet', convert: structConverter(_TransactionSetV1) },
  ],
});
export const GeneralizedTransactionSet = _GeneralizedTransactionSet as unknown as {
  1(value: TransactionSetV1): GeneralizedTransactionSet;
  read(io: Buffer): GeneralizedTransactionSet;
  write(value: GeneralizedTransactionSet, io: Buffer): void;
  isValid(value: GeneralizedTransactionSet): boolean;
  toXDR(value: GeneralizedTransactionSet): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): GeneralizedTransactionSet;
  fromXDR(input: string, format: 'hex' | 'base64'): GeneralizedTransactionSet;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerCloseMetaV1 {
  ext(value?: LedgerCloseMetaExt): LedgerCloseMetaExt;
  ledgerHeader(value?: LedgerHeaderHistoryEntry): LedgerHeaderHistoryEntry;
  txSet(value?: GeneralizedTransactionSet): GeneralizedTransactionSet;
  txProcessing(value?: TransactionResultMeta[]): TransactionResultMeta[];
  upgradesProcessing(value?: UpgradeEntryMeta[]): UpgradeEntryMeta[];
  scpInfo(value?: ScpHistoryEntry[]): ScpHistoryEntry[];
  totalByteSizeOfLiveSorobanState(value?: Uint64): Uint64;
  evictedKeys(value?: LedgerKey[]): LedgerKey[];
  unused(value?: LedgerEntry[]): LedgerEntry[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerCloseMetaV1 = createCompatStruct({
  codec: modern.LedgerCloseMetaV1,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_LedgerCloseMetaExt) },
    { name: 'ledgerHeader', modernName: 'ledgerHeader', convert: structConverter(_LedgerHeaderHistoryEntry) },
    { name: 'txSet', modernName: 'txSet', convert: unionConverter(_GeneralizedTransactionSet) },
    { name: 'txProcessing', modernName: 'txProcessing', convert: arrayConverter(structConverter(_TransactionResultMeta)) },
    { name: 'upgradesProcessing', modernName: 'upgradesProcessing', convert: arrayConverter(structConverter(_UpgradeEntryMeta)) },
    { name: 'scpInfo', modernName: 'scpInfo', convert: arrayConverter(unionConverter(_ScpHistoryEntry)) },
    { name: 'totalByteSizeOfLiveSorobanState', modernName: 'totalByteSizeOfLiveSorobanState', convert: uint64Conv },
    { name: 'evictedKeys', modernName: 'evictedKeys', convert: arrayConverter(unionConverter(_LedgerKey)) },
    { name: 'unused', modernName: 'unused', convert: arrayConverter(structConverter(_LedgerEntry)) },
  ],
});
export const LedgerCloseMetaV1 = _LedgerCloseMetaV1 as unknown as {
  new(attributes: { ext: LedgerCloseMetaExt; ledgerHeader: LedgerHeaderHistoryEntry; txSet: GeneralizedTransactionSet; txProcessing: TransactionResultMeta[]; upgradesProcessing: UpgradeEntryMeta[]; scpInfo: ScpHistoryEntry[]; totalByteSizeOfLiveSorobanState: Uint64; evictedKeys: LedgerKey[]; unused: LedgerEntry[] }): LedgerCloseMetaV1;
  read(io: Buffer): LedgerCloseMetaV1;
  write(value: LedgerCloseMetaV1, io: Buffer): void;
  isValid(value: LedgerCloseMetaV1): boolean;
  toXDR(value: LedgerCloseMetaV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerCloseMetaV1;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerCloseMetaV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionResultMetaV1 {
  ext(value?: ExtensionPoint): ExtensionPoint;
  result(value?: TransactionResultPair): TransactionResultPair;
  feeProcessing(value?: LedgerEntryChanges): LedgerEntryChanges;
  txApplyProcessing(value?: TransactionMeta): TransactionMeta;
  postTxApplyFeeProcessing(value?: LedgerEntryChanges): LedgerEntryChanges;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionResultMetaV1 = createCompatStruct({
  codec: modern.TransactionResultMetaV1,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_ExtensionPoint) },
    { name: 'result', modernName: 'result', convert: structConverter(_TransactionResultPair) },
    { name: 'feeProcessing', modernName: 'feeProcessing', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
    { name: 'txApplyProcessing', modernName: 'txApplyProcessing', convert: unionConverter(_TransactionMeta) },
    { name: 'postTxApplyFeeProcessing', modernName: 'postTxApplyFeeProcessing', convert: arrayConverter(unionConverter(_LedgerEntryChange)) },
  ],
});
export const TransactionResultMetaV1 = _TransactionResultMetaV1 as unknown as {
  new(attributes: { ext: ExtensionPoint; result: TransactionResultPair; feeProcessing: LedgerEntryChanges; txApplyProcessing: TransactionMeta; postTxApplyFeeProcessing: LedgerEntryChanges }): TransactionResultMetaV1;
  read(io: Buffer): TransactionResultMetaV1;
  write(value: TransactionResultMetaV1, io: Buffer): void;
  isValid(value: TransactionResultMetaV1): boolean;
  toXDR(value: TransactionResultMetaV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionResultMetaV1;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionResultMetaV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerCloseMetaV2 {
  ext(value?: LedgerCloseMetaExt): LedgerCloseMetaExt;
  ledgerHeader(value?: LedgerHeaderHistoryEntry): LedgerHeaderHistoryEntry;
  txSet(value?: GeneralizedTransactionSet): GeneralizedTransactionSet;
  txProcessing(value?: TransactionResultMetaV1[]): TransactionResultMetaV1[];
  upgradesProcessing(value?: UpgradeEntryMeta[]): UpgradeEntryMeta[];
  scpInfo(value?: ScpHistoryEntry[]): ScpHistoryEntry[];
  totalByteSizeOfLiveSorobanState(value?: Uint64): Uint64;
  evictedKeys(value?: LedgerKey[]): LedgerKey[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerCloseMetaV2 = createCompatStruct({
  codec: modern.LedgerCloseMetaV2,
  fields: [
    { name: 'ext', modernName: 'ext', convert: unionConverter(_LedgerCloseMetaExt) },
    { name: 'ledgerHeader', modernName: 'ledgerHeader', convert: structConverter(_LedgerHeaderHistoryEntry) },
    { name: 'txSet', modernName: 'txSet', convert: unionConverter(_GeneralizedTransactionSet) },
    { name: 'txProcessing', modernName: 'txProcessing', convert: arrayConverter(structConverter(_TransactionResultMetaV1)) },
    { name: 'upgradesProcessing', modernName: 'upgradesProcessing', convert: arrayConverter(structConverter(_UpgradeEntryMeta)) },
    { name: 'scpInfo', modernName: 'scpInfo', convert: arrayConverter(unionConverter(_ScpHistoryEntry)) },
    { name: 'totalByteSizeOfLiveSorobanState', modernName: 'totalByteSizeOfLiveSorobanState', convert: uint64Conv },
    { name: 'evictedKeys', modernName: 'evictedKeys', convert: arrayConverter(unionConverter(_LedgerKey)) },
  ],
});
export const LedgerCloseMetaV2 = _LedgerCloseMetaV2 as unknown as {
  new(attributes: { ext: LedgerCloseMetaExt; ledgerHeader: LedgerHeaderHistoryEntry; txSet: GeneralizedTransactionSet; txProcessing: TransactionResultMetaV1[]; upgradesProcessing: UpgradeEntryMeta[]; scpInfo: ScpHistoryEntry[]; totalByteSizeOfLiveSorobanState: Uint64; evictedKeys: LedgerKey[] }): LedgerCloseMetaV2;
  read(io: Buffer): LedgerCloseMetaV2;
  write(value: LedgerCloseMetaV2, io: Buffer): void;
  isValid(value: LedgerCloseMetaV2): boolean;
  toXDR(value: LedgerCloseMetaV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerCloseMetaV2;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerCloseMetaV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerCloseMeta {
  switch(): number;
  v0(value?: LedgerCloseMetaV0): LedgerCloseMetaV0;
  v1(value?: LedgerCloseMetaV1): LedgerCloseMetaV1;
  v2(value?: LedgerCloseMetaV2): LedgerCloseMetaV2;
  value(): LedgerCloseMetaV0 | LedgerCloseMetaV1 | LedgerCloseMetaV2;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerCloseMeta = createCompatUnion({
  codec: modern.LedgerCloseMeta,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0, arm: 'v0', convert: structConverter(_LedgerCloseMetaV0) },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_LedgerCloseMetaV1) },
    { switchValues: [2], modern: 2, arm: 'v2', convert: structConverter(_LedgerCloseMetaV2) },
  ],
});
export const LedgerCloseMeta = _LedgerCloseMeta as unknown as {
  0(value: LedgerCloseMetaV0): LedgerCloseMeta;
  1(value: LedgerCloseMetaV1): LedgerCloseMeta;
  2(value: LedgerCloseMetaV2): LedgerCloseMeta;
  read(io: Buffer): LedgerCloseMeta;
  write(value: LedgerCloseMeta, io: Buffer): void;
  isValid(value: LedgerCloseMeta): boolean;
  toXDR(value: LedgerCloseMeta): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerCloseMeta;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerCloseMeta;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface LedgerCloseMetaBatch {
  startSequence(value?: Uint32): Uint32;
  endSequence(value?: Uint32): Uint32;
  ledgerCloseMeta(value?: LedgerCloseMeta[]): LedgerCloseMeta[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _LedgerCloseMetaBatch = createCompatStruct({
  codec: modern.LedgerCloseMetaBatch,
  fields: [
    { name: 'startSequence', modernName: 'startSequence', convert: id },
    { name: 'endSequence', modernName: 'endSequence', convert: id },
    { name: 'ledgerCloseMeta', modernName: 'ledgerCloseMetas', convert: arrayConverter(unionConverter(_LedgerCloseMeta)) },
  ],
});
export const LedgerCloseMetaBatch = _LedgerCloseMetaBatch as unknown as {
  new(attributes: { startSequence: Uint32; endSequence: Uint32; ledgerCloseMeta: LedgerCloseMeta[] }): LedgerCloseMetaBatch;
  read(io: Buffer): LedgerCloseMetaBatch;
  write(value: LedgerCloseMetaBatch, io: Buffer): void;
  isValid(value: LedgerCloseMetaBatch): boolean;
  toXDR(value: LedgerCloseMetaBatch): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): LedgerCloseMetaBatch;
  fromXDR(input: string, format: 'hex' | 'base64'): LedgerCloseMetaBatch;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface StoredTransactionSet {
  switch(): number;
  txSet(value?: TransactionSet): TransactionSet;
  generalizedTxSet(value?: GeneralizedTransactionSet): GeneralizedTransactionSet;
  value(): TransactionSet | GeneralizedTransactionSet;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _StoredTransactionSet = createCompatUnion({
  codec: modern.StoredTransactionSet,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0, arm: 'txSet', convert: structConverter(_TransactionSet) },
    { switchValues: [1], modern: 1, arm: 'generalizedTxSet', convert: unionConverter(_GeneralizedTransactionSet) },
  ],
});
export const StoredTransactionSet = _StoredTransactionSet as unknown as {
  0(value: TransactionSet): StoredTransactionSet;
  1(value: GeneralizedTransactionSet): StoredTransactionSet;
  read(io: Buffer): StoredTransactionSet;
  write(value: StoredTransactionSet, io: Buffer): void;
  isValid(value: StoredTransactionSet): boolean;
  toXDR(value: StoredTransactionSet): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): StoredTransactionSet;
  fromXDR(input: string, format: 'hex' | 'base64'): StoredTransactionSet;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface StoredDebugTransactionSet {
  txSet(value?: StoredTransactionSet): StoredTransactionSet;
  ledgerSeq(value?: Uint32): Uint32;
  scpValue(value?: StellarValue): StellarValue;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _StoredDebugTransactionSet = createCompatStruct({
  codec: modern.StoredDebugTransactionSet,
  fields: [
    { name: 'txSet', modernName: 'txSet', convert: unionConverter(_StoredTransactionSet) },
    { name: 'ledgerSeq', modernName: 'ledgerSeq', convert: id },
    { name: 'scpValue', modernName: 'scpValue', convert: structConverter(_StellarValue) },
  ],
});
export const StoredDebugTransactionSet = _StoredDebugTransactionSet as unknown as {
  new(attributes: { txSet: StoredTransactionSet; ledgerSeq: Uint32; scpValue: StellarValue }): StoredDebugTransactionSet;
  read(io: Buffer): StoredDebugTransactionSet;
  write(value: StoredDebugTransactionSet, io: Buffer): void;
  isValid(value: StoredDebugTransactionSet): boolean;
  toXDR(value: StoredDebugTransactionSet): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): StoredDebugTransactionSet;
  fromXDR(input: string, format: 'hex' | 'base64'): StoredDebugTransactionSet;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PersistedScpStateV0 {
  scpEnvelopes(value?: ScpEnvelope[]): ScpEnvelope[];
  quorumSets(value?: ScpQuorumSet[]): ScpQuorumSet[];
  txSets(value?: StoredTransactionSet[]): StoredTransactionSet[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PersistedScpStateV0 = createCompatStruct({
  codec: modern.PersistedSCPStateV0,
  fields: [
    { name: 'scpEnvelopes', modernName: 'scpEnvelopes', convert: arrayConverter(structConverter(_ScpEnvelope)) },
    { name: 'quorumSets', modernName: 'quorumSets', convert: arrayConverter(lazyConverter(() => structConverter(_ScpQuorumSet))) },
    { name: 'txSets', modernName: 'txSets', convert: arrayConverter(unionConverter(_StoredTransactionSet)) },
  ],
});
export const PersistedScpStateV0 = _PersistedScpStateV0 as unknown as {
  new(attributes: { scpEnvelopes: ScpEnvelope[]; quorumSets: ScpQuorumSet[]; txSets: StoredTransactionSet[] }): PersistedScpStateV0;
  read(io: Buffer): PersistedScpStateV0;
  write(value: PersistedScpStateV0, io: Buffer): void;
  isValid(value: PersistedScpStateV0): boolean;
  toXDR(value: PersistedScpStateV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PersistedScpStateV0;
  fromXDR(input: string, format: 'hex' | 'base64'): PersistedScpStateV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PersistedScpStateV1 {
  scpEnvelopes(value?: ScpEnvelope[]): ScpEnvelope[];
  quorumSets(value?: ScpQuorumSet[]): ScpQuorumSet[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PersistedScpStateV1 = createCompatStruct({
  codec: modern.PersistedSCPStateV1,
  fields: [
    { name: 'scpEnvelopes', modernName: 'scpEnvelopes', convert: arrayConverter(structConverter(_ScpEnvelope)) },
    { name: 'quorumSets', modernName: 'quorumSets', convert: arrayConverter(lazyConverter(() => structConverter(_ScpQuorumSet))) },
  ],
});
export const PersistedScpStateV1 = _PersistedScpStateV1 as unknown as {
  new(attributes: { scpEnvelopes: ScpEnvelope[]; quorumSets: ScpQuorumSet[] }): PersistedScpStateV1;
  read(io: Buffer): PersistedScpStateV1;
  write(value: PersistedScpStateV1, io: Buffer): void;
  isValid(value: PersistedScpStateV1): boolean;
  toXDR(value: PersistedScpStateV1): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PersistedScpStateV1;
  fromXDR(input: string, format: 'hex' | 'base64'): PersistedScpStateV1;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PersistedScpState {
  switch(): number;
  v0(value?: PersistedScpStateV0): PersistedScpStateV0;
  v1(value?: PersistedScpStateV1): PersistedScpStateV1;
  value(): PersistedScpStateV0 | PersistedScpStateV1;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PersistedScpState = createCompatUnion({
  codec: modern.PersistedSCPState,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0, arm: 'v0', convert: structConverter(_PersistedScpStateV0) },
    { switchValues: [1], modern: 1, arm: 'v1', convert: structConverter(_PersistedScpStateV1) },
  ],
});
export const PersistedScpState = _PersistedScpState as unknown as {
  0(value: PersistedScpStateV0): PersistedScpState;
  1(value: PersistedScpStateV1): PersistedScpState;
  read(io: Buffer): PersistedScpState;
  write(value: PersistedScpState, io: Buffer): void;
  isValid(value: PersistedScpState): boolean;
  toXDR(value: PersistedScpState): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PersistedScpState;
  fromXDR(input: string, format: 'hex' | 'base64'): PersistedScpState;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ThresholdIndices {
  readonly name: 'thresholdMasterWeight' | 'thresholdLow' | 'thresholdMed' | 'thresholdHigh';
  readonly value: 0 | 1 | 2 | 3;
}
const _ThresholdIndices = createCompatEnum({
  codec: modern.ThresholdIndexes,
  members: [
    { compat: 'thresholdMasterWeight', modern: 'MasterWeight', value: 0 },
    { compat: 'thresholdLow', modern: 'Low', value: 1 },
    { compat: 'thresholdMed', modern: 'Med', value: 2 },
    { compat: 'thresholdHigh', modern: 'High', value: 3 },
  ],
});
export const ThresholdIndices = _ThresholdIndices as unknown as {
  thresholdMasterWeight(): ThresholdIndices;
  thresholdLow(): ThresholdIndices;
  thresholdMed(): ThresholdIndices;
  thresholdHigh(): ThresholdIndices;
};

export interface AccountFlags {
  readonly name: 'authRequiredFlag' | 'authRevocableFlag' | 'authImmutableFlag' | 'authClawbackEnabledFlag';
  readonly value: 1 | 2 | 4 | 8;
}
const _AccountFlags = createCompatEnum({
  codec: modern.AccountFlags,
  members: [
    { compat: 'authRequiredFlag', modern: 'RequiredFlag', value: 1 },
    { compat: 'authRevocableFlag', modern: 'RevocableFlag', value: 2 },
    { compat: 'authImmutableFlag', modern: 'ImmutableFlag', value: 4 },
    { compat: 'authClawbackEnabledFlag', modern: 'ClawbackEnabledFlag', value: 8 },
  ],
});
export const AccountFlags = _AccountFlags as unknown as {
  authRequiredFlag(): AccountFlags;
  authRevocableFlag(): AccountFlags;
  authImmutableFlag(): AccountFlags;
  authClawbackEnabledFlag(): AccountFlags;
};

export const MASK_ACCOUNT_FLAGS = 0x7;

export const MASK_ACCOUNT_FLAGS_V17 = 0xF;

export interface TrustLineFlags {
  readonly name: 'authorizedFlag' | 'authorizedToMaintainLiabilitiesFlag' | 'trustlineClawbackEnabledFlag';
  readonly value: 1 | 2 | 4;
}
const _TrustLineFlags = createCompatEnum({
  codec: modern.TrustLineFlags,
  members: [
    { compat: 'authorizedFlag', modern: 'AuthorizedFlag', value: 1 },
    { compat: 'authorizedToMaintainLiabilitiesFlag', modern: 'AuthorizedToMaintainLiabilitiesFlag', value: 2 },
    { compat: 'trustlineClawbackEnabledFlag', modern: 'TrustlineClawbackEnabledFlag', value: 4 },
  ],
});
export const TrustLineFlags = _TrustLineFlags as unknown as {
  authorizedFlag(): TrustLineFlags;
  authorizedToMaintainLiabilitiesFlag(): TrustLineFlags;
  trustlineClawbackEnabledFlag(): TrustLineFlags;
};

export const MASK_TRUSTLINE_FLAGS = 1;

export const MASK_TRUSTLINE_FLAGS_V13 = 3;

export const MASK_TRUSTLINE_FLAGS_V17 = 7;

export interface OfferEntryFlags {
  readonly name: 'passiveFlag';
  readonly value: 1;
}
const _OfferEntryFlags = createCompatEnum({
  codec: modern.OfferEntryFlags,
  members: [
    { compat: 'passiveFlag', modern: 'PassiveFlag', value: 1 },
  ],
});
export const OfferEntryFlags = _OfferEntryFlags as unknown as {
  passiveFlag(): OfferEntryFlags;
};

export const MASK_OFFERENTRY_FLAGS = 1;

export interface ClaimableBalanceFlags {
  readonly name: 'claimableBalanceClawbackEnabledFlag';
  readonly value: 1;
}
const _ClaimableBalanceFlags = createCompatEnum({
  codec: modern.ClaimableBalanceFlags,
  members: [
    { compat: 'claimableBalanceClawbackEnabledFlag', modern: 'ClaimableBalanceClawbackEnabledFlag', value: 1 },
  ],
});
export const ClaimableBalanceFlags = _ClaimableBalanceFlags as unknown as {
  claimableBalanceClawbackEnabledFlag(): ClaimableBalanceFlags;
};

export const MASK_CLAIMABLE_BALANCE_FLAGS = 0x1;

export interface BucketListType {
  readonly name: 'live' | 'hotArchive';
  readonly value: 0 | 1;
}
const _BucketListType = createCompatEnum({
  codec: modern.BucketListType,
  members: [
    { compat: 'live', modern: 'Live', value: 0 },
    { compat: 'hotArchive', modern: 'HotArchive', value: 1 },
  ],
});
export const BucketListType = _BucketListType as unknown as {
  live(): BucketListType;
  hotArchive(): BucketListType;
};

export interface BucketEntryType {
  readonly name: 'metaentry' | 'liveentry' | 'deadentry' | 'initentry';
  readonly value: -1 | 0 | 1 | 2;
}
const _BucketEntryType = createCompatEnum({
  codec: modern.BucketEntryType,
  members: [
    { compat: 'metaentry', modern: 'Metaentry', value: -1 },
    { compat: 'liveentry', modern: 'Liveentry', value: 0 },
    { compat: 'deadentry', modern: 'Deadentry', value: 1 },
    { compat: 'initentry', modern: 'Initentry', value: 2 },
  ],
});
export const BucketEntryType = _BucketEntryType as unknown as {
  metaentry(): BucketEntryType;
  liveentry(): BucketEntryType;
  deadentry(): BucketEntryType;
  initentry(): BucketEntryType;
};

export interface HotArchiveBucketEntryType {
  readonly name: 'hotArchiveMetaentry' | 'hotArchiveArchived' | 'hotArchiveLive';
  readonly value: -1 | 0 | 1;
}
const _HotArchiveBucketEntryType = createCompatEnum({
  codec: modern.HotArchiveBucketEntryType,
  members: [
    { compat: 'hotArchiveMetaentry', modern: 'Metaentry', value: -1 },
    { compat: 'hotArchiveArchived', modern: 'Archived', value: 0 },
    { compat: 'hotArchiveLive', modern: 'Live', value: 1 },
  ],
});
export const HotArchiveBucketEntryType = _HotArchiveBucketEntryType as unknown as {
  hotArchiveMetaentry(): HotArchiveBucketEntryType;
  hotArchiveArchived(): HotArchiveBucketEntryType;
  hotArchiveLive(): HotArchiveBucketEntryType;
};

export interface BucketMetadataExt {
  switch(): number;
  bucketListType(value?: BucketListType): BucketListType;
  value(): BucketListType | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _BucketMetadataExt = createCompatUnion({
  codec: modern.BucketMetadataExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'bucketListType', convert: enumConverter(_BucketListType) },
  ],
});
export const BucketMetadataExt = _BucketMetadataExt as unknown as {
  0(): BucketMetadataExt;
  1(value: BucketListType): BucketMetadataExt;
  read(io: Buffer): BucketMetadataExt;
  write(value: BucketMetadataExt, io: Buffer): void;
  isValid(value: BucketMetadataExt): boolean;
  toXDR(value: BucketMetadataExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): BucketMetadataExt;
  fromXDR(input: string, format: 'hex' | 'base64'): BucketMetadataExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface BucketMetadata {
  ledgerVersion(value?: Uint32): Uint32;
  ext(value?: BucketMetadataExt): BucketMetadataExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _BucketMetadata = createCompatStruct({
  codec: modern.BucketMetadata,
  fields: [
    { name: 'ledgerVersion', modernName: 'ledgerVersion', convert: id },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const BucketMetadata = _BucketMetadata as unknown as {
  new(attributes: { ledgerVersion: Uint32; ext: BucketMetadataExt }): BucketMetadata;
  read(io: Buffer): BucketMetadata;
  write(value: BucketMetadata, io: Buffer): void;
  isValid(value: BucketMetadata): boolean;
  toXDR(value: BucketMetadata): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): BucketMetadata;
  fromXDR(input: string, format: 'hex' | 'base64'): BucketMetadata;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface BucketEntry {
  switch(): BucketEntryType;
  liveEntry(value?: LedgerEntry): LedgerEntry;
  deadEntry(value?: LedgerKey): LedgerKey;
  metaEntry(value?: BucketMetadata): BucketMetadata;
  value(): LedgerEntry | LedgerKey | BucketMetadata;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _BucketEntry = createCompatUnion({
  codec: modern.BucketEntry,
  switchEnum: _BucketEntryType,
  arms: [
    { switchValues: ['liveentry', 'initentry'], modern: 'Liveentry', arm: 'liveEntry', convert: structConverter(_LedgerEntry) },
    { switchValues: ['deadentry'], modern: 'Deadentry', arm: 'deadEntry', convert: unionConverter(_LedgerKey) },
    { switchValues: ['metaentry'], modern: 'Metaentry', arm: 'metaEntry', convert: structConverter(_BucketMetadata) },
  ],
});
export const BucketEntry = _BucketEntry as unknown as {
  liveentry(value: LedgerEntry): BucketEntry;
  initentry(value: LedgerEntry): BucketEntry;
  deadentry(value: LedgerKey): BucketEntry;
  metaentry(value: BucketMetadata): BucketEntry;
  read(io: Buffer): BucketEntry;
  write(value: BucketEntry, io: Buffer): void;
  isValid(value: BucketEntry): boolean;
  toXDR(value: BucketEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): BucketEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): BucketEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HotArchiveBucketEntry {
  switch(): HotArchiveBucketEntryType;
  archivedEntry(value?: LedgerEntry): LedgerEntry;
  key(value?: LedgerKey): LedgerKey;
  metaEntry(value?: BucketMetadata): BucketMetadata;
  value(): LedgerEntry | LedgerKey | BucketMetadata;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HotArchiveBucketEntry = createCompatUnion({
  codec: modern.HotArchiveBucketEntry,
  switchEnum: _HotArchiveBucketEntryType,
  arms: [
    { switchValues: ['hotArchiveArchived'], modern: 'Archived', arm: 'archivedEntry', convert: structConverter(_LedgerEntry) },
    { switchValues: ['hotArchiveLive'], modern: 'Live', arm: 'key', convert: unionConverter(_LedgerKey) },
    { switchValues: ['hotArchiveMetaentry'], modern: 'Metaentry', arm: 'metaEntry', convert: structConverter(_BucketMetadata) },
  ],
});
export const HotArchiveBucketEntry = _HotArchiveBucketEntry as unknown as {
  hotArchiveArchived(value: LedgerEntry): HotArchiveBucketEntry;
  hotArchiveLive(value: LedgerKey): HotArchiveBucketEntry;
  hotArchiveMetaentry(value: BucketMetadata): HotArchiveBucketEntry;
  read(io: Buffer): HotArchiveBucketEntry;
  write(value: HotArchiveBucketEntry, io: Buffer): void;
  isValid(value: HotArchiveBucketEntry): boolean;
  toXDR(value: HotArchiveBucketEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HotArchiveBucketEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): HotArchiveBucketEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const MASK_LEDGER_HEADER_FLAGS = 0x7;

export interface LedgerHeaderFlags {
  readonly name: 'disableLiquidityPoolTradingFlag' | 'disableLiquidityPoolDepositFlag' | 'disableLiquidityPoolWithdrawalFlag';
  readonly value: 1 | 2 | 4;
}
const _LedgerHeaderFlags = createCompatEnum({
  codec: modern.LedgerHeaderFlags,
  members: [
    { compat: 'disableLiquidityPoolTradingFlag', modern: 'TradingFlag', value: 1 },
    { compat: 'disableLiquidityPoolDepositFlag', modern: 'DepositFlag', value: 2 },
    { compat: 'disableLiquidityPoolWithdrawalFlag', modern: 'WithdrawalFlag', value: 4 },
  ],
});
export const LedgerHeaderFlags = _LedgerHeaderFlags as unknown as {
  disableLiquidityPoolTradingFlag(): LedgerHeaderFlags;
  disableLiquidityPoolDepositFlag(): LedgerHeaderFlags;
  disableLiquidityPoolWithdrawalFlag(): LedgerHeaderFlags;
};

export interface ConfigUpgradeSet {
  updatedEntry(value?: ConfigSettingEntry[]): ConfigSettingEntry[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ConfigUpgradeSet = createCompatStruct({
  codec: modern.ConfigUpgradeSet,
  fields: [
    { name: 'updatedEntry', modernName: 'updatedEntry', convert: arrayConverter(unionConverter(_ConfigSettingEntry)) },
  ],
});
export const ConfigUpgradeSet = _ConfigUpgradeSet as unknown as {
  new(attributes: { updatedEntry: ConfigSettingEntry[] }): ConfigUpgradeSet;
  read(io: Buffer): ConfigUpgradeSet;
  write(value: ConfigUpgradeSet, io: Buffer): void;
  isValid(value: ConfigUpgradeSet): boolean;
  toXDR(value: ConfigUpgradeSet): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ConfigUpgradeSet;
  fromXDR(input: string, format: 'hex' | 'base64'): ConfigUpgradeSet;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionResultSet {
  results(value?: TransactionResultPair[]): TransactionResultPair[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionResultSet = createCompatStruct({
  codec: modern.TransactionResultSet,
  fields: [
    { name: 'results', modernName: 'results', convert: arrayConverter(structConverter(_TransactionResultPair)) },
  ],
});
export const TransactionResultSet = _TransactionResultSet as unknown as {
  new(attributes: { results: TransactionResultPair[] }): TransactionResultSet;
  read(io: Buffer): TransactionResultSet;
  write(value: TransactionResultSet, io: Buffer): void;
  isValid(value: TransactionResultSet): boolean;
  toXDR(value: TransactionResultSet): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionResultSet;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionResultSet;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionHistoryEntryExt {
  switch(): number;
  generalizedTxSet(value?: GeneralizedTransactionSet): GeneralizedTransactionSet;
  value(): GeneralizedTransactionSet | void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionHistoryEntryExt = createCompatUnion({
  codec: modern.TransactionHistoryEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
    { switchValues: [1], modern: 1, arm: 'generalizedTxSet', convert: unionConverter(_GeneralizedTransactionSet) },
  ],
});
export const TransactionHistoryEntryExt = _TransactionHistoryEntryExt as unknown as {
  0(): TransactionHistoryEntryExt;
  1(value: GeneralizedTransactionSet): TransactionHistoryEntryExt;
  read(io: Buffer): TransactionHistoryEntryExt;
  write(value: TransactionHistoryEntryExt, io: Buffer): void;
  isValid(value: TransactionHistoryEntryExt): boolean;
  toXDR(value: TransactionHistoryEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionHistoryEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionHistoryEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionHistoryEntry {
  ledgerSeq(value?: Uint32): Uint32;
  txSet(value?: TransactionSet): TransactionSet;
  ext(value?: TransactionHistoryEntryExt): TransactionHistoryEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionHistoryEntry = createCompatStruct({
  codec: modern.TransactionHistoryEntry,
  fields: [
    { name: 'ledgerSeq', modernName: 'ledgerSeq', convert: id },
    { name: 'txSet', modernName: 'txSet', convert: structConverter(_TransactionSet) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const TransactionHistoryEntry = _TransactionHistoryEntry as unknown as {
  new(attributes: { ledgerSeq: Uint32; txSet: TransactionSet; ext: TransactionHistoryEntryExt }): TransactionHistoryEntry;
  read(io: Buffer): TransactionHistoryEntry;
  write(value: TransactionHistoryEntry, io: Buffer): void;
  isValid(value: TransactionHistoryEntry): boolean;
  toXDR(value: TransactionHistoryEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionHistoryEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionHistoryEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionHistoryResultEntryExt {
  switch(): number;
  value(): void;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionHistoryResultEntryExt = createCompatUnion({
  codec: modern.TransactionHistoryResultEntryExt,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0 },
  ],
});
export const TransactionHistoryResultEntryExt = _TransactionHistoryResultEntryExt as unknown as {
  0(): TransactionHistoryResultEntryExt;
  read(io: Buffer): TransactionHistoryResultEntryExt;
  write(value: TransactionHistoryResultEntryExt, io: Buffer): void;
  isValid(value: TransactionHistoryResultEntryExt): boolean;
  toXDR(value: TransactionHistoryResultEntryExt): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionHistoryResultEntryExt;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionHistoryResultEntryExt;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionHistoryResultEntry {
  ledgerSeq(value?: Uint32): Uint32;
  txResultSet(value?: TransactionResultSet): TransactionResultSet;
  ext(value?: TransactionHistoryResultEntryExt): TransactionHistoryResultEntryExt;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionHistoryResultEntry = createCompatStruct({
  codec: modern.TransactionHistoryResultEntry,
  fields: [
    { name: 'ledgerSeq', modernName: 'ledgerSeq', convert: id },
    { name: 'txResultSet', modernName: 'txResultSet', convert: structConverter(_TransactionResultSet) },
    { name: 'ext', modernName: 'ext', convert: id },
  ],
});
export const TransactionHistoryResultEntry = _TransactionHistoryResultEntry as unknown as {
  new(attributes: { ledgerSeq: Uint32; txResultSet: TransactionResultSet; ext: TransactionHistoryResultEntryExt }): TransactionHistoryResultEntry;
  read(io: Buffer): TransactionHistoryResultEntry;
  write(value: TransactionHistoryResultEntry, io: Buffer): void;
  isValid(value: TransactionHistoryResultEntry): boolean;
  toXDR(value: TransactionHistoryResultEntry): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionHistoryResultEntry;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionHistoryResultEntry;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface InvokeHostFunctionSuccessPreImage {
  returnValue(value?: ScVal): ScVal;
  events(value?: ContractEvent[]): ContractEvent[];
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _InvokeHostFunctionSuccessPreImage = createCompatStruct({
  codec: modern.InvokeHostFunctionSuccessPreImage,
  fields: [
    { name: 'returnValue', modernName: 'returnValue', convert: lazyConverter(() => unionConverter(_ScVal)) },
    { name: 'events', modernName: 'events', convert: arrayConverter(structConverter(_ContractEvent)) },
  ],
});
export const InvokeHostFunctionSuccessPreImage = _InvokeHostFunctionSuccessPreImage as unknown as {
  new(attributes: { returnValue: ScVal; events: ContractEvent[] }): InvokeHostFunctionSuccessPreImage;
  read(io: Buffer): InvokeHostFunctionSuccessPreImage;
  write(value: InvokeHostFunctionSuccessPreImage, io: Buffer): void;
  isValid(value: InvokeHostFunctionSuccessPreImage): boolean;
  toXDR(value: InvokeHostFunctionSuccessPreImage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): InvokeHostFunctionSuccessPreImage;
  fromXDR(input: string, format: 'hex' | 'base64'): InvokeHostFunctionSuccessPreImage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ErrorCode {
  readonly name: 'errMisc' | 'errData' | 'errConf' | 'errAuth' | 'errLoad';
  readonly value: 0 | 1 | 2 | 3 | 4;
}
const _ErrorCode = createCompatEnum({
  codec: modern.ErrorCode,
  members: [
    { compat: 'errMisc', modern: 'Misc', value: 0 },
    { compat: 'errData', modern: 'Data', value: 1 },
    { compat: 'errConf', modern: 'Conf', value: 2 },
    { compat: 'errAuth', modern: 'Auth', value: 3 },
    { compat: 'errLoad', modern: 'Load', value: 4 },
  ],
});
export const ErrorCode = _ErrorCode as unknown as {
  errMisc(): ErrorCode;
  errData(): ErrorCode;
  errConf(): ErrorCode;
  errAuth(): ErrorCode;
  errLoad(): ErrorCode;
};

export interface Error {
  code(value?: ErrorCode): ErrorCode;
  msg(value?: string | Buffer): string | Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Error = createCompatStruct({
  codec: modern.Error,
  fields: [
    { name: 'code', modernName: 'code', convert: enumConverter(_ErrorCode) },
    { name: 'msg', modernName: 'msg', convert: id },
  ],
});
export const Error = _Error as unknown as {
  new(attributes: { code: ErrorCode; msg: string | Buffer }): Error;
  read(io: Buffer): Error;
  write(value: Error, io: Buffer): void;
  isValid(value: Error): boolean;
  toXDR(value: Error): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Error;
  fromXDR(input: string, format: 'hex' | 'base64'): Error;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SendMore {
  numMessages(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SendMore = createCompatStruct({
  codec: modern.SendMore,
  fields: [
    { name: 'numMessages', modernName: 'numMessages', convert: id },
  ],
});
export const SendMore = _SendMore as unknown as {
  new(attributes: { numMessages: Uint32 }): SendMore;
  read(io: Buffer): SendMore;
  write(value: SendMore, io: Buffer): void;
  isValid(value: SendMore): boolean;
  toXDR(value: SendMore): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SendMore;
  fromXDR(input: string, format: 'hex' | 'base64'): SendMore;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SendMoreExtended {
  numMessages(value?: Uint32): Uint32;
  numBytes(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SendMoreExtended = createCompatStruct({
  codec: modern.SendMoreExtended,
  fields: [
    { name: 'numMessages', modernName: 'numMessages', convert: id },
    { name: 'numBytes', modernName: 'numBytes', convert: id },
  ],
});
export const SendMoreExtended = _SendMoreExtended as unknown as {
  new(attributes: { numMessages: Uint32; numBytes: Uint32 }): SendMoreExtended;
  read(io: Buffer): SendMoreExtended;
  write(value: SendMoreExtended, io: Buffer): void;
  isValid(value: SendMoreExtended): boolean;
  toXDR(value: SendMoreExtended): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SendMoreExtended;
  fromXDR(input: string, format: 'hex' | 'base64'): SendMoreExtended;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Curve25519Public {
  key(value?: Buffer): Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Curve25519Public = createCompatStruct({
  codec: modern.Curve25519Public,
  fields: [
    { name: 'key', modernName: 'key', convert: id },
  ],
});
export const Curve25519Public = _Curve25519Public as unknown as {
  new(attributes: { key: Buffer }): Curve25519Public;
  read(io: Buffer): Curve25519Public;
  write(value: Curve25519Public, io: Buffer): void;
  isValid(value: Curve25519Public): boolean;
  toXDR(value: Curve25519Public): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Curve25519Public;
  fromXDR(input: string, format: 'hex' | 'base64'): Curve25519Public;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AuthCert {
  pubkey(value?: Curve25519Public): Curve25519Public;
  expiration(value?: Uint64): Uint64;
  sig(value?: Signature): Signature;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AuthCert = createCompatStruct({
  codec: modern.AuthCert,
  fields: [
    { name: 'pubkey', modernName: 'pubkey', convert: structConverter(_Curve25519Public) },
    { name: 'expiration', modernName: 'expiration', convert: uint64Conv },
    { name: 'sig', modernName: 'sig', convert: id },
  ],
});
export const AuthCert = _AuthCert as unknown as {
  new(attributes: { pubkey: Curve25519Public; expiration: Uint64; sig: Signature }): AuthCert;
  read(io: Buffer): AuthCert;
  write(value: AuthCert, io: Buffer): void;
  isValid(value: AuthCert): boolean;
  toXDR(value: AuthCert): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AuthCert;
  fromXDR(input: string, format: 'hex' | 'base64'): AuthCert;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Hello {
  ledgerVersion(value?: Uint32): Uint32;
  overlayVersion(value?: Uint32): Uint32;
  overlayMinVersion(value?: Uint32): Uint32;
  networkId(value?: Hash): Hash;
  versionStr(value?: string | Buffer): string | Buffer;
  listeningPort(value?: number): number;
  peerId(value?: NodeId): NodeId;
  cert(value?: AuthCert): AuthCert;
  nonce(value?: Uint256): Uint256;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Hello = createCompatStruct({
  codec: modern.Hello,
  fields: [
    { name: 'ledgerVersion', modernName: 'ledgerVersion', convert: id },
    { name: 'overlayVersion', modernName: 'overlayVersion', convert: id },
    { name: 'overlayMinVersion', modernName: 'overlayMinVersion', convert: id },
    { name: 'networkId', modernName: 'networkID', convert: id },
    { name: 'versionStr', modernName: 'versionStr', convert: id },
    { name: 'listeningPort', modernName: 'listeningPort', convert: id },
    { name: 'peerId', modernName: 'peerID', convert: unionConverter(_PublicKey) },
    { name: 'cert', modernName: 'cert', convert: structConverter(_AuthCert) },
    { name: 'nonce', modernName: 'nonce', convert: id },
  ],
});
export const Hello = _Hello as unknown as {
  new(attributes: { ledgerVersion: Uint32; overlayVersion: Uint32; overlayMinVersion: Uint32; networkId: Hash; versionStr: string | Buffer; listeningPort: number; peerId: NodeId; cert: AuthCert; nonce: Uint256 }): Hello;
  read(io: Buffer): Hello;
  write(value: Hello, io: Buffer): void;
  isValid(value: Hello): boolean;
  toXDR(value: Hello): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Hello;
  fromXDR(input: string, format: 'hex' | 'base64'): Hello;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED = 200;

export interface Auth {
  flags(value?: number): number;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Auth = createCompatStruct({
  codec: modern.Auth,
  fields: [
    { name: 'flags', modernName: 'flags', convert: id },
  ],
});
export const Auth = _Auth as unknown as {
  new(attributes: { flags: number }): Auth;
  read(io: Buffer): Auth;
  write(value: Auth, io: Buffer): void;
  isValid(value: Auth): boolean;
  toXDR(value: Auth): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Auth;
  fromXDR(input: string, format: 'hex' | 'base64'): Auth;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface IpAddrType {
  readonly name: 'iPv4' | 'iPv6';
  readonly value: 0 | 1;
}
const _IpAddrType = createCompatEnum({
  codec: modern.IPAddrType,
  members: [
    { compat: 'iPv4', modern: 'IPv4', value: 0 },
    { compat: 'iPv6', modern: 'IPv6', value: 1 },
  ],
});
export const IpAddrType = _IpAddrType as unknown as {
  iPv4(): IpAddrType;
  iPv6(): IpAddrType;
};

export interface PeerAddressIp {
  switch(): IpAddrType;
  ipv4(value?: Buffer): Buffer;
  ipv6(value?: Buffer): Buffer;
  value(): Buffer | Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PeerAddressIp = createCompatUnion({
  codec: modern.PeerAddressIp,
  switchEnum: _IpAddrType,
  arms: [
    { switchValues: ['iPv4'], modern: 'IPv4', arm: 'ipv4', convert: id },
    { switchValues: ['iPv6'], modern: 'IPv6', arm: 'ipv6', convert: id },
  ],
});
export const PeerAddressIp = _PeerAddressIp as unknown as {
  iPv4(value: Buffer): PeerAddressIp;
  iPv6(value: Buffer): PeerAddressIp;
  read(io: Buffer): PeerAddressIp;
  write(value: PeerAddressIp, io: Buffer): void;
  isValid(value: PeerAddressIp): boolean;
  toXDR(value: PeerAddressIp): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PeerAddressIp;
  fromXDR(input: string, format: 'hex' | 'base64'): PeerAddressIp;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PeerAddress {
  ip(value?: PeerAddressIp): PeerAddressIp;
  port(value?: Uint32): Uint32;
  numFailures(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PeerAddress = createCompatStruct({
  codec: modern.PeerAddress,
  fields: [
    { name: 'ip', modernName: 'ip', convert: id },
    { name: 'port', modernName: 'port', convert: id },
    { name: 'numFailures', modernName: 'numFailures', convert: id },
  ],
});
export const PeerAddress = _PeerAddress as unknown as {
  new(attributes: { ip: PeerAddressIp; port: Uint32; numFailures: Uint32 }): PeerAddress;
  read(io: Buffer): PeerAddress;
  write(value: PeerAddress, io: Buffer): void;
  isValid(value: PeerAddress): boolean;
  toXDR(value: PeerAddress): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PeerAddress;
  fromXDR(input: string, format: 'hex' | 'base64'): PeerAddress;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface MessageType {
  readonly name: 'errorMsg' | 'auth' | 'dontHave' | 'peers' | 'getTxSet' | 'txSet' | 'generalizedTxSet' | 'transaction' | 'getScpQuorumset' | 'scpQuorumset' | 'scpMessage' | 'getScpState' | 'hello' | 'sendMore' | 'sendMoreExtended' | 'floodAdvert' | 'floodDemand' | 'timeSlicedSurveyRequest' | 'timeSlicedSurveyResponse' | 'timeSlicedSurveyStartCollecting' | 'timeSlicedSurveyStopCollecting';
  readonly value: 0 | 2 | 3 | 5 | 6 | 7 | 17 | 8 | 9 | 10 | 11 | 12 | 13 | 16 | 20 | 18 | 19 | 21 | 22 | 23 | 24;
}
const _MessageType = createCompatEnum({
  codec: modern.MessageType,
  members: [
    { compat: 'errorMsg', modern: 'ErrorMsg', value: 0 },
    { compat: 'auth', modern: 'Auth', value: 2 },
    { compat: 'dontHave', modern: 'DontHave', value: 3 },
    { compat: 'peers', modern: 'Peers', value: 5 },
    { compat: 'getTxSet', modern: 'GetTxSet', value: 6 },
    { compat: 'txSet', modern: 'TxSet', value: 7 },
    { compat: 'generalizedTxSet', modern: 'GeneralizedTxSet', value: 17 },
    { compat: 'transaction', modern: 'Transaction', value: 8 },
    { compat: 'getScpQuorumset', modern: 'GetScpQuorumset', value: 9 },
    { compat: 'scpQuorumset', modern: 'ScpQuorumset', value: 10 },
    { compat: 'scpMessage', modern: 'ScpMessage', value: 11 },
    { compat: 'getScpState', modern: 'GetScpState', value: 12 },
    { compat: 'hello', modern: 'Hello', value: 13 },
    { compat: 'sendMore', modern: 'SendMore', value: 16 },
    { compat: 'sendMoreExtended', modern: 'SendMoreExtended', value: 20 },
    { compat: 'floodAdvert', modern: 'FloodAdvert', value: 18 },
    { compat: 'floodDemand', modern: 'FloodDemand', value: 19 },
    { compat: 'timeSlicedSurveyRequest', modern: 'TimeSlicedSurveyRequest', value: 21 },
    { compat: 'timeSlicedSurveyResponse', modern: 'TimeSlicedSurveyResponse', value: 22 },
    { compat: 'timeSlicedSurveyStartCollecting', modern: 'TimeSlicedSurveyStartCollecting', value: 23 },
    { compat: 'timeSlicedSurveyStopCollecting', modern: 'TimeSlicedSurveyStopCollecting', value: 24 },
  ],
});
export const MessageType = _MessageType as unknown as {
  errorMsg(): MessageType;
  auth(): MessageType;
  dontHave(): MessageType;
  peers(): MessageType;
  getTxSet(): MessageType;
  txSet(): MessageType;
  generalizedTxSet(): MessageType;
  transaction(): MessageType;
  getScpQuorumset(): MessageType;
  scpQuorumset(): MessageType;
  scpMessage(): MessageType;
  getScpState(): MessageType;
  hello(): MessageType;
  sendMore(): MessageType;
  sendMoreExtended(): MessageType;
  floodAdvert(): MessageType;
  floodDemand(): MessageType;
  timeSlicedSurveyRequest(): MessageType;
  timeSlicedSurveyResponse(): MessageType;
  timeSlicedSurveyStartCollecting(): MessageType;
  timeSlicedSurveyStopCollecting(): MessageType;
};

export interface DontHave {
  type(value?: MessageType): MessageType;
  reqHash(value?: Uint256): Uint256;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _DontHave = createCompatStruct({
  codec: modern.DontHave,
  fields: [
    { name: 'type', modernName: 'type', convert: enumConverter(_MessageType) },
    { name: 'reqHash', modernName: 'reqHash', convert: id },
  ],
});
export const DontHave = _DontHave as unknown as {
  new(attributes: { type: MessageType; reqHash: Uint256 }): DontHave;
  read(io: Buffer): DontHave;
  write(value: DontHave, io: Buffer): void;
  isValid(value: DontHave): boolean;
  toXDR(value: DontHave): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): DontHave;
  fromXDR(input: string, format: 'hex' | 'base64'): DontHave;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SurveyMessageCommandType {
  readonly name: 'timeSlicedSurveyTopology';
  readonly value: 1;
}
const _SurveyMessageCommandType = createCompatEnum({
  codec: modern.SurveyMessageCommandType,
  members: [
    { compat: 'timeSlicedSurveyTopology', modern: 'TimeSlicedSurveyTopology', value: 1 },
  ],
});
export const SurveyMessageCommandType = _SurveyMessageCommandType as unknown as {
  timeSlicedSurveyTopology(): SurveyMessageCommandType;
};

export interface SurveyMessageResponseType {
  readonly name: 'surveyTopologyResponseV2';
  readonly value: 2;
}
const _SurveyMessageResponseType = createCompatEnum({
  codec: modern.SurveyMessageResponseType,
  members: [
    { compat: 'surveyTopologyResponseV2', modern: 'SurveyTopologyResponseV2', value: 2 },
  ],
});
export const SurveyMessageResponseType = _SurveyMessageResponseType as unknown as {
  surveyTopologyResponseV2(): SurveyMessageResponseType;
};

export interface TimeSlicedSurveyStartCollectingMessage {
  surveyorId(value?: NodeId): NodeId;
  nonce(value?: Uint32): Uint32;
  ledgerNum(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TimeSlicedSurveyStartCollectingMessage = createCompatStruct({
  codec: modern.TimeSlicedSurveyStartCollectingMessage,
  fields: [
    { name: 'surveyorId', modernName: 'surveyorID', convert: unionConverter(_PublicKey) },
    { name: 'nonce', modernName: 'nonce', convert: id },
    { name: 'ledgerNum', modernName: 'ledgerNum', convert: id },
  ],
});
export const TimeSlicedSurveyStartCollectingMessage = _TimeSlicedSurveyStartCollectingMessage as unknown as {
  new(attributes: { surveyorId: NodeId; nonce: Uint32; ledgerNum: Uint32 }): TimeSlicedSurveyStartCollectingMessage;
  read(io: Buffer): TimeSlicedSurveyStartCollectingMessage;
  write(value: TimeSlicedSurveyStartCollectingMessage, io: Buffer): void;
  isValid(value: TimeSlicedSurveyStartCollectingMessage): boolean;
  toXDR(value: TimeSlicedSurveyStartCollectingMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TimeSlicedSurveyStartCollectingMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): TimeSlicedSurveyStartCollectingMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SignedTimeSlicedSurveyStartCollectingMessage {
  signature(value?: Signature): Signature;
  startCollecting(value?: TimeSlicedSurveyStartCollectingMessage): TimeSlicedSurveyStartCollectingMessage;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SignedTimeSlicedSurveyStartCollectingMessage = createCompatStruct({
  codec: modern.SignedTimeSlicedSurveyStartCollectingMessage,
  fields: [
    { name: 'signature', modernName: 'signature', convert: id },
    { name: 'startCollecting', modernName: 'startCollecting', convert: structConverter(_TimeSlicedSurveyStartCollectingMessage) },
  ],
});
export const SignedTimeSlicedSurveyStartCollectingMessage = _SignedTimeSlicedSurveyStartCollectingMessage as unknown as {
  new(attributes: { signature: Signature; startCollecting: TimeSlicedSurveyStartCollectingMessage }): SignedTimeSlicedSurveyStartCollectingMessage;
  read(io: Buffer): SignedTimeSlicedSurveyStartCollectingMessage;
  write(value: SignedTimeSlicedSurveyStartCollectingMessage, io: Buffer): void;
  isValid(value: SignedTimeSlicedSurveyStartCollectingMessage): boolean;
  toXDR(value: SignedTimeSlicedSurveyStartCollectingMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SignedTimeSlicedSurveyStartCollectingMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): SignedTimeSlicedSurveyStartCollectingMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TimeSlicedSurveyStopCollectingMessage {
  surveyorId(value?: NodeId): NodeId;
  nonce(value?: Uint32): Uint32;
  ledgerNum(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TimeSlicedSurveyStopCollectingMessage = createCompatStruct({
  codec: modern.TimeSlicedSurveyStopCollectingMessage,
  fields: [
    { name: 'surveyorId', modernName: 'surveyorID', convert: unionConverter(_PublicKey) },
    { name: 'nonce', modernName: 'nonce', convert: id },
    { name: 'ledgerNum', modernName: 'ledgerNum', convert: id },
  ],
});
export const TimeSlicedSurveyStopCollectingMessage = _TimeSlicedSurveyStopCollectingMessage as unknown as {
  new(attributes: { surveyorId: NodeId; nonce: Uint32; ledgerNum: Uint32 }): TimeSlicedSurveyStopCollectingMessage;
  read(io: Buffer): TimeSlicedSurveyStopCollectingMessage;
  write(value: TimeSlicedSurveyStopCollectingMessage, io: Buffer): void;
  isValid(value: TimeSlicedSurveyStopCollectingMessage): boolean;
  toXDR(value: TimeSlicedSurveyStopCollectingMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TimeSlicedSurveyStopCollectingMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): TimeSlicedSurveyStopCollectingMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SignedTimeSlicedSurveyStopCollectingMessage {
  signature(value?: Signature): Signature;
  stopCollecting(value?: TimeSlicedSurveyStopCollectingMessage): TimeSlicedSurveyStopCollectingMessage;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SignedTimeSlicedSurveyStopCollectingMessage = createCompatStruct({
  codec: modern.SignedTimeSlicedSurveyStopCollectingMessage,
  fields: [
    { name: 'signature', modernName: 'signature', convert: id },
    { name: 'stopCollecting', modernName: 'stopCollecting', convert: structConverter(_TimeSlicedSurveyStopCollectingMessage) },
  ],
});
export const SignedTimeSlicedSurveyStopCollectingMessage = _SignedTimeSlicedSurveyStopCollectingMessage as unknown as {
  new(attributes: { signature: Signature; stopCollecting: TimeSlicedSurveyStopCollectingMessage }): SignedTimeSlicedSurveyStopCollectingMessage;
  read(io: Buffer): SignedTimeSlicedSurveyStopCollectingMessage;
  write(value: SignedTimeSlicedSurveyStopCollectingMessage, io: Buffer): void;
  isValid(value: SignedTimeSlicedSurveyStopCollectingMessage): boolean;
  toXDR(value: SignedTimeSlicedSurveyStopCollectingMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SignedTimeSlicedSurveyStopCollectingMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): SignedTimeSlicedSurveyStopCollectingMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SurveyRequestMessage {
  surveyorPeerId(value?: NodeId): NodeId;
  surveyedPeerId(value?: NodeId): NodeId;
  ledgerNum(value?: Uint32): Uint32;
  encryptionKey(value?: Curve25519Public): Curve25519Public;
  commandType(value?: SurveyMessageCommandType): SurveyMessageCommandType;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SurveyRequestMessage = createCompatStruct({
  codec: modern.SurveyRequestMessage,
  fields: [
    { name: 'surveyorPeerId', modernName: 'surveyorPeerID', convert: unionConverter(_PublicKey) },
    { name: 'surveyedPeerId', modernName: 'surveyedPeerID', convert: unionConverter(_PublicKey) },
    { name: 'ledgerNum', modernName: 'ledgerNum', convert: id },
    { name: 'encryptionKey', modernName: 'encryptionKey', convert: structConverter(_Curve25519Public) },
    { name: 'commandType', modernName: 'commandType', convert: enumConverter(_SurveyMessageCommandType) },
  ],
});
export const SurveyRequestMessage = _SurveyRequestMessage as unknown as {
  new(attributes: { surveyorPeerId: NodeId; surveyedPeerId: NodeId; ledgerNum: Uint32; encryptionKey: Curve25519Public; commandType: SurveyMessageCommandType }): SurveyRequestMessage;
  read(io: Buffer): SurveyRequestMessage;
  write(value: SurveyRequestMessage, io: Buffer): void;
  isValid(value: SurveyRequestMessage): boolean;
  toXDR(value: SurveyRequestMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SurveyRequestMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): SurveyRequestMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TimeSlicedSurveyRequestMessage {
  request(value?: SurveyRequestMessage): SurveyRequestMessage;
  nonce(value?: Uint32): Uint32;
  inboundPeersIndex(value?: Uint32): Uint32;
  outboundPeersIndex(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TimeSlicedSurveyRequestMessage = createCompatStruct({
  codec: modern.TimeSlicedSurveyRequestMessage,
  fields: [
    { name: 'request', modernName: 'request', convert: structConverter(_SurveyRequestMessage) },
    { name: 'nonce', modernName: 'nonce', convert: id },
    { name: 'inboundPeersIndex', modernName: 'inboundPeersIndex', convert: id },
    { name: 'outboundPeersIndex', modernName: 'outboundPeersIndex', convert: id },
  ],
});
export const TimeSlicedSurveyRequestMessage = _TimeSlicedSurveyRequestMessage as unknown as {
  new(attributes: { request: SurveyRequestMessage; nonce: Uint32; inboundPeersIndex: Uint32; outboundPeersIndex: Uint32 }): TimeSlicedSurveyRequestMessage;
  read(io: Buffer): TimeSlicedSurveyRequestMessage;
  write(value: TimeSlicedSurveyRequestMessage, io: Buffer): void;
  isValid(value: TimeSlicedSurveyRequestMessage): boolean;
  toXDR(value: TimeSlicedSurveyRequestMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TimeSlicedSurveyRequestMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): TimeSlicedSurveyRequestMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SignedTimeSlicedSurveyRequestMessage {
  requestSignature(value?: Signature): Signature;
  request(value?: TimeSlicedSurveyRequestMessage): TimeSlicedSurveyRequestMessage;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SignedTimeSlicedSurveyRequestMessage = createCompatStruct({
  codec: modern.SignedTimeSlicedSurveyRequestMessage,
  fields: [
    { name: 'requestSignature', modernName: 'requestSignature', convert: id },
    { name: 'request', modernName: 'request', convert: structConverter(_TimeSlicedSurveyRequestMessage) },
  ],
});
export const SignedTimeSlicedSurveyRequestMessage = _SignedTimeSlicedSurveyRequestMessage as unknown as {
  new(attributes: { requestSignature: Signature; request: TimeSlicedSurveyRequestMessage }): SignedTimeSlicedSurveyRequestMessage;
  read(io: Buffer): SignedTimeSlicedSurveyRequestMessage;
  write(value: SignedTimeSlicedSurveyRequestMessage, io: Buffer): void;
  isValid(value: SignedTimeSlicedSurveyRequestMessage): boolean;
  toXDR(value: SignedTimeSlicedSurveyRequestMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SignedTimeSlicedSurveyRequestMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): SignedTimeSlicedSurveyRequestMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type EncryptedBody = Buffer;
export const EncryptedBody = createCompatTypedef({ codec: modern.EncryptedBody, convert: id });

export interface SurveyResponseMessage {
  surveyorPeerId(value?: NodeId): NodeId;
  surveyedPeerId(value?: NodeId): NodeId;
  ledgerNum(value?: Uint32): Uint32;
  commandType(value?: SurveyMessageCommandType): SurveyMessageCommandType;
  encryptedBody(value?: EncryptedBody): EncryptedBody;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SurveyResponseMessage = createCompatStruct({
  codec: modern.SurveyResponseMessage,
  fields: [
    { name: 'surveyorPeerId', modernName: 'surveyorPeerID', convert: unionConverter(_PublicKey) },
    { name: 'surveyedPeerId', modernName: 'surveyedPeerID', convert: unionConverter(_PublicKey) },
    { name: 'ledgerNum', modernName: 'ledgerNum', convert: id },
    { name: 'commandType', modernName: 'commandType', convert: enumConverter(_SurveyMessageCommandType) },
    { name: 'encryptedBody', modernName: 'encryptedBody', convert: id },
  ],
});
export const SurveyResponseMessage = _SurveyResponseMessage as unknown as {
  new(attributes: { surveyorPeerId: NodeId; surveyedPeerId: NodeId; ledgerNum: Uint32; commandType: SurveyMessageCommandType; encryptedBody: EncryptedBody }): SurveyResponseMessage;
  read(io: Buffer): SurveyResponseMessage;
  write(value: SurveyResponseMessage, io: Buffer): void;
  isValid(value: SurveyResponseMessage): boolean;
  toXDR(value: SurveyResponseMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SurveyResponseMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): SurveyResponseMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TimeSlicedSurveyResponseMessage {
  response(value?: SurveyResponseMessage): SurveyResponseMessage;
  nonce(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TimeSlicedSurveyResponseMessage = createCompatStruct({
  codec: modern.TimeSlicedSurveyResponseMessage,
  fields: [
    { name: 'response', modernName: 'response', convert: structConverter(_SurveyResponseMessage) },
    { name: 'nonce', modernName: 'nonce', convert: id },
  ],
});
export const TimeSlicedSurveyResponseMessage = _TimeSlicedSurveyResponseMessage as unknown as {
  new(attributes: { response: SurveyResponseMessage; nonce: Uint32 }): TimeSlicedSurveyResponseMessage;
  read(io: Buffer): TimeSlicedSurveyResponseMessage;
  write(value: TimeSlicedSurveyResponseMessage, io: Buffer): void;
  isValid(value: TimeSlicedSurveyResponseMessage): boolean;
  toXDR(value: TimeSlicedSurveyResponseMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TimeSlicedSurveyResponseMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): TimeSlicedSurveyResponseMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SignedTimeSlicedSurveyResponseMessage {
  responseSignature(value?: Signature): Signature;
  response(value?: TimeSlicedSurveyResponseMessage): TimeSlicedSurveyResponseMessage;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SignedTimeSlicedSurveyResponseMessage = createCompatStruct({
  codec: modern.SignedTimeSlicedSurveyResponseMessage,
  fields: [
    { name: 'responseSignature', modernName: 'responseSignature', convert: id },
    { name: 'response', modernName: 'response', convert: structConverter(_TimeSlicedSurveyResponseMessage) },
  ],
});
export const SignedTimeSlicedSurveyResponseMessage = _SignedTimeSlicedSurveyResponseMessage as unknown as {
  new(attributes: { responseSignature: Signature; response: TimeSlicedSurveyResponseMessage }): SignedTimeSlicedSurveyResponseMessage;
  read(io: Buffer): SignedTimeSlicedSurveyResponseMessage;
  write(value: SignedTimeSlicedSurveyResponseMessage, io: Buffer): void;
  isValid(value: SignedTimeSlicedSurveyResponseMessage): boolean;
  toXDR(value: SignedTimeSlicedSurveyResponseMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SignedTimeSlicedSurveyResponseMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): SignedTimeSlicedSurveyResponseMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface PeerStats {
  id(value?: NodeId): NodeId;
  versionStr(value?: string | Buffer): string | Buffer;
  messagesRead(value?: Uint64): Uint64;
  messagesWritten(value?: Uint64): Uint64;
  bytesRead(value?: Uint64): Uint64;
  bytesWritten(value?: Uint64): Uint64;
  secondsConnected(value?: Uint64): Uint64;
  uniqueFloodBytesRecv(value?: Uint64): Uint64;
  duplicateFloodBytesRecv(value?: Uint64): Uint64;
  uniqueFetchBytesRecv(value?: Uint64): Uint64;
  duplicateFetchBytesRecv(value?: Uint64): Uint64;
  uniqueFloodMessageRecv(value?: Uint64): Uint64;
  duplicateFloodMessageRecv(value?: Uint64): Uint64;
  uniqueFetchMessageRecv(value?: Uint64): Uint64;
  duplicateFetchMessageRecv(value?: Uint64): Uint64;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _PeerStats = createCompatStruct({
  codec: modern.PeerStats,
  fields: [
    { name: 'id', modernName: 'id', convert: unionConverter(_PublicKey) },
    { name: 'versionStr', modernName: 'versionStr', convert: id },
    { name: 'messagesRead', modernName: 'messagesRead', convert: uint64Conv },
    { name: 'messagesWritten', modernName: 'messagesWritten', convert: uint64Conv },
    { name: 'bytesRead', modernName: 'bytesRead', convert: uint64Conv },
    { name: 'bytesWritten', modernName: 'bytesWritten', convert: uint64Conv },
    { name: 'secondsConnected', modernName: 'secondsConnected', convert: uint64Conv },
    { name: 'uniqueFloodBytesRecv', modernName: 'uniqueFloodBytesRecv', convert: uint64Conv },
    { name: 'duplicateFloodBytesRecv', modernName: 'duplicateFloodBytesRecv', convert: uint64Conv },
    { name: 'uniqueFetchBytesRecv', modernName: 'uniqueFetchBytesRecv', convert: uint64Conv },
    { name: 'duplicateFetchBytesRecv', modernName: 'duplicateFetchBytesRecv', convert: uint64Conv },
    { name: 'uniqueFloodMessageRecv', modernName: 'uniqueFloodMessageRecv', convert: uint64Conv },
    { name: 'duplicateFloodMessageRecv', modernName: 'duplicateFloodMessageRecv', convert: uint64Conv },
    { name: 'uniqueFetchMessageRecv', modernName: 'uniqueFetchMessageRecv', convert: uint64Conv },
    { name: 'duplicateFetchMessageRecv', modernName: 'duplicateFetchMessageRecv', convert: uint64Conv },
  ],
});
export const PeerStats = _PeerStats as unknown as {
  new(attributes: { id: NodeId; versionStr: string | Buffer; messagesRead: Uint64; messagesWritten: Uint64; bytesRead: Uint64; bytesWritten: Uint64; secondsConnected: Uint64; uniqueFloodBytesRecv: Uint64; duplicateFloodBytesRecv: Uint64; uniqueFetchBytesRecv: Uint64; duplicateFetchBytesRecv: Uint64; uniqueFloodMessageRecv: Uint64; duplicateFloodMessageRecv: Uint64; uniqueFetchMessageRecv: Uint64; duplicateFetchMessageRecv: Uint64 }): PeerStats;
  read(io: Buffer): PeerStats;
  write(value: PeerStats, io: Buffer): void;
  isValid(value: PeerStats): boolean;
  toXDR(value: PeerStats): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): PeerStats;
  fromXDR(input: string, format: 'hex' | 'base64'): PeerStats;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TimeSlicedNodeData {
  addedAuthenticatedPeers(value?: Uint32): Uint32;
  droppedAuthenticatedPeers(value?: Uint32): Uint32;
  totalInboundPeerCount(value?: Uint32): Uint32;
  totalOutboundPeerCount(value?: Uint32): Uint32;
  p75ScpFirstToSelfLatencyMs(value?: Uint32): Uint32;
  p75ScpSelfToOtherLatencyMs(value?: Uint32): Uint32;
  lostSyncCount(value?: Uint32): Uint32;
  isValidator(value?: boolean): boolean;
  maxInboundPeerCount(value?: Uint32): Uint32;
  maxOutboundPeerCount(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TimeSlicedNodeData = createCompatStruct({
  codec: modern.TimeSlicedNodeData,
  fields: [
    { name: 'addedAuthenticatedPeers', modernName: 'addedAuthenticatedPeers', convert: id },
    { name: 'droppedAuthenticatedPeers', modernName: 'droppedAuthenticatedPeers', convert: id },
    { name: 'totalInboundPeerCount', modernName: 'totalInboundPeerCount', convert: id },
    { name: 'totalOutboundPeerCount', modernName: 'totalOutboundPeerCount', convert: id },
    { name: 'p75ScpFirstToSelfLatencyMs', modernName: 'p75SCPFirstToSelfLatencyMs', convert: id },
    { name: 'p75ScpSelfToOtherLatencyMs', modernName: 'p75SCPSelfToOtherLatencyMs', convert: id },
    { name: 'lostSyncCount', modernName: 'lostSyncCount', convert: id },
    { name: 'isValidator', modernName: 'isValidator', convert: id },
    { name: 'maxInboundPeerCount', modernName: 'maxInboundPeerCount', convert: id },
    { name: 'maxOutboundPeerCount', modernName: 'maxOutboundPeerCount', convert: id },
  ],
});
export const TimeSlicedNodeData = _TimeSlicedNodeData as unknown as {
  new(attributes: { addedAuthenticatedPeers: Uint32; droppedAuthenticatedPeers: Uint32; totalInboundPeerCount: Uint32; totalOutboundPeerCount: Uint32; p75ScpFirstToSelfLatencyMs: Uint32; p75ScpSelfToOtherLatencyMs: Uint32; lostSyncCount: Uint32; isValidator: boolean; maxInboundPeerCount: Uint32; maxOutboundPeerCount: Uint32 }): TimeSlicedNodeData;
  read(io: Buffer): TimeSlicedNodeData;
  write(value: TimeSlicedNodeData, io: Buffer): void;
  isValid(value: TimeSlicedNodeData): boolean;
  toXDR(value: TimeSlicedNodeData): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TimeSlicedNodeData;
  fromXDR(input: string, format: 'hex' | 'base64'): TimeSlicedNodeData;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TimeSlicedPeerData {
  peerStats(value?: PeerStats): PeerStats;
  averageLatencyMs(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TimeSlicedPeerData = createCompatStruct({
  codec: modern.TimeSlicedPeerData,
  fields: [
    { name: 'peerStats', modernName: 'peerStats', convert: structConverter(_PeerStats) },
    { name: 'averageLatencyMs', modernName: 'averageLatencyMs', convert: id },
  ],
});
export const TimeSlicedPeerData = _TimeSlicedPeerData as unknown as {
  new(attributes: { peerStats: PeerStats; averageLatencyMs: Uint32 }): TimeSlicedPeerData;
  read(io: Buffer): TimeSlicedPeerData;
  write(value: TimeSlicedPeerData, io: Buffer): void;
  isValid(value: TimeSlicedPeerData): boolean;
  toXDR(value: TimeSlicedPeerData): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TimeSlicedPeerData;
  fromXDR(input: string, format: 'hex' | 'base64'): TimeSlicedPeerData;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export type TimeSlicedPeerDataList = TimeSlicedPeerData[];
export const TimeSlicedPeerDataList = createCompatTypedef({ codec: modern.TimeSlicedPeerDataList, convert: arrayConverter(structConverter(_TimeSlicedPeerData)) });

export interface TopologyResponseBodyV2 {
  inboundPeers(value?: TimeSlicedPeerDataList): TimeSlicedPeerDataList;
  outboundPeers(value?: TimeSlicedPeerDataList): TimeSlicedPeerDataList;
  nodeData(value?: TimeSlicedNodeData): TimeSlicedNodeData;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TopologyResponseBodyV2 = createCompatStruct({
  codec: modern.TopologyResponseBodyV2,
  fields: [
    { name: 'inboundPeers', modernName: 'inboundPeers', convert: arrayConverter(structConverter(_TimeSlicedPeerData)) },
    { name: 'outboundPeers', modernName: 'outboundPeers', convert: arrayConverter(structConverter(_TimeSlicedPeerData)) },
    { name: 'nodeData', modernName: 'nodeData', convert: structConverter(_TimeSlicedNodeData) },
  ],
});
export const TopologyResponseBodyV2 = _TopologyResponseBodyV2 as unknown as {
  new(attributes: { inboundPeers: TimeSlicedPeerDataList; outboundPeers: TimeSlicedPeerDataList; nodeData: TimeSlicedNodeData }): TopologyResponseBodyV2;
  read(io: Buffer): TopologyResponseBodyV2;
  write(value: TopologyResponseBodyV2, io: Buffer): void;
  isValid(value: TopologyResponseBodyV2): boolean;
  toXDR(value: TopologyResponseBodyV2): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TopologyResponseBodyV2;
  fromXDR(input: string, format: 'hex' | 'base64'): TopologyResponseBodyV2;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface SurveyResponseBody {
  switch(): SurveyMessageResponseType;
  topologyResponseBodyV2(value?: TopologyResponseBodyV2): TopologyResponseBodyV2;
  value(): TopologyResponseBodyV2;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SurveyResponseBody = createCompatUnion({
  codec: modern.SurveyResponseBody,
  switchEnum: _SurveyMessageResponseType,
  arms: [
    { switchValues: ['surveyTopologyResponseV2'], modern: 'SurveyTopologyResponseV2', arm: 'topologyResponseBodyV2', convert: structConverter(_TopologyResponseBodyV2) },
  ],
});
export const SurveyResponseBody = _SurveyResponseBody as unknown as {
  surveyTopologyResponseV2(value: TopologyResponseBodyV2): SurveyResponseBody;
  read(io: Buffer): SurveyResponseBody;
  write(value: SurveyResponseBody, io: Buffer): void;
  isValid(value: SurveyResponseBody): boolean;
  toXDR(value: SurveyResponseBody): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SurveyResponseBody;
  fromXDR(input: string, format: 'hex' | 'base64'): SurveyResponseBody;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const TX_ADVERT_VECTOR_MAX_SIZE = 1000;

export type TxAdvertVector = Hash[];
export const TxAdvertVector = createCompatTypedef({ codec: modern.TxAdvertVector, convert: arrayConverter(id) });

export interface FloodAdvert {
  txHashes(value?: TxAdvertVector): TxAdvertVector;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _FloodAdvert = createCompatStruct({
  codec: modern.FloodAdvert,
  fields: [
    { name: 'txHashes', modernName: 'txHashes', convert: arrayConverter(id) },
  ],
});
export const FloodAdvert = _FloodAdvert as unknown as {
  new(attributes: { txHashes: TxAdvertVector }): FloodAdvert;
  read(io: Buffer): FloodAdvert;
  write(value: FloodAdvert, io: Buffer): void;
  isValid(value: FloodAdvert): boolean;
  toXDR(value: FloodAdvert): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): FloodAdvert;
  fromXDR(input: string, format: 'hex' | 'base64'): FloodAdvert;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const TX_DEMAND_VECTOR_MAX_SIZE = 1000;

export type TxDemandVector = Hash[];
export const TxDemandVector = createCompatTypedef({ codec: modern.TxDemandVector, convert: arrayConverter(id) });

export interface FloodDemand {
  txHashes(value?: TxDemandVector): TxDemandVector;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _FloodDemand = createCompatStruct({
  codec: modern.FloodDemand,
  fields: [
    { name: 'txHashes', modernName: 'txHashes', convert: arrayConverter(id) },
  ],
});
export const FloodDemand = _FloodDemand as unknown as {
  new(attributes: { txHashes: TxDemandVector }): FloodDemand;
  read(io: Buffer): FloodDemand;
  write(value: FloodDemand, io: Buffer): void;
  isValid(value: FloodDemand): boolean;
  toXDR(value: FloodDemand): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): FloodDemand;
  fromXDR(input: string, format: 'hex' | 'base64'): FloodDemand;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface StellarMessage {
  switch(): MessageType;
  error(value?: Error): Error;
  hello(value?: Hello): Hello;
  auth(value?: Auth): Auth;
  dontHave(value?: DontHave): DontHave;
  peers(value?: PeerAddress[]): PeerAddress[];
  txSetHash(value?: Uint256): Uint256;
  txSet(value?: TransactionSet): TransactionSet;
  generalizedTxSet(value?: GeneralizedTransactionSet): GeneralizedTransactionSet;
  transaction(value?: TransactionEnvelope): TransactionEnvelope;
  signedTimeSlicedSurveyRequestMessage(value?: SignedTimeSlicedSurveyRequestMessage): SignedTimeSlicedSurveyRequestMessage;
  signedTimeSlicedSurveyResponseMessage(value?: SignedTimeSlicedSurveyResponseMessage): SignedTimeSlicedSurveyResponseMessage;
  signedTimeSlicedSurveyStartCollectingMessage(value?: SignedTimeSlicedSurveyStartCollectingMessage): SignedTimeSlicedSurveyStartCollectingMessage;
  signedTimeSlicedSurveyStopCollectingMessage(value?: SignedTimeSlicedSurveyStopCollectingMessage): SignedTimeSlicedSurveyStopCollectingMessage;
  qSetHash(value?: Uint256): Uint256;
  qSet(value?: ScpQuorumSet): ScpQuorumSet;
  envelope(value?: ScpEnvelope): ScpEnvelope;
  getScpLedgerSeq(value?: Uint32): Uint32;
  sendMoreMessage(value?: SendMore): SendMore;
  sendMoreExtendedMessage(value?: SendMoreExtended): SendMoreExtended;
  floodAdvert(value?: FloodAdvert): FloodAdvert;
  floodDemand(value?: FloodDemand): FloodDemand;
  value(): Error | Hello | Auth | DontHave | PeerAddress[] | Uint256 | TransactionSet | GeneralizedTransactionSet | TransactionEnvelope | SignedTimeSlicedSurveyRequestMessage | SignedTimeSlicedSurveyResponseMessage | SignedTimeSlicedSurveyStartCollectingMessage | SignedTimeSlicedSurveyStopCollectingMessage | Uint256 | ScpQuorumSet | ScpEnvelope | Uint32 | SendMore | SendMoreExtended | FloodAdvert | FloodDemand;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _StellarMessage = createCompatUnion({
  codec: modern.StellarMessage,
  switchEnum: _MessageType,
  arms: [
    { switchValues: ['errorMsg'], modern: 'ErrorMsg', arm: 'error', convert: structConverter(_Error) },
    { switchValues: ['hello'], modern: 'Hello', arm: 'hello', convert: structConverter(_Hello) },
    { switchValues: ['auth'], modern: 'Auth', arm: 'auth', convert: structConverter(_Auth) },
    { switchValues: ['dontHave'], modern: 'DontHave', arm: 'dontHave', convert: structConverter(_DontHave) },
    { switchValues: ['peers'], modern: 'Peers', arm: 'peers', convert: arrayConverter(structConverter(_PeerAddress)) },
    { switchValues: ['getTxSet'], modern: 'GetTxSet', arm: 'txSetHash', convert: id },
    { switchValues: ['txSet'], modern: 'TxSet', arm: 'txSet', convert: structConverter(_TransactionSet) },
    { switchValues: ['generalizedTxSet'], modern: 'GeneralizedTxSet', arm: 'generalizedTxSet', convert: unionConverter(_GeneralizedTransactionSet) },
    { switchValues: ['transaction'], modern: 'Transaction', arm: 'transaction', convert: unionConverter(_TransactionEnvelope) },
    { switchValues: ['timeSlicedSurveyRequest'], modern: 'TimeSlicedSurveyRequest', arm: 'signedTimeSlicedSurveyRequestMessage', convert: structConverter(_SignedTimeSlicedSurveyRequestMessage) },
    { switchValues: ['timeSlicedSurveyResponse'], modern: 'TimeSlicedSurveyResponse', arm: 'signedTimeSlicedSurveyResponseMessage', convert: structConverter(_SignedTimeSlicedSurveyResponseMessage) },
    { switchValues: ['timeSlicedSurveyStartCollecting'], modern: 'TimeSlicedSurveyStartCollecting', arm: 'signedTimeSlicedSurveyStartCollectingMessage', convert: structConverter(_SignedTimeSlicedSurveyStartCollectingMessage) },
    { switchValues: ['timeSlicedSurveyStopCollecting'], modern: 'TimeSlicedSurveyStopCollecting', arm: 'signedTimeSlicedSurveyStopCollectingMessage', convert: structConverter(_SignedTimeSlicedSurveyStopCollectingMessage) },
    { switchValues: ['getScpQuorumset'], modern: 'GetScpQuorumset', arm: 'qSetHash', convert: id },
    { switchValues: ['scpQuorumset'], modern: 'ScpQuorumset', arm: 'qSet', convert: lazyConverter(() => structConverter(_ScpQuorumSet)) },
    { switchValues: ['scpMessage'], modern: 'ScpMessage', arm: 'envelope', convert: structConverter(_ScpEnvelope) },
    { switchValues: ['getScpState'], modern: 'GetScpState', arm: 'getScpLedgerSeq', convert: id },
    { switchValues: ['sendMore'], modern: 'SendMore', arm: 'sendMoreMessage', convert: structConverter(_SendMore) },
    { switchValues: ['sendMoreExtended'], modern: 'SendMoreExtended', arm: 'sendMoreExtendedMessage', convert: structConverter(_SendMoreExtended) },
    { switchValues: ['floodAdvert'], modern: 'FloodAdvert', arm: 'floodAdvert', convert: structConverter(_FloodAdvert) },
    { switchValues: ['floodDemand'], modern: 'FloodDemand', arm: 'floodDemand', convert: structConverter(_FloodDemand) },
  ],
});
export const StellarMessage = _StellarMessage as unknown as {
  errorMsg(value: Error): StellarMessage;
  hello(value: Hello): StellarMessage;
  auth(value: Auth): StellarMessage;
  dontHave(value: DontHave): StellarMessage;
  peers(value: PeerAddress[]): StellarMessage;
  getTxSet(value: Uint256): StellarMessage;
  txSet(value: TransactionSet): StellarMessage;
  generalizedTxSet(value: GeneralizedTransactionSet): StellarMessage;
  transaction(value: TransactionEnvelope): StellarMessage;
  timeSlicedSurveyRequest(value: SignedTimeSlicedSurveyRequestMessage): StellarMessage;
  timeSlicedSurveyResponse(value: SignedTimeSlicedSurveyResponseMessage): StellarMessage;
  timeSlicedSurveyStartCollecting(value: SignedTimeSlicedSurveyStartCollectingMessage): StellarMessage;
  timeSlicedSurveyStopCollecting(value: SignedTimeSlicedSurveyStopCollectingMessage): StellarMessage;
  getScpQuorumset(value: Uint256): StellarMessage;
  scpQuorumset(value: ScpQuorumSet): StellarMessage;
  scpMessage(value: ScpEnvelope): StellarMessage;
  getScpState(value: Uint32): StellarMessage;
  sendMore(value: SendMore): StellarMessage;
  sendMoreExtended(value: SendMoreExtended): StellarMessage;
  floodAdvert(value: FloodAdvert): StellarMessage;
  floodDemand(value: FloodDemand): StellarMessage;
  read(io: Buffer): StellarMessage;
  write(value: StellarMessage, io: Buffer): void;
  isValid(value: StellarMessage): boolean;
  toXDR(value: StellarMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): StellarMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): StellarMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HmacSha256Mac {
  mac(value?: Buffer): Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HmacSha256Mac = createCompatStruct({
  codec: modern.HmacSha256Mac,
  fields: [
    { name: 'mac', modernName: 'mac', convert: id },
  ],
});
export const HmacSha256Mac = _HmacSha256Mac as unknown as {
  new(attributes: { mac: Buffer }): HmacSha256Mac;
  read(io: Buffer): HmacSha256Mac;
  write(value: HmacSha256Mac, io: Buffer): void;
  isValid(value: HmacSha256Mac): boolean;
  toXDR(value: HmacSha256Mac): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HmacSha256Mac;
  fromXDR(input: string, format: 'hex' | 'base64'): HmacSha256Mac;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AuthenticatedMessageV0 {
  sequence(value?: Uint64): Uint64;
  message(value?: StellarMessage): StellarMessage;
  mac(value?: HmacSha256Mac): HmacSha256Mac;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AuthenticatedMessageV0 = createCompatStruct({
  codec: modern.AuthenticatedMessageV0,
  fields: [
    { name: 'sequence', modernName: 'sequence', convert: uint64Conv },
    { name: 'message', modernName: 'message', convert: unionConverter(_StellarMessage) },
    { name: 'mac', modernName: 'mac', convert: structConverter(_HmacSha256Mac) },
  ],
});
export const AuthenticatedMessageV0 = _AuthenticatedMessageV0 as unknown as {
  new(attributes: { sequence: Uint64; message: StellarMessage; mac: HmacSha256Mac }): AuthenticatedMessageV0;
  read(io: Buffer): AuthenticatedMessageV0;
  write(value: AuthenticatedMessageV0, io: Buffer): void;
  isValid(value: AuthenticatedMessageV0): boolean;
  toXDR(value: AuthenticatedMessageV0): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AuthenticatedMessageV0;
  fromXDR(input: string, format: 'hex' | 'base64'): AuthenticatedMessageV0;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface AuthenticatedMessage {
  switch(): number;
  v0(value?: AuthenticatedMessageV0): AuthenticatedMessageV0;
  value(): AuthenticatedMessageV0;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _AuthenticatedMessage = createCompatUnion({
  codec: modern.AuthenticatedMessage,
  switchEnum: null,
  arms: [
    { switchValues: [0], modern: 0, arm: 'v0', convert: id },
  ],
});
export const AuthenticatedMessage = _AuthenticatedMessage as unknown as {
  0(value: AuthenticatedMessageV0): AuthenticatedMessage;
  read(io: Buffer): AuthenticatedMessage;
  write(value: AuthenticatedMessage, io: Buffer): void;
  isValid(value: AuthenticatedMessage): boolean;
  toXDR(value: AuthenticatedMessage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): AuthenticatedMessage;
  fromXDR(input: string, format: 'hex' | 'base64'): AuthenticatedMessage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export const LIQUIDITY_POOL_FEE_V18 = 30;

export type SorobanAuthorizationEntries = SorobanAuthorizationEntry[];
export const SorobanAuthorizationEntries = createCompatTypedef({ codec: modern.SorobanAuthorizationEntries, convert: arrayConverter(structConverter(_SorobanAuthorizationEntry)) });

export interface HashIdPreimageOperationId {
  sourceAccount(value?: AccountId): AccountId;
  seqNum(value?: SequenceNumber): SequenceNumber;
  opNum(value?: Uint32): Uint32;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HashIdPreimageOperationId = createCompatStruct({
  codec: modern.HashIDPreimageOperationID,
  fields: [
    { name: 'sourceAccount', modernName: 'sourceAccount', convert: unionConverter(_PublicKey) },
    { name: 'seqNum', modernName: 'seqNum', convert: int64Conv },
    { name: 'opNum', modernName: 'opNum', convert: id },
  ],
});
export const HashIdPreimageOperationId = _HashIdPreimageOperationId as unknown as {
  new(attributes: { sourceAccount: AccountId; seqNum: SequenceNumber; opNum: Uint32 }): HashIdPreimageOperationId;
  read(io: Buffer): HashIdPreimageOperationId;
  write(value: HashIdPreimageOperationId, io: Buffer): void;
  isValid(value: HashIdPreimageOperationId): boolean;
  toXDR(value: HashIdPreimageOperationId): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HashIdPreimageOperationId;
  fromXDR(input: string, format: 'hex' | 'base64'): HashIdPreimageOperationId;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HashIdPreimageRevokeId {
  sourceAccount(value?: AccountId): AccountId;
  seqNum(value?: SequenceNumber): SequenceNumber;
  opNum(value?: Uint32): Uint32;
  liquidityPoolId(value?: PoolId): PoolId;
  asset(value?: Asset): Asset;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HashIdPreimageRevokeId = createCompatStruct({
  codec: modern.HashIDPreimageRevokeID,
  fields: [
    { name: 'sourceAccount', modernName: 'sourceAccount', convert: unionConverter(_PublicKey) },
    { name: 'seqNum', modernName: 'seqNum', convert: int64Conv },
    { name: 'opNum', modernName: 'opNum', convert: id },
    { name: 'liquidityPoolId', modernName: 'liquidityPoolID', convert: id },
    { name: 'asset', modernName: 'asset', convert: unionConverter(_Asset) },
  ],
});
export const HashIdPreimageRevokeId = _HashIdPreimageRevokeId as unknown as {
  new(attributes: { sourceAccount: AccountId; seqNum: SequenceNumber; opNum: Uint32; liquidityPoolId: PoolId; asset: Asset }): HashIdPreimageRevokeId;
  read(io: Buffer): HashIdPreimageRevokeId;
  write(value: HashIdPreimageRevokeId, io: Buffer): void;
  isValid(value: HashIdPreimageRevokeId): boolean;
  toXDR(value: HashIdPreimageRevokeId): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HashIdPreimageRevokeId;
  fromXDR(input: string, format: 'hex' | 'base64'): HashIdPreimageRevokeId;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HashIdPreimageContractId {
  networkId(value?: Hash): Hash;
  contractIdPreimage(value?: ContractIdPreimage): ContractIdPreimage;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HashIdPreimageContractId = createCompatStruct({
  codec: modern.HashIDPreimageContractID,
  fields: [
    { name: 'networkId', modernName: 'networkID', convert: id },
    { name: 'contractIdPreimage', modernName: 'contractIDPreimage', convert: unionConverter(_ContractIdPreimage) },
  ],
});
export const HashIdPreimageContractId = _HashIdPreimageContractId as unknown as {
  new(attributes: { networkId: Hash; contractIdPreimage: ContractIdPreimage }): HashIdPreimageContractId;
  read(io: Buffer): HashIdPreimageContractId;
  write(value: HashIdPreimageContractId, io: Buffer): void;
  isValid(value: HashIdPreimageContractId): boolean;
  toXDR(value: HashIdPreimageContractId): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HashIdPreimageContractId;
  fromXDR(input: string, format: 'hex' | 'base64'): HashIdPreimageContractId;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HashIdPreimageSorobanAuthorization {
  networkId(value?: Hash): Hash;
  nonce(value?: Int64): Int64;
  signatureExpirationLedger(value?: Uint32): Uint32;
  invocation(value?: SorobanAuthorizedInvocation): SorobanAuthorizedInvocation;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HashIdPreimageSorobanAuthorization = createCompatStruct({
  codec: modern.HashIDPreimageSorobanAuthorization,
  fields: [
    { name: 'networkId', modernName: 'networkID', convert: id },
    { name: 'nonce', modernName: 'nonce', convert: int64Conv },
    { name: 'signatureExpirationLedger', modernName: 'signatureExpirationLedger', convert: id },
    { name: 'invocation', modernName: 'invocation', convert: lazyConverter(() => structConverter(_SorobanAuthorizedInvocation)) },
  ],
});
export const HashIdPreimageSorobanAuthorization = _HashIdPreimageSorobanAuthorization as unknown as {
  new(attributes: { networkId: Hash; nonce: Int64; signatureExpirationLedger: Uint32; invocation: SorobanAuthorizedInvocation }): HashIdPreimageSorobanAuthorization;
  read(io: Buffer): HashIdPreimageSorobanAuthorization;
  write(value: HashIdPreimageSorobanAuthorization, io: Buffer): void;
  isValid(value: HashIdPreimageSorobanAuthorization): boolean;
  toXDR(value: HashIdPreimageSorobanAuthorization): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HashIdPreimageSorobanAuthorization;
  fromXDR(input: string, format: 'hex' | 'base64'): HashIdPreimageSorobanAuthorization;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HashIdPreimage {
  switch(): EnvelopeType;
  operationId(value?: HashIdPreimageOperationId): HashIdPreimageOperationId;
  revokeId(value?: HashIdPreimageRevokeId): HashIdPreimageRevokeId;
  contractId(value?: HashIdPreimageContractId): HashIdPreimageContractId;
  sorobanAuthorization(value?: HashIdPreimageSorobanAuthorization): HashIdPreimageSorobanAuthorization;
  value(): HashIdPreimageOperationId | HashIdPreimageRevokeId | HashIdPreimageContractId | HashIdPreimageSorobanAuthorization;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HashIdPreimage = createCompatUnion({
  codec: modern.HashIDPreimage,
  switchEnum: _EnvelopeType,
  arms: [
    { switchValues: ['envelopeTypeOpId'], modern: 'OpId', arm: 'operationId', convert: id },
    { switchValues: ['envelopeTypePoolRevokeOpId'], modern: 'PoolRevokeOpId', arm: 'revokeId', convert: id },
    { switchValues: ['envelopeTypeContractId'], modern: 'ContractId', arm: 'contractId', convert: id },
    { switchValues: ['envelopeTypeSorobanAuthorization'], modern: 'SorobanAuthorization', arm: 'sorobanAuthorization', convert: id },
  ],
});
export const HashIdPreimage = _HashIdPreimage as unknown as {
  envelopeTypeOpId(value: HashIdPreimageOperationId): HashIdPreimage;
  envelopeTypePoolRevokeOpId(value: HashIdPreimageRevokeId): HashIdPreimage;
  envelopeTypeContractId(value: HashIdPreimageContractId): HashIdPreimage;
  envelopeTypeSorobanAuthorization(value: HashIdPreimageSorobanAuthorization): HashIdPreimage;
  read(io: Buffer): HashIdPreimage;
  write(value: HashIdPreimage, io: Buffer): void;
  isValid(value: HashIdPreimage): boolean;
  toXDR(value: HashIdPreimage): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HashIdPreimage;
  fromXDR(input: string, format: 'hex' | 'base64'): HashIdPreimage;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionSignaturePayloadTaggedTransaction {
  switch(): EnvelopeType;
  tx(value?: Transaction): Transaction;
  feeBump(value?: FeeBumpTransaction): FeeBumpTransaction;
  value(): Transaction | FeeBumpTransaction;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionSignaturePayloadTaggedTransaction = createCompatUnion({
  codec: modern.TransactionSignaturePayloadTaggedTransaction,
  switchEnum: _EnvelopeType,
  arms: [
    { switchValues: ['envelopeTypeTx'], modern: 'Tx', arm: 'tx', convert: structConverter(_Transaction) },
    { switchValues: ['envelopeTypeTxFeeBump'], modern: 'TxFeeBump', arm: 'feeBump', convert: structConverter(_FeeBumpTransaction) },
  ],
});
export const TransactionSignaturePayloadTaggedTransaction = _TransactionSignaturePayloadTaggedTransaction as unknown as {
  envelopeTypeTx(value: Transaction): TransactionSignaturePayloadTaggedTransaction;
  envelopeTypeTxFeeBump(value: FeeBumpTransaction): TransactionSignaturePayloadTaggedTransaction;
  read(io: Buffer): TransactionSignaturePayloadTaggedTransaction;
  write(value: TransactionSignaturePayloadTaggedTransaction, io: Buffer): void;
  isValid(value: TransactionSignaturePayloadTaggedTransaction): boolean;
  toXDR(value: TransactionSignaturePayloadTaggedTransaction): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionSignaturePayloadTaggedTransaction;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionSignaturePayloadTaggedTransaction;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface TransactionSignaturePayload {
  networkId(value?: Hash): Hash;
  taggedTransaction(value?: TransactionSignaturePayloadTaggedTransaction): TransactionSignaturePayloadTaggedTransaction;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _TransactionSignaturePayload = createCompatStruct({
  codec: modern.TransactionSignaturePayload,
  fields: [
    { name: 'networkId', modernName: 'networkId', convert: id },
    { name: 'taggedTransaction', modernName: 'taggedTransaction', convert: id },
  ],
});
export const TransactionSignaturePayload = _TransactionSignaturePayload as unknown as {
  new(attributes: { networkId: Hash; taggedTransaction: TransactionSignaturePayloadTaggedTransaction }): TransactionSignaturePayload;
  read(io: Buffer): TransactionSignaturePayload;
  write(value: TransactionSignaturePayload, io: Buffer): void;
  isValid(value: TransactionSignaturePayload): boolean;
  toXDR(value: TransactionSignaturePayload): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): TransactionSignaturePayload;
  fromXDR(input: string, format: 'hex' | 'base64'): TransactionSignaturePayload;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface Curve25519Secret {
  key(value?: Buffer): Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _Curve25519Secret = createCompatStruct({
  codec: modern.Curve25519Secret,
  fields: [
    { name: 'key', modernName: 'key', convert: id },
  ],
});
export const Curve25519Secret = _Curve25519Secret as unknown as {
  new(attributes: { key: Buffer }): Curve25519Secret;
  read(io: Buffer): Curve25519Secret;
  write(value: Curve25519Secret, io: Buffer): void;
  isValid(value: Curve25519Secret): boolean;
  toXDR(value: Curve25519Secret): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): Curve25519Secret;
  fromXDR(input: string, format: 'hex' | 'base64'): Curve25519Secret;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface HmacSha256Key {
  key(value?: Buffer): Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _HmacSha256Key = createCompatStruct({
  codec: modern.HmacSha256Key,
  fields: [
    { name: 'key', modernName: 'key', convert: id },
  ],
});
export const HmacSha256Key = _HmacSha256Key as unknown as {
  new(attributes: { key: Buffer }): HmacSha256Key;
  read(io: Buffer): HmacSha256Key;
  write(value: HmacSha256Key, io: Buffer): void;
  isValid(value: HmacSha256Key): boolean;
  toXDR(value: HmacSha256Key): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): HmacSha256Key;
  fromXDR(input: string, format: 'hex' | 'base64'): HmacSha256Key;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface ShortHashSeed {
  seed(value?: Buffer): Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _ShortHashSeed = createCompatStruct({
  codec: modern.ShortHashSeed,
  fields: [
    { name: 'seed', modernName: 'seed', convert: id },
  ],
});
export const ShortHashSeed = _ShortHashSeed as unknown as {
  new(attributes: { seed: Buffer }): ShortHashSeed;
  read(io: Buffer): ShortHashSeed;
  write(value: ShortHashSeed, io: Buffer): void;
  isValid(value: ShortHashSeed): boolean;
  toXDR(value: ShortHashSeed): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): ShortHashSeed;
  fromXDR(input: string, format: 'hex' | 'base64'): ShortHashSeed;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

export interface BinaryFuseFilterType {
  readonly name: 'binaryFuseFilter8Bit' | 'binaryFuseFilter16Bit' | 'binaryFuseFilter32Bit';
  readonly value: 0 | 1 | 2;
}
const _BinaryFuseFilterType = createCompatEnum({
  codec: modern.BinaryFuseFilterType,
  members: [
    { compat: 'binaryFuseFilter8Bit', modern: 'B8Bit', value: 0 },
    { compat: 'binaryFuseFilter16Bit', modern: 'B16Bit', value: 1 },
    { compat: 'binaryFuseFilter32Bit', modern: 'B32Bit', value: 2 },
  ],
});
export const BinaryFuseFilterType = _BinaryFuseFilterType as unknown as {
  binaryFuseFilter8Bit(): BinaryFuseFilterType;
  binaryFuseFilter16Bit(): BinaryFuseFilterType;
  binaryFuseFilter32Bit(): BinaryFuseFilterType;
};

export interface SerializedBinaryFuseFilter {
  type(value?: BinaryFuseFilterType): BinaryFuseFilterType;
  inputHashSeed(value?: ShortHashSeed): ShortHashSeed;
  filterSeed(value?: ShortHashSeed): ShortHashSeed;
  segmentLength(value?: Uint32): Uint32;
  segementLengthMask(value?: Uint32): Uint32;
  segmentCount(value?: Uint32): Uint32;
  segmentCountLength(value?: Uint32): Uint32;
  fingerprintLength(value?: Uint32): Uint32;
  fingerprints(value?: Buffer): Buffer;
  toXDR(format?: 'raw'): Buffer;
  toXDR(format: 'hex' | 'base64'): string;
  [key: string]: any;
}
const _SerializedBinaryFuseFilter = createCompatStruct({
  codec: modern.SerializedBinaryFuseFilter,
  fields: [
    { name: 'type', modernName: 'type', convert: enumConverter(_BinaryFuseFilterType) },
    { name: 'inputHashSeed', modernName: 'inputHashSeed', convert: structConverter(_ShortHashSeed) },
    { name: 'filterSeed', modernName: 'filterSeed', convert: structConverter(_ShortHashSeed) },
    { name: 'segmentLength', modernName: 'segmentLength', convert: id },
    { name: 'segementLengthMask', modernName: 'segementLengthMask', convert: id },
    { name: 'segmentCount', modernName: 'segmentCount', convert: id },
    { name: 'segmentCountLength', modernName: 'segmentCountLength', convert: id },
    { name: 'fingerprintLength', modernName: 'fingerprintLength', convert: id },
    { name: 'fingerprints', modernName: 'fingerprints', convert: id },
  ],
});
export const SerializedBinaryFuseFilter = _SerializedBinaryFuseFilter as unknown as {
  new(attributes: { type: BinaryFuseFilterType; inputHashSeed: ShortHashSeed; filterSeed: ShortHashSeed; segmentLength: Uint32; segementLengthMask: Uint32; segmentCount: Uint32; segmentCountLength: Uint32; fingerprintLength: Uint32; fingerprints: Buffer }): SerializedBinaryFuseFilter;
  read(io: Buffer): SerializedBinaryFuseFilter;
  write(value: SerializedBinaryFuseFilter, io: Buffer): void;
  isValid(value: SerializedBinaryFuseFilter): boolean;
  toXDR(value: SerializedBinaryFuseFilter): Buffer;
  fromXDR(input: Buffer, format?: 'raw'): SerializedBinaryFuseFilter;
  fromXDR(input: string, format: 'hex' | 'base64'): SerializedBinaryFuseFilter;
  validateXDR(input: Buffer, format?: 'raw'): boolean;
  validateXDR(input: string, format: 'hex' | 'base64'): boolean;
};

